---

title: Providing restartable file systems within computing devices
abstract: In general, techniques are described for enabling a restartable file system. A computing device comprising a processor that executes an operating system may implement the techniques. The processor executes kernel and file system functions of the operating system to perform an operation, where both types of functions call each other to perform the operation. The operating system stores data identifying those of the kernel functions that called the file system functions. In response to determining that one of the file system functions that was called has failed, the operating system accesses the data to identify one of the kernel functions that most recently called one of the file system functions, and returns control to the identified one of the kernel functions without executing any of the file system functions called after the identified one of the kernel functions and prior to the one of the file system functions that failed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08510597&OS=08510597&RS=08510597
owner: Wisconsin Alumni Research Foundation
number: 08510597
owner_city: Madison
owner_country: US
publication_date: 20110208
---
This invention was made with government support under 0621487 and 0509474 awarded by the National Science Foundation. The government has certain rights in the invention.

The invention relates to computing devices and more particularly the execution of file systems within computing devices.

A computing device typically executes software referred to as an operating system to provide an environment in which programs or other executables generally referred to as software applications may execute. The operating system manages the hardware resources of the computing device and typically presents what is referred to as an application programming interface API with the software applications interact to utilize the underlying hardware resources provided by the computing devices. The hardware resources typically include storage devices e.g. hard drives compact disc drives and digital video disc drives memories e.g. random access memory dynamic random access memory and static random access memory graphics cards card readers printers keyboards mice network interfaces or any other type of hardware provided by or included within computing devices. The applications generally invoke one or more functions provided by the API to access this hardware through the operating system. The operating system generally manages any interrupts exceptions and faults that result from such function calls and otherwise acts as an intermediary between the applications and the underlying hardware.

To provide the applications access to data stored to memories and storage devices the operating system typically includes internal software that provides one or more file systems. A file system is a logical construct that defines the manner in which data is stored on media such as permanent storage devices accessible to the computing system. Typically the file system components of the operating system operates on discrete portions of data referred to as files and organizes these files into a hierarchical structure for the storage organization manipulation and retrieval by the operating system. The hierarchical structure is generally defined in terms of directories or so called folders and sub directories so called sub folders . The file system maps various physical areas of the underlying storage devices to the directories and sub directories of the hierarchical structure and defines which areas are used to store which files and which areas are currently available to store additional files. For example the file system may store data mapping at least a portion of a file to a particular sector of a hard drive as well as other metadata defining the file name date of file creation size of the file and the like.

While operating systems are carefully constructed to provide a secure and consistent operating environment for the software applications the operating system may experience faults that crash or otherwise prevent successful execution of the operating system. Faults that occur in the file system for example due to software errors or so called bugs in the program code providing the file system of the operating system or transient faults in the device hardware generally lead to total failure of the entire operating system as a result of the importance of the file system to stable execution of the operating system. To illustrate a fault in the file system code may impact the mapping of data to areas of the memories and storage devices which may effectively lead to loss of data. Consequently in response to file system faults or other failures if handled gracefully the operating system typically if handled gracefully requests that the computing device be restarted to overcome the failure or if not well handled shuts down without much in the way of warning forcing a restart of the computing device. This forced shutdown or restart impacts the usability of the computing device. In addition the current state of software applications being executed by the operating system as well as some incremental user data not yet written to the storage devices may be lost. The operating system may attempt data recovery operations in an attempt to recover this lost application state data and incremental user data but these recovery operations are usually only partially successful.

In general techniques are described for providing restartable file systems of operating systems within computing devices. As described the techniques may allow a computing device to avoid a restart of the operating systems to overcome certain faults or other failures with the file system code of the operating system. In order to provide this type of restartable file system the techniques create what may be viewed as a logical membrane around the file system of the operating system to better manage the file system and in instances of file system failure isolate the failure to the file system without overly impacting either execution of the supporting components of the operating system or software applications executing within the operating environment provided by the operating system.

The techniques provide the logical membrane around the file system code through the creation of file system checkpoints and inter checkpoint logs. In response to a file system failure the techniques effectively isolate the file system by delaying pending but not yet started file system processes and halting those file system processes currently being executed. Once halted the techniques unwind the existing file system processes to effectively remove these current processes by leveraging current fault management aspects of the operating system. After unwinding the processes the techniques may un mount the faulted file system remount the file system from the last file system checkpoint and rebuild the previous file system state based on the last checkpoint and inter checkpoint logs. Once the file system is rebuilt the techniques may resume those halted file system processes and begin accepting the pending but not yet started file system processes. Through isolation of the file system in this manner the techniques may avoid restarting the operating systems in response to file system failure which may greatly improve the user experience associated with operating systems that feature these techniques while also promoting more stable and functional operating systems.

In one embodiment a method comprises executing an operating system with a computing device to provide an operating environment for execution of a software application receiving a request from the software application with the operating system wherein the request specifies an operation to be performed by the operating system with respect to one of the plurality of files managed by a file system of the operating system and executing with the computing device one or more kernel functions of the operating system and one or more file system functions provided by program code of the file system to perform the operation wherein the kernel functions call the file system functions to perform the operation and wherein the file system functions also call the kernel functions to perform the operation. The method also comprises maintaining a stack with the computing device that stores data identifying those of the kernel functions that called the file system functions but not those of the file system functions that called the kernel functions in response to determining that one of the file system functions that was called has failed accessing the stack with the computing device to identify one of the kernel functions that most recently called one of the file system functions and returning control of execution to the identified one of the kernel functions that most recently called the one of the file system functions without executing any of the file system functions called after the one of the kernel functions that most recently called the one of the file system functions but before the one of the file system functions that failed. The method further comprises detecting attempted execution of a second one of the file system functions after returning control of execution to the identified first one of the kernel functions in response to detecting the attempted execution of the second one of the file system functions accessing the stack to identify a second one of the kernel functions that most recently called the second one of the file system functions for which execution was attempted and returning control of execution to the identified second one of the kernel functions without executing the second one of the file system functions.

In another embodiment a computing device comprising a processor a storage device that stores at least some of a plurality of files and an operating system executed by the processor to provide an operating environment for execution of a software application and receive a request from the software application executing in the operating environment wherein the request specifies an operation to be performed by the operating system with respect to one of the plurality of files managed by a file system of the operating system. The processor executes one or more kernel functions of the operating system and one or more file system functions provided by program code of the file system to perform the operation wherein the kernel functions call the file system functions to perform the operation and wherein the file system functions also call the kernel functions to perform the operation. The operating system maintains a stack that stores data identifying those of the kernel functions that called the file system functions but not those of the file system functions that called the kernel functions in response to determining that one of the file system functions that was called has failed accesses the stack to identify one of the kernel functions that most recently called one of the file system functions and returns control of execution to the identified one of the kernel functions that most recently called the one of the file system functions without executing any of the file system functions called after the one of the kernel functions that most recently called the one of the file system functions but before the one of the file system functions that failed. The operating system also detects attempted execution of a second one of the file system functions after returning control of execution to the identified first one of the kernel functions in response to detecting the attempted execution of the second one of the file system functions accessing the stack to identify a second one of the kernel functions that most recently called the second one of the file system functions for which execution was attempted and returns control of execution to the identified second one of the kernel functions without executing the second one of the file system functions.

In another embodiment a non transitory computer readable medium comprising instructions that when executed cause one or more processors to execute an operating system to provide an operating environment for execution of a software application receive a request from the software application with the operating system wherein the request specifies an operation to be performed by the operating system with respect to one of the plurality of files managed by a file system of the operating system execute one or more kernel functions of the operating system and one or more file system functions provided by program code of the file system to perform the operation wherein the kernel functions call the file system functions to perform the operation and wherein the file system functions also call the kernel functions to perform the operation maintain a stack that stores data identifying those of the kernel functions that called the file system functions but not those of the file system functions that called the kernel functions in response to determining that one of the file system functions that was called has failed access the stack to identify one of the kernel functions that most recently called one of the file system functions and return control of execution to the identified one of the kernel functions that most recently called the one of the file system functions without executing any of the file system functions called after the one of the kernel functions that most recently called the one of the file system functions that failed but before the one of the file system functions that failed. The non transitory computer readable medium also comprises instruction that when executed cause the one or more processors to detect attempted execution of a second one of the file system functions after returning control of execution to the identified first one of the kernel functions in response to detecting the attempted execution of the second one of the file system functions access the stack to identify a second one of the kernel functions that most recently called the second one of the file system functions for which execution was attempted and return control of execution to the identified second one of the kernel functions without executing the second one of the file system functions.

In another embodiment a method comprises executing a first software module with one or more computing devices executing a second software module different than the first software module with the one or more computing devices wherein the first software module calls one or more functions of the second software module to perform an operation and wherein the second software module calls one or more functions of the first software module to perform the operation and maintaining a stack with the one or more computing devices that stores data identifying those of the one or more functions of the first software module that called the one or more functions of the second software module but not those of the one or more functions of the second software module that called the one or more functions of the first software module. The method also comprises in response to determining that one of the one or more functions of the second software module that was called has failed accessing the stack with the one or more computing devices to identify one of the one or more functions of the first software module that most recently called one of the one or more functions of the second software module and returning control of execution to the identified one of the one or more functions of the first software module that most recently called the one of the one or more functions of the second software module without executing any of the one or more functions of the second software module called after the one of the one or more functions of the first software module that most recently called the one of the one or more functions of the second software module but before the one of the one or more functions of the second software module that failed. The method further comprises detecting attempted execution of a second one of the functions of the second software module after returning control of execution to the identified first one of the functions of the first software module in response to detecting the attempted execution of the second one of the functions of the second software module accessing the stack to identify a second one of the functions of the first software module that most recently called the second one of the functions of the second software module for which execution was attempted and returning control of execution to the identified second one of the functions of the first software module without executing the second one of the functions of the second software module.

The details of one or more embodiments of the techniques are set forth in the accompanying drawings and the description below. Other features objects and advantages of the techniques will be apparent from the description and drawings and from the claims.

As shown in the example of computing device includes a control unit . Control unit may represent one or more processors not shown in that execute software instructions such as those used to define a software or computer program stored to a computer readable storage medium again not shown in such as a storage device e.g. a disk drive or an optical drive or memory such as Flash memory random access memory or RAM or any other type of volatile or non volatile memory that stores instructions to cause a programmable processor to perform the techniques described herein. Alternatively control unit may represent dedicated hardware such as one or more integrated circuits one or more Application Specific Integrated Circuits ASICs one or more Application Specific Special Processors ASSPs one or more Field Programmable Gate Arrays FPGAs or any combination of one or more of the foregoing examples of dedicated hardware for performing the techniques described herein.

Control unit executes an operating system which represents software that generally provides an execution environment in which software applications A N applications may execute. In providing this execution environment operating system enables applications to interact or otherwise interface with the underlying physical hardware of computing device which is generally represented by control unit to the extent that control unit may represent processors memories and storage drives and or dedicated hardware. While not shown in the example of computing device may include other hardware such as busses television capture cards graphic cards network interfaces wireless communication interfaces keyboards mice touch screens or any other type of hardware that is commonly included within a computing device.

In providing this execution environment operating system includes a system call interface SCI module SCI module that presents an interface by which applications may invoke functions provided by operating system for use in interfacing with operating system . Through these functions of SCI module applications may communicate with operating system . SCI module provides standard routines or functions for many common operations including reading and writing from memory or storage drives inter process or thread communication or any other operation that requires privileges beyond ordinary user privileges to perform. Common system calls may include an open system call to open a file a write system call to write a file a read system call to read a file a close system call to close an open file a wait system call to wait for a particular thread or a group of threads a fork system call that forks a process an exit system call and a kill system call to kill or otherwise terminate a process. The term process refers to an instance of a computer program such as one of applications that is being executed. A process may include one or more threads of execution that execute instructions concurrently. A thread refers to the smallest unit of execution that can be scheduled by an operating system and generally represents a sequence of one or more software instructions executed by the processor

In the example of applications currently being executed by control unit may represent processes or instances of the underlying computer program stored to a memory and or storage device. That is applications may represent computer programs when stored to memory or a storage device and processes when executed. In the current example of it is assumed that applications are processes currently being executed by control unit . Applications may include third party applications that are not provided with operating system and applications that are provided with operating system . Thus while shown executing outside of operating system one or more of applications may execute within operating system where these operating system applications may include system utilities and other processes that require privileges outside of ordinary user privileges to operate. Consequently the techniques should not be limited in this respect to the example of .

Operating system also includes a fault handler that represents software for handling operating system faults. Fault handler may provide certain fault functions used by other aspects or portions of the operating system to signal faults or other unexpected behavior. For example the Linux operating system provides a panic function for use by other aspects or portions of the Linux operating system in signaling detection of an internal fatal error from which this aspect or portion of the operating system cannot recover. Fault handler may handle faults issued from both software and hardware.

Operating system further includes a virtual file system VFS and a file system to manage the storage and retrieval of data from underlying memories and physical drives such as hard drives optical drives so called thumb drives or any other type of volatile or non volatile memory and storage devices. VFS provides a layer of abstraction between FS and operating system so as to present a uniform interface to operating system while supporting multiple different types of file systems that may each have a different interface. That is each file system may include its own interface by which to read and write data maintain directories or folders in the Windows operating system and otherwise interact with the file system. Rather than require operating system to natively support the interface of each and every file system and make this interface available to each of applications VFS instead provides a uniform interface by which to access these different file systems. In providing this uniform interface VFS virtualizes the underlying file system in a manner such that it appears as one file system to operating system hence the name virtual file system. In response to operating system invoking various functions provided by this interface VFS translates these virtual interface function calls into file system specific function calls.

File system may represent any type of file system commonly supported by an operating system. Example file systems include an extended file system known commonly as ext a second extended file system commonly referred to as ext2 a third extended file system commonly known as ext3 a Unix file system UFS a hierarchical file system HFS a hierarchical file system plus HSF a file allocation table FAT file system including the FAT 12 FAT16 FAT32 and exFAT file systems a new technology file system NTFS and a high performance file system HPFS to name a few. File system generally stores data defining a hierarchical directory structure comprised of directories and sub directories. File system stores data associating a file to at least one of the directories or sub directories of the hierarchical directory structure. File system also maintains data identifying the location of the file whether this location is a local memory or storage device or a remote or networked memory or storage device. As noted above file system also includes code that provides a file system specific interface by which the files may be manipulated within the file system e.g. moved within deleted from copied read from or written to the hierarchical directory structure. While shown as including only a single file system the techniques may be implemented with respect to any number of file systems similar to file system . Accordingly the techniques should not be limited in this respect to the example of .

The program code of file system may interface or otherwise interact with a number of other aspects or portions of operating system in providing access to the underlying data. For example file system may interface with a page cache that provides a transparent buffer in memory such as RAM for the storage of so called pages of data from the hard drive or other physical storage devices to facilitate quicker access by the operating system to these pages of data. File system may also interface with a system heap which represents a heap data structure in a portion of memory available for use by the operating system for storing dynamically allocated data structures and run time data. System heap may be distinguished from an application heap in that system heap is only available for use by operating system while the application heap may be used by applications .

In addition file system as mentioned above stores a large amount of state information pertaining to the various state of files in the hierarchical data structure such as whether a file is open in the process of being edited in the process of being read in the process of being written or locked. File system also maintains or otherwise stores the location of the file in terms of a physical address and in terms of its location or position within the hierarchical data structure. File system may store this data for hundreds thousands or even greater number of file. File system also ensures the integrity of the files as corrupted files represents lost data that may impact the user and or the execution of the operating system or applications. File system further ensures the integrity of the state data as corrupted state data may lead to overwriting valid data in a disk drive or other fault write or read that corrupts files.

Because file system interfaces with a wide number of portions or aspects of operating system and maintains or otherwise stores a large amount of state data faults occurring in file system are often debilitating in terms of the continued execution of the hosting operating system i.e. operating system in this example and require restart of this operating system to overcome the faults. These faults are often a result of software bugs in file system where such bugs are difficult to eliminate from file system due in part to its complexity and size. Moreover new file systems are frequently being introduced to accommodate new uses of computing devices and files. These new file systems may not be as well tested as older and more hardened file systems that have undergone repeated updates to correct for these deficiencies. As a result software bugs may be considered an inevitable part of file systems due to their complex highly stateful and evolving nature.

In encountering a fault file systems ordinarily resort to the above mentioned panic function which typically causes fault handler to report the fault by way of a fault code and provide an accompanying kernel memory dump to facilitate some amount of debugging. In Windows operating systems this report is commonly known as the blue screen of death because the screen that provides this report and memory dump has a blue colored background. In any event once fault handler issues this report and memory dump the operating system becomes unresponsive and halts the execution of applications and any other process executing within the computing device. The user typically must restart the computing device which in turn restarts the operating system. The restarted operating system reloads the file system but any data not saved before the panic function was invoked is more than likely lost considering that this data was more than likely stored to volatile memory such as RAM and was not written to a storage device prior to the occurrence of the fault. While the interruption in execution may impact usability of the computing device the loss of data may negatively impact the user experience especially if that data was attributed some importance by a user.

In accordance with the techniques described in this disclosure operating system constructs what may be considered a membrane around file system that enables better management of file system and in instances of file system failure isolate the failure to file system without overly impacting either execution of supporting operating system or applications executing within operating or execution environment provided by operating system . This membrane effectively represents a way by which to carefully monitor and log the operation of underlying file systems . The monitoring and logging occurs primarily by way of file system snapshots or checkpoints in which the logical or transient state of file system page cache and the underlying storage devices are captured. The monitoring and logging also occurs by way of inter checkpoint logging to capture the state of file system page cache and the underlying storage devices between checkpoints.

In response to detecting the occurrence of a fault in file system membrane may prevent successive file system operations from reaching file system . In this sense membrane may be considered selectively permeable in that file system operations invoked by operating system either on behalf of operating system itself or applications may only be permitted to permeate membrane during select times. Membrane may also block file system operations when checkpointing or performing other logging operations. Membrane halts or otherwise prevents operations from reaching file system and in some instances virtual file system so as to isolate file system from the remaining portions of operating system . This isolation enables file system to be unmounted remounted and restored without overly impacting either execution of supporting operating system or applications executing within operating or execution environment provided by operating system .

To provide this logical membrane operating system has been adapted to provide a checkpoint manager and a recovery manager . Checkpoint manager represents a module responsible for storing checkpoint data and inter checkpoint log data log data . Checkpoint data represents data that defines one or more checkpoints capturing the current state of file system page cache and any underlying storage devices. Log data represents any state changes to the most recent checkpoint and for this reason are referred to as inter checkpoint log data. Recovery manager represents a file system recovery module that manages recovery of faults that occur in file system . Fault handler may be adapted or otherwise configured to divert control of the recovery process to recovery manager upon determining that the fault originated in file system . Recovery manager then orchestrates the recovery of file system in accordance with one or more aspects of the techniques set forth in this disclosure and described in more detail below.

Checkpoint manager and recover manager are aided in their respective operations by a checkpoint agent and a recovery agent . Checkpoint agent may represent a shim module placed between VFS and FS so as to monitor and log operations issued by virtual file system to file system . Checkpoint agent may also isolate FS from VFS which may involve halting operations or invocation of file system specific functions by VFS so that a checkpoint or snapshot may be completed without impacting those operations or the resulting checkpoint or snapshot. Recovery agent represents another shim module placed between VFS and the remaining portions of operating system that in response to a fault halts or otherwise stops operations or invocation of VFS functions from reaching VFS . By halting these operations recovery agent may halt these operations to ensure that these operations do not access any corrupt or inconsistent file system state data until the recovery is complete. In this sense recovery agent may isolate file system from operating system and thereby allow for recovery manager to unmount file system remount file system using checkpoint data and restore file system to its previous state using log data .

In the example of both checkpoint manager and recovery manager communicate with both of checkpoint agent and recovery agent . In a sense checkpoint agent and recovery agent may provide an interface by which recovery manager and checkpoint manager may communicate with one another. While described in this manner with respect to the example of checkpoint manager may instead include an interface separate from checkpoint agent by which recovery manager may communicate with checkpoint manger and likewise recovery manager may provide an interface separate from recovery agent by which checkpoint manager may communicate with recovery manager . Moreover checkpoint and recover managers may be implemented as a single restartable file system unit or module that implements the techniques described in this disclosure. In this respect the techniques should not be limited to the example of and may be implemented in any number of ways so as to provide for the limited impact restoration of file system .

In operation operating system receives system calls via SCI module one or more of which may involve operations to be performed by file system such as an open system call to open a file stored by file system . Assuming for purposes of example that SCI module receives an open system call SCI module may transmit log data to checkpoint manager informing checkpoint manager of the open system call. As file system executes this open system call one or more functions provided by VFS may be invoked. VFS may execute these functions by invoking one or more file system specific functions which checkpoint agent may monitor and log passing log data back to checkpoint manager . Checkpoint manager may receive a number of other types of log data from for example a memory management or allocation module of operating system not shown in the example of that maintains system heap file system and page cache which is described in more detail below.

At periodic intervals checkpoint manager may take a snapshot of file system and store this snapshot as a checkpoint within checkpoint data . This snapshot may capture the current state of file system including page cache and any underlying storage devices. As described below in more detail the checkpoint process may involve a number of techniques to reduce or even eliminate the need to maintain log data in that the checkpoint may make this log data redundant or outdated. After checkpointing in this manner checkpoint manager typically discards log data and for this reason log data is referred to as inter checkpoint log data . Checkpoint manager continues to log and checkpoint in the manner described above until fault handler identifies a fault that originated in file system .

In response to detecting that a fault originated in file system fault handler redirects control of the recovery process to recovery manager . Recovery manager may first isolate file subsystem from operating system and thereby from applications by instructing recovery agent to block any pending but not yet started operations until recovery manager specifies otherwise. Recovery manager may then unwind any operations currently being performed by file system using log data . Recovery manager may implement what may be referred to as a skip trust unwind protocol. This skip trust unwind protocol skips over file system calls or operations by returning an error code for these operations. When forming log data checkpoint manager may store error codes for each system call that involves the file system. Recovery manager may harvest these error codes from log data and provide these error codes to the calling portion of operating system which in this case may be referred to as the operating system kernel or kernel. The kernel represents as its name suggests the core operating system module responsible for the core functionality of operating system . The kernel is typically the central module that facilitates interoperability between the peripheral modules of the operating system. The kernel typically includes SCI module to provide an interface with applications and device drivers to interface with the underlying hardware. The kernel also typically includes fault handler and other interrupt and exception mechanisms.

The kernel in this example receives the error code and invokes fault handler which handles the call. Fault handler may return control to the function that invoked the function of the kernel which in some examples may return control back to one or more functions of file system . Upon returning control to file system the processor attempts to execute the referenced program code of file system but because this code has been marked as non executable as part of initiating the skip trust unwind protocol as described in more detail below issues a fault to fault handler . By issuing this fault the processor redirects control back to recovery manager upon determining that the fault originated with file system . Recovery manager may skip over the file system functions and return control back to the trusted kernel again by signaling the corresponding fault stored as log data by checkpoint manager . The kernel may again then handle the fault returned by recovery manager . In this respect recovery manager skips untrusted file system functions triggered by the open system call but trusts kernel functions triggered by the open system call. For this reason the process of unwinding currently executed operations may be referred to as a skip trust unwind protocol.

While described with respect to two specific portions of operating system i.e. the kernel and file system the unwind techniques described in this disclosure may be implemented with respect to any two intertwined portions of operating system . The phrase intertwined portions refers to any two software components of the operating system that invoke one another by system calls. In the example above the kernel includes software functions e.g. software functions of VFS that make system calls to invoke software functions of file system . In turn program code of file system includes software functions that make system calls to software functions of the kernel e.g. VFS . In this example the kernel and file system may be considered two intertwined portions of operating system . Generally when executing the first one of the intertwined portions of the operating system i.e. the kernel in this example the first one of the intertwined portions invokes the second one of the intertwined portions of the operating system i.e. file system in this example. Checkpoint manager in response to invoking file system stores data that enables recovery from a failure in executing the file system i.e. log data in this example. In this sense upon detecting such a fault recovery manager may recover from the file system fault based on log data to unwind execution of file system leveraging recovery operations provided by the kernel to unwind execution of the kernel system call. By leveraging these recovery operations the unwind techniques described in this disclosure effectively trust the kernel to be bug free and capable of recovery in this instance. While such trust may by unwarranted by trusting the kernel in this manner recovery manager may more efficiently and with less complexity recovery file system and checkpoint manager may not be required to perform more extensive inter checkpoint logging that may reduce performance of computing device .

After unwinding active or currently executed operations recovery manager may unmount file system and remount file system using the most recent checkpoint stored as checkpoint data . Recovery manager then reinitiate execution of previously unwound operations based on log data so as to restore the current state of file system before the fault. Recovery manager may orchestrate this recovery process without requiring operating system to be restarted. After restoring this current pre fault state and upon the successful completion of the reinitiated operations recovery manager may instruct recovery agent to once again allow pending but not yet started operations to reach virtual file system and then file system . File system may then return a response to the open system call i.e. the data from page cache corresponding to the file specified in the open system call such that the issuing one of applications is unaware of the file system failure or fault.

In this way control unit executes operating system to provide operating environment in which applications execute where applications issue one or more requests to access a file stored to file system via system call interface module . Operating system then invokes file system to process the request. In processing the request file system may fail or otherwise fault resulting in a fault interrupt to fault handler . Fault handler may determine that the file system has failed or faulted and pass control to recovery manager which restores file system to a pre failure state without restarting the operating system. In some instances recovery manager restores file system to the state it was in when the fault or failure was detected. File system may then return a response to the request such that the application that issued the request is unaware of the failure and successive restore of the file system.

The techniques thereby provide this so called membrane through the creation of file system checkpoints and inter checkpoint logs. In response to a file system failure the techniques effectively isolate the file system by delaying pending but not yet started file system processes and halting those file system processes currently being executed. Once halted the techniques unwind the existing file system processes to effectively remove these current processes by leveraging current fault management aspects of the operating system. After unwinding the processes the techniques may un mount the faulted file system remount the file system from the last file system checkpoint and rebuild the previous file system state based on the inter checkpoint logs. Once the file system is rebuilt the techniques may resume those halted file system processes and begin accepting the pending but not yet started file system processes.

By way of tracking or monitoring various aspects of the virtual file system the techniques may learn or otherwise determine information about the virtual file system for replay of completed and in flight operations. i.e. inter checkpoint logs are replayed through the VFS layer without any support from the underlying file system in the example above. By monitoring the VFS layer the techniques may provide for a simplified restartable file system. In addition through isolation of the file system in this manner the techniques may avoid restarting the operating systems in response to file system failure which may greatly improve the user experience associated with operating systems that feature these techniques while also promoting more stable and functional operating systems.

Referring first to the example of SCI module includes system calls A N system calls each of which represents a function made available to applications . One or more of system calls may be adapted or otherwise configured to include a logging agent A N logging agents . Logging agents may be integrated within one or more function calls of their respective system calls such that when the respective one of system calls are invoked the corresponding one of logging agents may log file system calls or invocation of virtual file system functions as well as information of which of the functions that form the associated one of system calls invoked the file system function.

Checkpoint manager generally provides a form of what may be referred to as fault anticipation that may limit or otherwise minimize overhead while retaining the ability to restore file system . Checkpoint manager includes a checkpoint module and an inter checkpoint logging module . Checkpoint module represents a module that performs a lightweight process to checkpoint or in other words take a snapshot of file system and stores data regarding this checkpoint as checkpoints A N checkpoints . Checkpoint module partitions file system operations into different epochs or transactions and ensures that each of checkpoints represents a consistent state. Each of checkpoints A N represents a snapshot or checkpoint taken of file system at a different time or during a different epoch. While shown as storing more than one checkpoint checkpoint module may instead store only the most recent one of checkpoints and the techniques should not be limited in this respect to storing more than one checkpoint.

Inter checkpoint logging module represents a module that performs inter checkpoint logging to store log data . In effect inter checkpoint logging module stores data tracking updates to data structures and other state with a set of in memory logs and stacks. Multiple stacks may be maintained concurrently or in parallel for each process or thread. Log data may comprise a number of different logs A E in the form of traditional logs tables stacks or any other type of data structure or file.

Operation log A op log A represents a log that stores data recording all state modifying file system operations such as an open file system operation that have taken place between two successive checkpoints. Operation log A generally stores enough data to enable full recovery from any given one of checkpoints . Session log B represents a log that stores data tracking which files are open at the beginning of an epoch triggering a checkpoint and the current position of a file pointer within file system where a pointer refers to a data structure whose value refers directly to another value stored elsewhere in the computer memory using its address. The file pointer is the data structure maintained by the file system whose value refers to the address of the file currently being operating upon by file system . Malloc table C represents a table that stores data tracking heap allocated memory used by file system or more generally file system . File system may utilize system heap for storing dynamically allocated data structures and run time data used to facilitate the maintenance and storage of state data that defines file system . In the C programming language requests for additional dynamically allocated heap space are issued in the form of malloc function calls. Table C adopts the term malloc to refer to this function and imply that this table tracks requests for dynamically allocated heap memory.

Lock stack D represents a stack data structure storing data that tracks file lock acquires and releases within file system . A given file system thread executing in file system locks files prior to performing an operation with respect to the locked file to prevent another file system thread from concurrently operating on the same file. Locking files prevent file ownership conflicts that may result in lost data or uncommitted operations. Once a given operation with respect to the locked file is complete the file system thread that locked the file releases the lock. Lock stack D tracks these thread locks and releases in a stack data structure because the exact order of lock acquires and releases may be important to successfully restoring the state of file system . Lock stack D may comprise one or more lock stacks where each lock stack is associated with a different thread. Lock stack D may therefore include per thread lock stacks and push lock acquisitions by a thread onto the lock stack associated with that thread and pop lock acquisitions by the thread from the lock stack associated with that thread. Lock stack D may track all of the thread locks and releases or only a certain type of locks and releases such as global locks and releases as intra file system locks and releases are cleaned up and restored reacquired after restart while operations are replayed from the operation or session log. By storing or otherwise maintaining lock acquisitions in a last in first out LIFO order meaning that the lock stacks are so called LIFO stacks recovery manager is able to release them in the proper order as required. Unwind stack E represents a stack data structure that stores data tracking the execution of code in the file system and kernel. Unwind stack E may comprise per thread unwind stacks similar to the per thread lock stacks of lock stack D where register state is pushed onto the per thread unwind stacks when the file system is called on kernel to file system calls. Inter checkpoint logging module records sufficient information to this unwind stack E to unwind threads after a failure in file system has been detected in order to enable restoration of file system using the skip trust unwind protocol.

Generally log data may be grouped into two distinct groups. Malloc table C lock stack D and unwind stack are compensatory in nature as they are used to compensate for actions that have already taken place and should be undone before proceeding with restoration of file system . Operation log A and session log B are restorative in nature and are used by recovery manager to restore the in memory state of file system before continuing execution after restoration of file system .

Also shown in the example of is memory allocation module which represents another portion or component of operating system generally and more specifically the kernel of operating system . Memory allocation module represents a module responsible for managing memory and otherwise allocating memory for use by system heap . Memory allocation module may dynamically allocate additional unused portions of memory for use by system heap . Memory allocation module may be adapted or otherwise configured to include a logging agent LA LA where this logging agent forwards data regarding file system malloc function calls to inter checkpoint logging module for use in populating malloc table C.

In operation checkpoint manager receives log data from checkpoint agent logging agents and logging agent concerning the current state of file system . In response to receiving this log data checkpoint manager invokes inter checkpoint logging module which populates one or more operation log A session log B malloc table C lock stack D and unwind stack E with this log data. For example checkpoint agent generally monitors file system operations and transmits data concerning those operations that update the file system state to inter checkpoint logging module . To minimize the amount of operation log data logged checkpoint agent may only log data indicating that a write took place with respect to a particular file without logging the actual data written to the file. By only logging that a write took place with respect to a particular file checkpoint agent may greatly reduce the amount of memory required to store operation log A while also reducing overhead associated with maintaining operation log A.

Checkpoint agent avoids logging the actual data written by implementing what may be referred to as page stealing techniques. Files that have been edited via a write operation are commonly stored in page cache and may only be written to memory periodically. In response to detecting a fault in file system inter checkpoint logging module may steal these pages storing edited or what is commonly referred to as dirty files and write this dirty page to the underlying storage device for later retrieval once file system has been restored. Inter checkpoint logging module at this point before restoration of file system then updates operation log A to identify the location of the dirty page in the underlying persistent storage device for later use in restoring page cache to its current state. By only storing these pages to the persistent storage device in response to a file system fault inter checkpoint logging module avoids having to actually log any write data that edits a file These page stealing techniques also reducing the number of operations that need to be logged to operation log A in that inter checkpoint logging module only need to log the last write operation successfully completed with respect to each file as the edited file in the dirty page of page cache stores the most recent copy of the data. As a result of implementing these page stealing techniques inter checkpoint logging module may potentially avoid storing application data and successive write operations. Checkpoint agent moreover does not need to monitor log or record read operations as closely as write operations as these read operations will have either been completed or unwound and replayed in response to a fault. Read operations however do not modify the file and thus do not need to be replayed or repeated after a checkpoint to advance the file system to its state prior to the fault or failure. Checkpoint agent may monitor these read operations however to determine the current file position after a successful read operation.

Checkpoint agent also monitors and logs all files that are open and the current file position of each file such as a pointer that points to the last location in a file accessed by one of applications . Checkpoint agent logs this data to session log B. Logging agent further reports as noted above memory allocations performed by file system . File system may be adapted or otherwise configured to insert a new allocation flag which may be denoted as GFP FSX RESTARTABLE to all memory allocation calls. Upon receiving a memory allocation call from file system with this new allocation flag memory allocation module invokes logging agent to record the necessary per file system information into malloc table C.

File system may also be adapted or otherwise configured to track lock acquisitions. In particular file system may be adapted or configured to track only global locks. Thus when a thread is running in the file system the instrumented lock function saves the lock information in the threads s private lock stack D for global locks where the term global locks generally refers to locks that are shared by the file system with the kernel or another software module of for example the operating system. Exemplary global locks include a global kernel lock a super block lock and an inode lock. File system specific locks or intra file system locks may not need to be tracked as these locks will be removed during recovery and appropriately re instated during replay of the operations from the operation log. Logging agents also logs all kernel calls into the file system. Typically logging agents are implemented as wrappers that push and pop register state return addresses and return values such as the above noted error codes onto and off of unwind stack E. Logging agents push this log data onto unwind stack E at the beginning of the kernel call and pop this log data if the kernel call completes successfully. In this way inter checkpoint logging module along with checkpoint agent logging agents logging agent and file system store log data to both unwind inter checkpoint operations and then restore file system to its state immediately before the occurrence of the fault.

At periodic intervals checkpoint manager takes a snapshot or checkpoints file system . To take this snapshot checkpoint manager invokes checkpoint module . Checkpoint module performs a form of copy on write COW based checkpointing. Checkpointing is generally necessary to provide a restartable file system because file system state is constantly modified by operations such as writes and deletes. The file system lazily writes back the modified state to improve performance e.g. by only writing back changed state data when the operating system is relatively inactive . As any point in time then file system may be comprised of dirty pages in memory in memory copies of its meta data objects that have not yet been copied to its on disk pages and data on the disk. Thus the file system is typically in an inconsistent state until all of the dirty pages and meta data objects are stored to the disk. To provide correct operation and permit restoration checkpoint module may need to ensure that the file system is in a consistent state at the beginning of the mount or in the case of restartable file system restoration processes.

While the techniques described in this disclosure provide for a light weight form of checkpointing optimized to facilitate the logical creation of a membrane other checkpointing or snapshot mechanisms provided by file systems may be employed as an alternative to or in conjunction with the COW based checkpointing implemented in accordance with the techniques described in this disclosure. That is file system may provide a snapshot or checkpointing function that checkpoint module may invoke to create checkpoints . However for file systems that do not support snapshots or checkpointing checkpoint module may invoke checkpoint agent to create checkpoints . To create checkpoints checkpoint agent may group several file system operations into a single transaction and commit this transaction to the disk. Prior to creating this transaction checkpoint manager in some instances interfaces with a session manager of operating system which is not shown in B for ease of illustration purposes instructing this session manager to halt all file system operations for a relatively small duration after waiting for all in process operations to complete. During this duration and once the session manager signals that all in process operations have been completed checkpoint agent copies dirty meta data objects back to their on disk pages and all dirty pages are marked copy on write COW . Instead Checkpoint agent associates each page with one of checkpoint number associated with the most recent one of checkpoints to prevent pages dirtied in the current epoch from reaching the disk.

By using this COW support of file system checkpoint agent improves performance in performing checkpointing by allowing file system operations to run concurrently with the checkpoint of the previous epoch. That is forcing all dirty pages to be written to disk immediately rather than leverage the COW support of file system would be slow and basically extend the duration during which new operations are not able to enter file system . Once these pages have been marked COW checkpoint agent returns one of checkpoints which may indicate which pages were marked COW and their location in memory. Checkpoint module then interfaces with the session manager and instructs the session manager to allow file system operations to once again flow to file system . If these new operations attempt to write to these COW marked pages a COW fault results and fault handler copies the desired COW marked pages and indicates that the data is to be written to the copy of the COW marked page. Many operating systems support COW to enable among other things fast address space copying during process creation. If not implemented for particular types of pages such as kernel pages checkpoint agent may provide COW support to avoid having to alter file systems to support COW. Using the checkpoint number associated with each page checkpoint module allows these pages to be written to disk and the background input output I O process or daemon e.g. pdflush in the example of the Linux operating system is free to write COW pages to disk during the next epoch. Checkpoint module working with checkpoint agent thereby groups dirty pages from the previous epoch and may only allow modifications to be written to disk during the next epoch where newly dirtied pages are held in memory until the complete flush of the previous epoch s dirty pages.

Checkpoint module may perform checkpointing in accordance with a user configured policy or in response to dynamically monitoring any number of factors. Likely factors that may affect when checkpointing is performed may include the time that has elapsed since the lask checkpoint to minimize recover time the number of dirty blocks to keep memory pressure low and the current levels of processor and or I O utilization to perform checkpointing during relatively idle times . Alternatively checkpointing may be performed periodically such as every five seconds. Checkpointing may also be initiated any time one of applications forces data to a storage drive.

Referring next to the example of fault handler performs a form of what may be referred to as fault detection. Fault handler performs a lightweight form of fault detection that involves catching as many faults as possible without overly inserting implementation complexity that may reduce execution efficiency and introduce delay. Fault handler includes a hardware fault handler and a software fault handler . Hardware fault handler represents a module responsible for handling hardware based faults while software fault handler represents a module responsible for handling software based faults. Software fault handler module may include one or more of extensible programmer defined software assertions and checks to determine that the code segment has faulted. Hardware fault handler detects hardware faults such as null pointer faults divide by zero faults as well as any other hardware exception commonly triggered by hardware such as arithmetic logic units interfaces graphical processing units central processing units and the like. Hardware fault handler includes a redirection module that detects when hardware faults occur in the context of a file system operation. While shown as a single module fault handler including hardware and software fault modules may be distributed throughout various modules of the operating system to detect software or hardware faults.

Redirection module represents a module that redirects handling of these file system hardware faults to recovery manager . Software fault hander handles software faults such as file system fault assertions as well as invocation of the panic and similar functions. Software fault handler includes a redirection module which may be distributed throughout software fault handler . Redirection module may detect when a software fault occurs in the context of file system and redirects handling of these faults many of which may commonly require a restart of operating system to overcome to recovery manager .

File system may further be adapted or otherwise configured to perform explicit error checks to detect a broader class of semantically meaningful faults and route handling of these faults not to fault handler but directly to recovery manager . These error checks may be located in the interface presented by file system to the kernel or in some instances between virtual file system and the kernel in the form of recovery agent . Recovery agent may initiate this error checking to prevent fault propagation in to the kernel proper such that they are handled by fault hander rather than recovery manager . While shown as being located as on top of virtual file system this error checking aspect of recovery agent may be integrated in any number of portions of operating system generally and the kernel more specifically. For example these error checks may be inserted across key points in the generic file system and memory management modules as well as in header files.

Also as shown in the example of recovery manager includes a thread management module and a file system FS recovery management module FS recovery manager module . Recovery manager implements a form of what may be referred to as fault recovery which is invoked when a fault is detected either by fault handler through its redirection modules and or directly by file system . Thread management module represent a module that unwinds in process file system threads and prevents pending file system threads from being executed. To capture control of these threads that need to be unwound thread management module marks all code pages of file system as non executable thereby ensnaring other threads with a technique that may be referred to as control flow capture. When a file system thread is being executed after being marked as non executable the hardware generates a trap which is directed to hardware fault handler of fault handler . Redirection module of hardware fault handler then hands control to recovery manager . Recovery manger invokes thread management module which proceed to unwind the threads in accordance with the skip trust unwind protocol mentioned above.

Thread management module implements the above noted skip trust unwind protocol. This protocol skips over file system code but trusts the kernel code to behave reasonably in response to a failure and thus manage kernel state correctly. Thread management module coerces such behavior from the kernel by carefully arranging the return values which are more than likely error codes on the stack mimicking an error return from a failed file system thread or routine to the kernel. Thread management module permits the kernel code to run and clean up its state in response to the error code. Thread management module interfaces with checkpoint agent to retrieve unwind stack E which provides the necessary information or data to unwind an associated process. Unwind stack E may store register values some of which may specify an error and the last kernel function preceding the faulted file system process or thread. Thread management module unwinds this process by replacing the current register values with the register values from unwind stack E and mimics a returns back to the identified last kernel functions.

While described herein as interfacing with checkpoint agent to retrieve unwind stack E unwind stack E and any other portion of log data may be stored generally by operating system . For example in the case of unwind stack E operating system may store this stack E in what may be referred to as a process task structure or in other words meta data maintained by operating system for this particular process that is to be unwound. Thus while generally shown as being stored and otherwise maintained by checkpoint manager implementations may vary especially with respect to the operating system in which these techniques are implemented. Consequently the techniques should not be limited in this respect to the examples shown in .

FS recovery manager module represents a module that manages recovery of file system . FS recovery manager module includes a FS mount manager module and a FS session restore module . FS mount manager module represents a module that unmounts faulted file system and remounts file system from persistent storage devices. FS mount manager module may also represent a module that commits dirty pages from previous epochs as identified by the most recent one of checkpoints to stable or persistent storage devices. FS mount manager module forcefully commits these dirty pages to disk or other persistent storage devices. FS mount manager module further interfaces with checkpoint agent to retrieve malloc table C and based on malloc table C free all in memory objects allocated by file system . FS mount manager module may further unmount file system by freeing all items or elements in the file system buffer cache e.g. inodes and directory entries . FS mount manager module also effectively releases all pages for this file system in page cache . FS mount manager module then remounts file system by reading the super block of the file system from stable storage and performing all other tasks to reattach file system to operating system .

FS session restore module represents a module that restores file system to the state it was at when the fault occurred. FS session restore module interfaces with checkpoint agent to retrieve session log B and uses this session log B to restore the sessions of active processes to the state of file system when the last one of checkpoints was captured. FS session restore module also interfaces with checkpoint agent to retrieve operation log A and uses operation log A to replay previous operations as needed so as to restore the active state of file system to its state when the fault occurred. FS session restore module may interface with recovery agent to replay these operations such that these operations seem to come from one or more of application rather than recovery manager . After these operations have completed successfully FS session restore module restarts execution of pending but not yet executed threads such as those threads that were in flight at the time of the fault. The restoration of file system may from the perspective of these threads occur transparently given that these threads are unaware of the restoration of file system .

In some instances the order of the operations in operation log A need not be the same as the order executed by the scheduler of operating system prior to the fault. Yet this new execution order could potentially pose a problem while replaying completed write operations as applications could have observed the modified state via a read operation before the crash. Recovery manager avoids this non deterministic replay of completed write operations through page stealing. While replaying completed operations FS recovery manager module reads the final version of the page from the page cache and re executes the write operation by copying the data from it. As a result write operations while being replayed end up being the same final version no matter what order they are executed. Moreover as the in flight operations have not yet returned back to the application FS recovery manager module allows the operating system scheduler to execute them in arbitrary order.

Meanwhile fault handler may receive faults and determine whether these faults occur in the context of file system e.g. by examining the code segment that faulted and determine that this fault occurred in the context of the file system for which membrane protection is provided as described above in more detail . If a file system fault is not detected NO file handler handles the fault in accordance with conventional fault handling techniques. In these no file system fault instances control unit continues to execute file system of operating system where checkpoint manager continues to perform checkpoints and inter checkpoint logging .

However if a file system fault is detected YES fault handler invokes one of redirection modules to redirect control or handling of the file system fault to recovery manager . Recovery manage interfaces with recovery agent instructing recovery agent to block pending but not yet started FS operations . Recovery manager then invokes thread management module . Thread management module unwinds those FS operations in the process of being executed by file system when the fault occurred in accordance with the skip trust unwind protocol described above . Once these operations are unwound recovery manager invokes FS recovery manager module which in turn invokes FS mount manager module . FS mount manager module unmounts file system and remounts file system using the last one of checkpoints as described above . FS recovery manager module then invokes FS session restore module . FS session restore module restores file system using inter checkpoint log data in the manner described above . Also as described above FS session restore module also re executes unwound FS operations using inter checkpoint log data .

Once these unwound FS operations have been completed successfully recovery manager may interface with recovery agent to once again allow file system to receive and process pending but not yet started file system operations where control unit may once again resume normal execution of file system of operating system . The entire file system restoration process does not normally require a restart of operating system as a result of the careful logging and restore operations performed by checkpoint manager and recovery manager respectively. As a result normal execution of operating system may resume such that applications are unaware of the file system failure or fault. Consequently operating system may continue to execute and the file system restoration processes may continue to perform checkpoints and inter checkpoint logging while also seamlessly recovering from file system faults without overly impacting execution of applications .

In some instances recovery manager may determine that the file system function failures and subsequent restoration of the file system to the software application are repeating which is indicative of a non transient fault. Recovery manager may then halt recovery and return an error to the software application indicating a non transient failure. In this way recovery manager does not endlessly loop attempting to recover from a non transient unrecoverable error.

During this first clock cycle time 0 in the example of one of system calls shown in the example of are invoked to write A to block 0 of a file creating a dirty block storing A during epoch 0. During the second clock cycle or time 1 checkpoint manager which may represent a background process wakes up and invokes checkpoint module . Checkpoint module interfaces with checkpoint agent in the manner described above to mark all dirty pages as copy on write COW . In the example of dirty block is marked as COW in the second clock cycle.

After checkpointing in this manner and during the third clock cycle or time 2 another one of system calls is invoked to write B to block 0. However this system call process or thread which may be used interchangeably when a process only includes a single thread when attempting to write B to block 0 raises a fault given that this dirty block has been marked COW. Fault handler processes this fault and in response creates a copy of dirty block passing this copied block back to the system call process. The system call process then writes B to this copy of block zero or copied block . At this point both dirty block and copied block are stored in memory. During the fourth clock cycle or time 3 file system performs an input output I O flush to flush all dirty pages associated with the previous epoch i.e. epoch 0 in this example back to disk . As a result dirty block is stored back to disk. However all dirty blocks associated with the current epoch i.e. epoch 1 in this example remain in memory . In this way the techniques of this disclosure provide for a COW based form of checkpointing that may potentially reducing overhead associated with performing checkpointing by delaying writes to disk of pages dirtied during a first epoch until a subsequent second epoch.

At some point checkpoint manager wakes up or otherwise triggers a checkpoint whereupon checkpoint manger interfaces with the session manager of operating system to halt pending but not yet started file system operations . Checkpoint manager then performs the checkpoint by interfacing with checkpoint agent to mark written to or dirty blocks e.g. dirty block as COW . Checkpoint agent may return data identifying which blocks were marked COW to checkpoint module which stores these blocks along with the current epoch identifier or number identifying the current epoch as one of checkpoints . Checkpoint module may interface with the session manager to resume execution of pending but not yet started file system operations.

Operating system may once again receive an invocation of one of system calls requesting that data being written to the previously marked COW block e.g. block . When file system attempts to write to this COW block file system throws a fault given that this block is marked COW . Fault handler handles this fault by copying COW block to generate a copied block such as copied block shown in the example of . Checkpoint agent associates this copied block with the subsequent second epoch and passes this data back to checkpoint module which stores this data to another one of checkpoints . File system then writes the data to copied block which has not been marked COW . At some later point such as during a period of relative inactivity of the second epoch checkpoint module causes file system to write dirty blocks associated with the first epoch e.g. block to disk thereby maintaining a consistent file system image or checkpoint in a lazy manner that does not require immediate storage of dirty pages at the end of the first epoch.

Initially kernel function A is invoked or called which invokes or calls kernel function B. Kernel function B invokes kernel function C which in turn invokes kernel function D. Kernel function D invokes kernel function E which invokes file system function A. At this point between kernel function E invoking file system function A membrane as implemented by inter checkpoint logging module working with checkpoint agent may update log data to update the per thread unwind stack shown in the example of as unwind stack E in the manner described above. Meanwhile file system function A invokes file system function B which in turn invokes file system function C. File system function C then invokes kernel function F which invokes file system function D. Again at this point between kernel function F invoking file system function D membrane as implemented by inter checkpoint logging module working with checkpoint agent may update log data to update the per thread unwind stack shown in the example of as unwind stack E in the manner described above.

As shown in the example of file system function D faults where control eventually is handed over to recovery system . Recovery system invokes thread management module which proceeds to implement the skip trust unwind protocol using the data stored to per thread unwind stack E. Thread management module pops the first entry from unwind stack E pushed on by inter checkpoint logging module returning the return value logged to the identified function i.e. kernel function F. Kernel function F receives this return value which is more than likely an error value specifically chosen by inter checkpoint logging module to cause kernel function F to perform the operations denoted by the number 3 in a grey circle shown to the right and above kernel functions and file system functions . That is kernel function F cleans up by clearing the buffer zero the page operating on by this kernel function F and mark the page as clean or not dirty. Kernel function F then passes control to file system function C.

Membrane as implemented by recovery manager then catches the attempt to execute file system function C e.g. by previously marking all file system executable or code pages as non executable which triggers a fault that fault handler handles by redirecting handling back to thread management module . Thread management module then retrieves or otherwise pops the next entry to unwind stack E replaces the current register values with those stored to the popped entry and returns the return value specified by that entry back to kernel function E skipping file system functions B and A but trusting kernel function E to properly handle the returned fault. Kernel function E returns control to kernel function D which implements the cleanup operations shown in the circle denoted as 2. Kernel functions D returns control to kernel function C which returns control to kernel function B. Kernel function B performs the cleanup operations shown next to the circle denoted 1 and returns control to kernel function A. In this manner thread management module implements the skip trust thread unwind protocol.

As noted above the kernel and the file system may be considered intertwined portions of an operating system. Intertwined portions arise when a function of one intertwined portion calls a function of the other intertwined portion of the operating system. Rather than attempt to provide a recovery function for each file system function the skip trust unwind protocol implemented in accordance with the techniques of this disclosure skips intertwined file system functions and returns control to the trusted kernel functions which then perform kernel level cleanup. This cleanup is trusted to adequately handle the kernel state and unwind the thread. In this manner only function calls from the kernel to the file system may need to be logged as compared to also including calls from the kernel to the file system which may greatly reduce the size of unwind stack E while also reducing the implementation complexity of thread management module in that it potentially does not need to implement a recovery function for each file system operation.

File system function D which may also be considered a thread in that when executed functions are normally executed as threads may fail and as a result issue a file system fault . Fault handler may handle this fault and redirect this fault to recovery manager which in turn invokes thread management module to unwind this thread and any other threads currently in flight or in the process of being executed when the fault occurs. Thread management module first marks all executable file system code as non executable to as to provide flow control capture in the manner described above . Thread management module then interfaces with checkpoint agent to retrieve unwind stack E that stores an unwind stack for the faulted thread . Thread management module pops the top element from this unwind stack E and returns control to the kernel function that invoke or lead to the invocation of the faulted thread skipping any intervening file system functions based on the popped element in the manner described above .

Upon receiving control the kernel function such as kernel function F performs kernel function cleanup and returns control to the function that called kernel function F e.g. file system function C in the example of . If this function is a file system function YES upon attempting to execute this function a file system fault is issued as described above . The process then repeats although thread management module may not remark the file system code as non executable considering that it has already been marked as non executable . If the calling function is a kernel function NO control is transferred to this calling function . If this is the top most function e.g. kernel function A then thread management module determines that the thread has been unwound YES and thread management module may iterate to the next thread and begin unwinding this thread in accordance with skip trust unwind protocol . If this is not the top most thread the kernel function e.g. kernel function E performs kernel function cleanup and returns control to its calling function. This process repeats until the thread is unwound or an attempt to execute a file system function occurs .

At some point checkpoint module of operating system shown in the example of interfaces with either the session manager or checkpoint agent to halt or otherwise stop processes from entering file system . Checkpoint agent then checkpoints file system and in the process of checkpointing marks all of pages A D as COW. That these pages A D have been marked COW is reflected by the black coloring of these pages A D as shown in the example of . Referring to the example of checkpoint module has finished checkpointing as evidenced by the lack of a dashed box surrounding page cache and disk and threads or processes have been allowed to reenter file system . Application A has after this checkpoint requested that another file system operation be performed which file system performed. This operation involved file system copying another page E from disk to page cache .

Referring to the example of pages A D are associated with the first epoch that led to the previous checkpoint shown by way of the dashed lined box in B. These pages A D can be written to disk at any point during the current second epoch and are marked with a checkmark in the example of to denote that these are available to be written to disk . Referring next to application A issued yet another request for a file system operation that writes data to page A. However this page A has been marked as copy on write or COW and the attempt by file system to perform this operation results in a fault that fault handler handles by creating a copy of page A which is shown in the example of as page A . File system then writes the data to page A .

Referring next to the example of checkpoint module wakes up and performs another checkpoint as shown in the example of as the dashed lined box around page cache and disk . Checkpoint module interfaces with checkpoint agent to block access by pending but not yet started file system processes or threads to file system while also stopping those pages associated with the current epoch i.e. pages A and E in the current example from being written to disk . Checkpoint agent however does write any of pages A D that remain in page cache to disk . In this respect the barrier between page cache and disk is permeable with respect to pages associated with the previous epoch but not permeable with respect to pages associated with the current epoch. This process of checkpointing may continue until a fault occurs in file system as shown in the example of .

Referring to the example of file system faults where this fault is denoted by the lightning bolt in the block labeled FS . At this point page cache stores a page F that was edited during the current epoch and a page G marked as being available to write to disk meaning that this page is associated with the previous epoch. In response to the fault recovery manager is invoked to handle the file system fault whereupon recovery manager invokes thread management module to unwind the in process threads while also interfacing with recovery agent to halt any pending threads from entering virtual file system and thereby file system . After the processes are unwound recovery manager also invokes FS recovery manager module which invokes FS mount manger module to unmount file system .

FS mount manager module unmounts file system by clearing or otherwise deleting any dirty pages in page cache such as page F. illustrates the result of FS mount manager module performing page stealing and dirty page deletion where disk is shown to store page G and page F has been deleted. Once these operations have been performed recovery manager invokes FS session restoration module to restore file system to the state it was in when the fault occurred. FS restoration module then replays those operations logged to operation log A to restore the session of file systems which effectively restores in this example page F within page cache . illustrates the restoration of page F within page cache after it had been previously cleared as shown in the example of . At this point recovery manager may allow pending but not yet started file system operations to reach file system and application A may receive responses to its previous operations that caused the fault. In this way the file system restoration techniques may restore file system without having to restart operating system in its entirety.

Also as shown in the example of operating system includes a kernel which as described above provides the core functionality of operating system . Kernel includes SCI module fault handler memory allocation module and many other modules not shown in the example of for ease of illustration purposes. Kernel interfaces with file system which is protected by membrane . Membrane represents those modules and as well as their agents and that implement various aspects of the file restoration techniques described in this disclosure to provide a file system capable of being restored without restarting operating system or otherwise restarting computing device .

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

