---

title: Parametric trace slicing
abstract: A program trace is obtained and events of the program trace are traversed. For each event identified in traversing the program trace, a trace slice of which the identified event is a part is identified based on the parameter instance of the identified event. For each trace slice of which the identified event is a part, the identified event is added to an end of a record of the trace slice. These parametric trace slices can be used in a variety of different manners, such as for monitoring, mining, and predicting.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08719796&OS=08719796&RS=08719796
owner: The Board of Trustees of the University of Illinois
number: 08719796
owner_city: Urbana
owner_country: US
publication_date: 20110124
---
This application claims the benefit of U.S. Provisional Application No. 61 298 303 filed Jan. 26 2010 entitled Parametric Trace Slicing to Grigore Rosu Feng Chen and Patrick O. Meredith which is hereby incorporated by reference herein.

This invention was made with Government support under Grant Numbers CCF 0448501 CNS 0509321 and CNS 0720512 awarded by the National Science Foundation NSF and Contract Number NNL08AA23C awarded by the National Aeronautics and Space Administration NASA . The Government has certain rights in the invention.

Analyzing execution traces of programs is oftentimes performed to debug and or otherwise analyze computer programs. Unfortunately many computer programs can result in execution traces that are very long and or complex. This problem is exacerbated for parametric traces which are traces that contain events with parameter bindings. In parametric traces the execution trace typically includes multiple trace slices merged together with each trace slice corresponding to a parameter binding. Accordingly it can be difficult to analyze execution traces particularly for parametric traces.

This Summary is provided to introduce subject matter that is further described below in the Detailed Description. Accordingly the Summary should not be considered to describe essential features nor used to limit the scope of the claimed subject matter.

In accordance with one or more aspects a program trace is obtained and events of the program trace are traversed. For each event identified in traversing the program trace a trace slice of which the identified event is a part is identified based on one or more parameter instances in the identified event. For each trace slice of which the identified event is a part the identified event is added to an end of a record of the trace slice.

Parametric trace slicing is discussed herein. A program trace is a parametric execution trace containing events with parameter bindings and is traversed to identify multiple parametric trace slices in the program trace. During the traversal a table of parametric trace slices is generated. This table can be subsequently accessed to retrieve one or more parametric trace slices without re traversing the program trace. These parametric trace slices can be used in a variety of different manners such as for one or more of monitoring mining and predicting.

Parametric execution traces can be generated using a variety of different techniques such as using direct program instrumentation and or predictive program instrumentation. In one or more embodiments parametric execution traces are generated by module using direct program instrumentation. In such embodiments parametric traces are constructed in the order events occur in the actual program.

In alternate embodiments parametric execution traces are generated by module using predictive program instrumentation. In such embodiments multiple parametric execution traces are output by module one of which corresponds to the actual order of observed events in a program. The other parametric execution traces correspond to possible sequences of events with respect to a partial order such as happens before or sliced causality and are relevant in multi threaded or distributed programs. These other parametric execution traces are not the actual observed trace although these other parametric execution traces may occur in different runs or executions of the program. Thus using predictive program instrumentation additional bugs or errors can be found that did not occur when the program was actually run.

Parametric trace slicing module receives one or more execution traces . Module analyzes parametric execution traces and outputs one or more trace slices obtained from the parametric execution traces . In one or more embodiments trace slices are output by system for analysis e.g. by a program developer . In addition to or alternatively in place of system outputting trace slices trace slices can be input to one or more of monitoring module and mining module .

A parametric execution trace is an execution trace that contains events with parameter bindings. Events with parameter bindings are present in programs where abstract parameters e.g. variable names are bound to concrete data e.g. heap objects at runtime. Accordingly a parametric execution trace can include numerous events with numerous parameter bindings. Parametric trace slicing module analyzes a parametric execution trace and obtains the trace slices corresponding to each instance of a parameter. Module generates a record e.g. a table of parametric trace slices while traversing trace thereby avoiding any need to re traverse the trace for each instance of a parameter. Module also obtains the trace slices without imposing restrictions on the type of parametric execution trace . For example the first event for a particular property instance need not bind all the parameters for the property.

Monitoring module monitors parametric execution traces and determines whether the monitored traces comply with particular constraints. These constraints can be specified for example as regular expressions identifying the format that monitored traces are to follow. Monitoring module can operate on parametric execution traces and or trace slices . An indication of whether traces and or trace slices comply with the particular constraints can be output by monitoring module in a variety of different manners such as by generating one or more tables and or other records. These indications are output by module as monitoring results .

Mining module analyzes trace slices to generate non parametric state based specifications together with equivalent regular expressions. An indication of these specifications and or regular expressions are output by module as mining results . Mining module automatically detects various aspects regarding the manner in which the underlying program that was executed to generate parametric execution traces operates. For example mining module can automatically detect Application Programming Interface API patterns usage scenarios and so forth.

Direct program instrumentation refers to obtaining a parametric execution trace corresponding to an actual execution of a program. Direct program instrumentation is performed by for example direct program instrumentation module of .

Generally using direct program instrumentation particular points of interest in a program are specified. The location of these points of interest can be specified in different manners such as by a user e.g. a program developer or system administrator or by another module or device. When such specified points of interest in the program are reached they are reported as an event to one or more other modules in the system. A set of such events reported for a program are the parametric execution trace for the program. Direct program instrumentation can be performed in a variety of different conventional manners. For example direct program instrumentation can be performed using an aspect language such as AspectJ. Additional information regarding the AspectJ aspect language can be found in for example An Overview of AspectJ by G. Kiczales E. Hilsdale J. Hugunin M. Kersten J. Palm and W. G. Griswold European Conference on Object Oriented Programming ECOOP 01 2001 .

Predictive program instrumentation refers to attempting to infer all possible execution traces in a multi threaded or distributed program in which different inter leavings of execution of the threads or distributed pieces can result in different execution traces. Predictive program instrumentation is performed by for example predictive program instrumentation module of . It should be noted that although inferring all possible execution traces is attempted the predictive program instrumentation may actually infer fewer than all possible execution traces.

Predictive program instrumentation begins by generating a direct trace of program events e.g. using direct program instrumentation as discussed above . At predetermined points during the collection of the direct trace a partial order of events is determined using control relations such as happens before or sliced causality . The partial order of events can be determined using a variety of different control relations. Additional information regarding the happens before control relation can be found in for example Time Clocks and the Ordering of Events in Distributed Systems by L. Lamport Communications of the ACM 21 7 558565 1978 . Additional information regarding the sliced causality control relation can be found in for example Parametric and Sliced Causality by F. Chen and G. Rosu Computer Aided Verification CAV 07 2007 .

The location of these predetermined points can be specified by a user e.g. a program developer or system administrator or by another module or device. In one or more embodiments the location of the predetermined points is determined by balancing precision of the partial orders which is increased or improved by spacing the predetermined points further apart against runtime overhead which is decreased or improved by spacing the predetermined points closer together .

The feasible traces with respect to these determined partial orders of events are generated. For example assume a program generates a trace a b c where each letter represents an event and that the control relation used determines that a must occur before c. In this example then the feasible traces b a c and a c b can be inferred. The parametric execution traces generated by the predictive program instrumentation include these feasible traces as well as the actual traces from the direct trace of program events. Thus the parametric execution trace includes feasible traces that were not actually part of the tested execution of the program. This allows errors that occur within a feasible trace but do not occur in the actual tested execution of the program to be identified or predicted. Referring to this allows the monitoring performed by monitoring module and or the mining performed by mining module to be performed based on feasible traces that did not occur in the actual tested execution of the program.

Parametric trace slicing refers to obtaining from or identifying in a parametric execution trace multiple trace slices each of which corresponds to an instance of a parameter in the parametric execution trace. Parametric execution traces can be obtained using a variety of different instrumentation techniques such as the direct program instrumentation and or predictive program instrumentation techniques discussed above. Parametric trace slicing is performed by for example parametric trace slicing module of .

In the discussions herein refers to a set of non parametric events also referred to as base events . An trace is a non parametric trace when is understood or not important. An trace is referred to as any finite sequence of events in also referred to as an element in . An event can be referred to as e and a trace can be referred to as w and if an event e appears in a trace w this situation is also referred to as e w.

An property P also referred to as a base or non parametric property is a function P C that partitions a set of traces into categories C. In one or more embodiments categories in C include validating violating and don t know also referred to as . Other categories for C can alternatively be used such as matching and don t care .

A regular expression can be used to identify an acceptable or proper format for a trace or portion thereof . This can also be referred to as a constraint on the trace or portion thereof . Assuming C is the set validating violating don t know and for a given regular expression E of a trace the property P C of the regular expression E is defined as follows P w validating if and only if w is in the language of E P w violating if and only if there is no w such that w w is in the language of E and P w don t know otherwise.

These preceding definitions can be extended to the parametric case where events carry concrete data instantiating abstract parameters as follows. For example assume an event Acquire and an event Release are parametric in their resource a resource to be acquired and released . Assume r is the name of the generic resource parameter and that rand rare two concrete resources. Following this assumption parametric acquire release events have the form Acquirerr Releaserr and so forth. It should be noted that not all events need carry instances for all parameters. For example Begin and End parametric events signifying the beginning and ending respectively of a procedure have the form Begin and End where refers to the partial map undefined everywhere and instantiates no parameter. The sets of total partial functions from A to B are also referred to as A B AB .

A set of parameters is referred to as X and a set of corresponding parameter values is referred to as V. A set of base events is referred to as as discussed above and X is a set of corresponding parametric events e where e is a base event in and is a partial function XV . A parametric trace is a trace with events in X also referred to as a word in X .

In the discussions herein the parameter values set V is implicit to simplify writing. For example a parametric trace can be Begin Acquire Acquire Acquire Release End Begin Acquire Release End where maps r to rand maps r to r. Additionally in the discussions herein just the parameter values are listed when writing parameter instance such as r instead of rr rinstead of rr and so forth. Using this notation the previous example parametric trace can be written as Begin Acquirer Acquirer Acquirer Releaser End Begin Acquirer Releaser End. This example parametric trace thus involves two resources rand r and includes two trace slices one for each of the two resources . The Begin and End events in the parametric trace belong to both trace slices. The trace slice corresponding to is Begin Acquire Acquire Release End Begin End. The trace slice corresponding to is Begin Acquire End Begin Acquire Release End.

Partial functions in XV are referred to as parameter instances. The and AB are referred to as being compatible if for any x Dom Dom where x x . Compatible instances and can be combined written as as follows 

The is also referred to as the least upper bound lub of and . The is less informative than or is more informative than also written as if and only if for any x X if x is defined then x is also defined and x x . For example is compatible with r and with r but r and r are not compatible. Additionally r and r.

The trace slice first filters out the parametric events that are not relevant for the instance . The parametric events that are not relevant for the instance are the parametric events that contain instances of parameters that does not care about e.g. instances of parameters not included in . For the remaining events relevant to the trace slice forgets or drops the parameters so that the trace can be checked against base non parametric properties. It should be noted obtaining such trace slices is different from extracting traces from executions and abstracting traces from executions. Extracting traces refers to determining the events to include in the trace as well as parameter instances carried by events. Abstracting traces refers to dispatching each event in the given trace to corresponding trace slices according to the event s parameter instance.

A set of parameters together with their corresponding parameter values V is referred to as X and P C refers to a non parametric property as discussed above. The parametric property X P is defined as the property over traces X and categories XV C 

which is referred to as X P P for any X and any XV . If X x . . . x then x . . . x P can be written as x . . . x P. Additionally P refers to a pattern or formula in some particular trace specification formalism then X P is written as X .

Parametric properties X P over base properties P C are thus properties taking traces in X to categories XV C in other words to function domains from parameter instances to base property categories. X P is defined as if many instances of P are observed at the same time on the parametric trace one property instance for each parameter instance and each property instance concerned with its events only dropping the unrelated events .

Generally to slice parametric traces a parametric slicing process is used that takes a parametric execution trace incrementally and builds a partial function of finite domain as a lookup table for all slices of the parametric trace. The parameter instances are the index used to lookup slices in the lookup table. The various parametric trace slices in the parametric trace are identified in this lookup table. A trace slice is computed for all combinations of parameter instances observed in parametric trace events in the trace. In order to obtain a particular slice for a particular set of functions instantiating a particular set of parameter values a most informative set of parameter instances is calculated. This most informative set of parameter instances refers to all the parameter instances used in the particular slice. The lookup table is then accessed to identify the parametric trace slice identified by the most informative set of parameters. Thus the parametric trace can be processed or traversed one time as the lookup table is being generated. Appropriate data structures are maintained as the lookup table so that parametric trace slices can be subsequently retrieved for any parameter instance without processing or traversing the parametric trace again.

In process a program trace is obtained act . The program trace can be obtained from a variety of different sources in a variety of different conventional manners. The program trace can be a trace of a previously run program or alternatively an on going trace of a program currently running

The trace is traversed from the first event in the trace to the last event in the trace act . Each event in the trace is analyzed as the trace is traversed. Alternatively the program trace can be traversed in different orders other than from the first event to the last event.

The first event in the trace is identified during the traversal act . This first event can be a parametric event or a non parametric event.

Based on the parameter instances in the identified event each trace slice of which the identified event is a part is identified act . An event is part of a trace slice if the parameter instance of the event is less informative than the parameter instance of the trace slice. If the event includes no parameter instances then the event is a part of all trace slices. A record of each different trace slice identified in the trace is maintained. These different trace slices correspond to different possible combinations of parameter instances observed while traversing the trace. A record of each possible trace slice resulting from each possible combination of parameter instances observed in the trace can be maintained regardless of whether the particular combination of parameter instances is actually observed in the trace. Alternatively a record of each possible trace slice resulting from the combinations of parameter instances actually observed in the trace can be maintained.

The identified event is added to the end of the trace slice record for each trace slice of which the identified event is a part act . For each trace slice identified in act the identified event is added to the end of the record of that trace slice. It should be noted that the identified event can be added with or without its parameter instances.

A check is then made as to whether the identified event is the last event in the trace act . If the identified event is the last event in the trace then process is finished for the obtained trace act .

However if the identified event is not the last event in the trace then the next event in the trace is identified during the traversal act . Process then returns to act to identify based on the parameter instances in the identified event each trace slice of which the identified event is a part.

Process illustrates an example process for parametric trace slicing. Example pseudo code for an algorithm performing parametric trace slicing is included in Table I below. The algorithm AX in Table I takes a parametric trace X incrementally and builds a partial function T XV of finite domain as a quick lookup table for all slices of . Given sets of partial functions XV is the least informative partial function XV such that for any max is the most informative such that exists and and . It should be noted that and max may not exist. The algorithm AX in Table I takes an input of a parametric trace X and outputs a map or lookup table T XV and a set XV .

The algorithm AX in Table I operates on input also written as AX traverses from its first event to its last event and for each encountered event e updates both its data structures T and . After processing each event the relationship between T and is that is a domain of T.

In the algorithm AX in Table I at line 1 the data structures T and are initialized. T is undefined everywhere except for the undefined everywhere function where T . is initialized to the set . The code at lines 3 to 6 inside the outer loop at lines 2 to 7 is triggered when a new event is received. When a new event e is received T is updated as follows. For each XV that can be obtained by combining with the compatible partial functions in the domain of the current T update T by adding the non parametric event e to the end of the slice corresponding to the largest the most knowledgeable entry in the current table T that is less informative or as informative as . Then at line 6 is extended.

As an example consider a sample parametric trace with parametric events in a b c. The sample parametric trace ea ea eb eab ea e eb. The following example records illustrate how the algorithm AX works on the sample parametric trace . An entry of the form w in a record corresponding to a current parametric event e means that T w after processing all the parametric events up to and including the current parametric event T is undefined on any other partial function. The corresponding to a record is the union of all the s that appear in pairs w in that record. It should be noted that as each parametric event e is processed the non parametric event e is added at most once to the record of each slice. Tables II VIII below illustrate the contents of each record for a trace slice after the event identified in each table has been analyzed during traversal of the sample trace.

Trace slice monitoring refers to analyzing the parametric trace slices to verify parametric properties in the execution trace. This monitoring can be used for example to assist in the identification of errors or problems in the underlying program the program whose execution results in the execution trace . Monitoring of the parametric trace slices is performed by a monitoring module such as module of . The monitoring of the parametric trace slices can be performed as the underlying program is running or alternatively after the underlying program has run.

For parametric trace slice monitoring a set of monitors M and a set of parametric monitors X M are defined. Parametric monitors refer to monitors for parametric events and have parameter instance indexed states and output categories. A parametric monitor X M is a monitor for the property X P with P being the property monitored by M.

A monitor M is a tuple S C S S S C where S refers to a set of states refers to a set of input events C refers to a set of output categories S is the initial state is the transition function and is the output function. The transition function is extended to S S in the standard way s s and s we s w e for any s S e and w . It should be noted however that implementations of monitors need not generate all the state space ahead of time but rather can generate the state space as needed. It should also be noted that although a finite number of states is reached during any given finite execution trace in general there is no bound on the number of states.

A monitor M S C is a monitor for property P C if and only if w P w for each w . Each monitor M defines the property P C with P w w . Each such monitor M is referred to as a monitor for P. Two monitors M and M are equivalent referred to as M M and only if P P.

Given parameters X with corresponding values V and monitor M S C S S S C the parametric monitor X M is the monitor

In other words a state of parametric monitor X M maintains a state of M for each parameter instance takes parametric events as input and outputs categories indexed by parameter instances one output category of M per parameter instance .

Generally to monitor parametric trace slices a monitoring process is used that takes parametric trace slices and builds records of states of monitor instances and also builds records indicating violation or validation of a property. Similar to the parametric slicing process discussed above the parametric trace slices can be processed or traversed one time as the records are generated.

In process a program trace is obtained act . The program trace can be obtained from a variety of different sources in a variety of different conventional manners. The program trace can be a trace of a previously run program or alternatively an on going trace of a program currently running Additionally the program trace can be a parametric trace slice e.g. generated by slicing module of rather than an entire program trace in which case the parameter instance of every event will be     .

The trace is traversed from the first event in the trace to the last event in the trace act . Each event in the trace is analyzed as the trace is traversed. Alternatively the trace can be traversed in different orders other than from the first event to the last event.

The first event in the trace is identified during the traversal act . This first event can be a parametric event or a non parametric event.

Based on the parameter instances in the identified event the monitor instance corresponding to the identified event is identified act . An event is part of a trace slice if the parameter instance of the event is less informative than the parameter instance of the trace slice. A record of each different monitor instance identified in the trace is maintained. These different monitor instances correspond to different possible combinations of parameter instances observed while traversing the trace. A record of each possible monitor instance resulting from each possible combination of parameter instances observed in the trace can be maintained regardless of whether the particular combination of parameter instances is actually observed in the trace. Alternatively a record of each possible monitor instance resulting from the combinations of parameter instances actually observed in the trace can be maintained.

The identified event is added to the monitor instance record for each monitor instance corresponding to the identified event act . For each monitor instance identified in act the identified event is added to the record of that monitor instance. The identified event can be added to the end of the record or alternatively elsewhere in the record. It should be noted that the identified event can be added with or without its parameter instances.

An output corresponding to the identified monitor instance is also determined act . The output corresponding to the identified monitor instance based on the events added to the identified monitor instance thus far is calculated. This output comprises determining for example whether the trace slice corresponding to that monitor instance is validating violating or don t know. In other words whether the trace slice corresponding to that monitor instance complies with the appropriate constraints. This determination is made for example based on a regular expression of a trace as discussed above. For example if a regular expression indicates that an Acquire event is to precede a Release event then it can be determined that the output corresponding to the identified monitor instance is validating if an Acquire event precedes the Release event in a trace slice and any other regular expressions for the trace slice are satisfied but violating if an Acquire event does not precede the Release event.

An indication of the determined output is added to a record corresponding to the identified monitor instance act . For example an indication of validating violating or don t know can be added to the record. Alternatively indications of validating or violating may be added to the record but indications of don t know are not added.

A check is then made as to whether the identified event is the last event in the trace act . If the identified event is the last event in the trace then process is finished for the obtained trace act .

However if the identified event is not the last event in the trace then the next event in the trace is identified during the traversal act . Process then returns to act to identify based on the parameter instances in the identified event the monitor instance corresponding to the identified event.

Process illustrates an example process for parametric trace slice monitoring. Example pseudo code for an algorithm performing parametric trace slice monitoring is included in Table IX below. The algorithm BX in Table IX encodes functions XV S as tables with entries indexed by parameters instances in XV and with content states in S. The algorithm BX in Table IX uses a data structure that is a record of monitor instance states and a data structure that is a record of indications of whether the output corresponding to the monitor instance violates or validates the property e.g. whether one or more regular expressions for the trace or trace slice is satisfied . In the algorithm BX in Table IX is mapped to XV S and is mapped to XV C .

The algorithm BX in Table IX is similar to the algorithm AX for which pseudo code is included in Table I discussed above. The algorithm BX in Table IX operates on input traverses from its first event to its last event and for each encountered event e updates both its data structures and .

In the algorithm BX in Table IX at line 1 the data structure is initialized as undefined everywhere except for the undefined everywhere function is initialized to and is initialed to the set . The code at lines 3 to 7 inside the outer loop at lines 2 to 8 is triggered when a new event is received. When a new event e is received at line 4 the state of the monitor instance corresponding to is calculated and stored in the record corresponding to by sending e to the corresponding monitor instance. Additionally at line 5 a determination is made whether the output corresponding to the monitor instance violates or validates the property and an indication of the determination is stored in the data structure . Then at line 7 is extended.

In the implementation of algorithm BX in Table IX a search is made at line 3 for all parameter instances in that are compatible with . Alternatively an auxiliary data structure can be used to reduce the amount searching that is performed so that a search for all parameter instances in that are compatible with need not be performed. The auxiliary data structure maps each parameter instance into the finite set of parameter instances encountered in thus far that are more informative than . For example the auxiliary data structure can be referred to as U and is defined as U Dom and . Accordingly the amount of searching that is performed is reduced as only the parameter instances encountered thus far that are more informative than the current parameter instance need be considered.

Example pseudo code for another algorithm performing parametric trace slice monitoring is included in Table X below. The algorithm CX in Table X is similar to the algorithm BX in Table IX except that the search at line 3 of algorithm BX in Table IX is replaced so that a reduced amount of searching is performed. The algorithm CX in Table X uses the auxiliary data structure U discussed above.

The algorithm CX in Table X using mappings for and as discussed above with reference to algorithm BX in Table IX and in addition U is mapped to XV P XV where P S is the finite power set of set S. The algorithm CX in Table X is composed of two functions main and defineTo . The defineTo function takes two parameter instances and and adds a new entry corresponding to into and U. More specifically the defineTo function sets to and adds into the set U for each .

The main function differentiates two cases when a new event ee is received and processed. The first case is that is already defined on in other words at the beginning of the outer loop lines 2 8 of the algorithm BX in Table IX. In this first case and so lines 3 to 6 of the algorithm BX in Table IX become the lines 16 to 19 of the algorithm CX in Table X.

In the second case of the main function when is not already defined on two steps are taken to process e. The first step searches for new parameter instances introduced by and adds entries for these new parameter instances into at lines 2 to 15 . More specifically at lines 2 to 7 an entry is added to for . A search for all parameter instances that are compatible with making use of U at lines 8 and 9 and for each such an appropriate entry is added to for its least upper bound with and U is updated accordingly at lines 10 to 12 . Thus is defined on the new parameter instances introduced by after the first step. In the second step the related monitor states and outputs are updated in a similar way as in the first case at lines 16 to 19 .

Example pseudo code for another algorithm performing parametric trace slice monitoring is included in Table XI below and is referred to as algorithm CX. Algorithm CX in Table XI is similar to algorithm CX in Table X but extends algorithm CX in Table X to include creation events. Creation events refer to events that lead to creation of new monitor states. The algorithm CX in Table X can be viewed as a special case of the algorithm CX in Table XI in which all events are creation events. The creation events typically occur as a result of a request e.g. a user request or a request from another component or module to begin monitoring each new event encountered after the request to begin monitoring is a creation event. The algorithm CX in Table XI uses the data structure that is a record of monitor instance states the data structure that is a record of indications of whether the output corresponding to the monitor instance violates or validates the property and the auxiliary data structure U discussed above.

The algorithm CX in Table XI includes an additional function defineNew that takes a parameter instance and adds a new entry corresponding to into and U.

Parametric trace slice mining refers to generating specifications for the underlying program based on the parametric trace slices obtained from an execution trace. The specifications identify various aspects regarding the manner in which the underlying program such as API patterns usage scenarios and so forth. In addition to generating the specifications regular expressions equivalent to the specifications can also be generated.

In process trace slices are obtained act . These trace slices are parametric trace slices as discussed above. It should be noted that although these trace slices are referred to as parametric trace slices in one or more embodiments they do not include parameters. As discussed above events are added to trace slices during the parametric trace slicing process but these different slices correspond to particular combinations of parameters. Thus the parameters for these events need not recorded in the different slices as the events are associated with particular combinations of parameters by virtue of their being included in a particular trace slice.

Deterministic finite automata are produced based on the obtained trace slices act . A deterministic finite automaton DFA is a finite state machine in which for each pair of state and input there is a single transition to a next state. These deterministic finite automata are generated using a probabilistic finite state automata PFSA learner.

Refined deterministic automata are produced based on the use trace slices act . Generally the refined deterministic finite automata refines the deterministic finite automata produced in act by expanding the deterministic finite automata produced in act to split each state according to its incoming edges e.g. one state per incoming edge . The expanded deterministic finite automata is then traversed using the obtained trace slices and edges in the expanded deterministic finite automata that are not used in any of the obtained trace slices are removed. The resulting deterministic finite automata is compressed by merging states having the same outgoing transitions and removing those states have no incoming transitions to produce the refined deterministic finite automata.

Equivalent regular patterns are generated from the refined deterministic finite automata act . These regular patterns are generated using a regular pattern generator that generates equivalent regular patterns from finite state machines.

The regular patterns generated in act and the refined deterministic finite automata produced in act are output act . One or more deterministic finite automata are generated for each trace slice obtained in act and output in act as the specification for the trace slice. Alternatively both the regular patterns and refined deterministic finite automata are not output in act e.g. only one of the regular patterns and refined deterministic finite automata may be output .

The following describes an example implementation of parametric trace slice mining. The trace slices are input to a probabilistic finite state automata learner the output automata are input to an automata refiner. The automata refiner refines the automata generating the finite state machines that are the specifications for the trace slices. These finite state machines are also input to a regular pattern generator which generates equivalent regular patterns from the finite state machines.

The probabilistic finite state automata learner infers a finite state machine automaton from a set of strings which are the trace slices discussed above. The inferred state machine accepts at least the input trace slices and may allow more as oftentimes the probabilistic finite state automata learner generalizes during its learning process. A variety of different well known probabilistic finite state automata learners can be used with the parametric trace slice mining discussed herein. In one or more embodiments the probabilistic finite state automata learner is the well known sk string algorithm. Additional information regarding the sk string algorithm can be found in for example The sk strings method for inferring pfsa by A. V. Raman and J. D. Patrick International Conference on Machine Learning ICML 97 1997 .

Generally the sk string PFSA learner first constructs a prefix tree which is essentially a finite state automaton that accepts precisely the input set of strings. Each arc of the prefix tree is labeled with a frequency that represents how many times the arc was traversed during the creation of the tree. The sk string algorithm is then used to merge states in the prefix tree to build a more compact and more general nondeterministic finite automaton.

State merging is based on a concept referred to as sk equivalence . In sk equivalence refers to the set of words used in the strings Q refers to the set of states in the prefix tree Q 2refers to the transition function and Frefers to the set of final states. The set of k strings of state q is then defined as the set z z z k q z Q z 

Thus the probabilistic finite state automata learner outputs deterministic finite automata each automaton having nodes that represent the involved components and edges are labeled with events.

The deterministic finite automata output by the probabilistic finite state automata learner can be over generalized. To compensate for such over generalization the automata refiner refines the deterministic finite automata output by the probabilistic finite state automata learner using the trace slices.

Example pseudo code for an algorithm performing parametric trace slice mining is included in Table XII below and is referred to as algorithm R. An automaton refers to a tuple S i F where S refers to a set of states refers to a set of events i S is the initial state S S is the transition function and FS is the set of final states. Algorithm R includes a function main and a function expand . The main function of algorithm R takes as an input an automaton A S i S S F and a set of trace slices T and outputs an automaton A. The main function of algorithm R uses local values of automaton A S i F state s s and transition function . The expand function of algorithm R takes as an input an automaton A S i F and outputs an automaton A S i F . The expand function of algorithm R is initialized by setting S to setting F to and setting to . The expand function of algorithm R also use local values of integer n set of states D and map S 2.

In algorithm R the input automaton is expanded using the expand function which splits each state according to its incoming edges. The incoming edges are counted as follows if s e s for some s s then e represents an incoming edge to s . Additionally it is assumed that the initial state has a default incoming edge at lines 3 to 5 in the expand function . If state s has n incoming edges then n new states are generated for the new automaton and the mapping from s to the corresponding set of newly created states is kept in at lines 6 to 8 in the expand function . The expand function then builds transitions in the new automaton at lines 10 to 23 as follows. If s e s is a transition in the input automaton and s s then a state s from s with no incoming edges yet is chosen and transitions are added from every state in s to s . Ifs is a final state then all states in s are also final if s is the initial state then a state from s with no incoming edges is chosen as the new initial state. Thus the input automaton is expanded to an equivalent automaton in which every state has a set of incoming edges corresponding to one incoming edge in the original automaton.

The algorithm R then traverses the expanded automaton using the input set of trace slices and marks the transitions used in the traversal at lines 3 to 13 of the main function . After all the traces are applied the unmarked transitions which are not traversed in the trace slice are removed from the expanded automaton to generate a reduced automaton. The reduced automaton is then compressed by merging states that have the same outgoing transitions and removing those states that have no incoming states. At the end the compressed automaton is associated with parameter information the combination of parameters associated with the trace slice being analyzed removed when performing the parametric trace slicing discussed above. The output of the algorithm R is the finite state machines that are the specifications for the trace slices.

The output of the algorithm R can also be input to a regular pattern generator that generates equivalent regular patterns form the finite state machines. A variety of different well known regular pattern generators can be used with the parametric trace slice mining discussed herein. In one or more embodiments the regular pattern generator uses the well known Brzozowski method. Additional information regarding the Brzozowski method can be found in for example Derivatives of regular expressions by J. A. Brzozowski Journal of the Association for Computing Machinery ACM 11 4 481 494 1964 .

Computing device includes one or more processor s computer readable media such as system memory and mass storage device s input output I O device s and bus . Processor s include one or more processors or controllers that execute instructions stored in system memory and or mass storage device s . Processor s may also include computer readable media such as cache memory.

System memory includes various computer readable media including volatile memory such as random access memory RAM and or nonvolatile memory such as read only memory ROM . System memory may include rewritable ROM such as Flash memory.

Mass storage device s include various computer readable media such as magnetic disks optical discs solid state memory e.g. Flash memory and so forth. Various drives may also be included in mass storage device s to enable reading from and or writing to the various computer readable media. Mass storage device s include removable media and or nonremovable media.

I O device s include various devices that allow data and or other information to be input to and or output from computing device . Examples of I O device s include cursor control devices keypads microphones monitors or other displays speakers printers network interface cards modems lenses CCDs or other image capture devices and so forth.

Bus allows processor s system mass storage device s and I O device s to communicate with one another. Bus can be one or more of multiple types of buses such as a system bus PCI bus IEEE 1394 bus USB bus and so forth.

Although the description above uses language that is specific to structural features and or methodological acts in processes it is to be understood that the subject matter defined in the appended claims is not limited to the specific features or processes described. Rather the specific features and processes are disclosed as example forms of implementing the claims. Various modifications changes and variations apparent to those skilled in the art may be made in the arrangement operation and details of the disclosed embodiments herein.

