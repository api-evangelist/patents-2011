---

title: Runtime machine supported method level caching
abstract: A computer system includes a disk space comprising at least one type of memory and an operating system for controlling allocations and access to the disk space. A runtime machine runs applications through at least one of the operating system or directly on at least one processor of the computer system. In addition, the runtime machine manages a selected runtime disk space allocated to the runtime machine by the operating system and manages a separate method cache within the selected virtual disk space. The virtual machine controls caching within the method cache of a separate result of at least one method of the application marked as cache capable. For a next instance of the method detected by the runtime machine, the runtime machine accesses the cached separate result of the method in lieu of executing the method again.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08131925&OS=08131925&RS=08131925
owner: International Business Machines Corporation
number: 08131925
owner_city: Armonk
owner_country: US
publication_date: 20110124
---
This application is a continuation of commonly assigned U.S. patent application Ser. No. 11 773 462 filed Jun. 5 2007 which is hereby incorporated herein by reference.

The present invention relates in general to an improved runtime machine such as a virtual machine or interpreter. Still more particularly the present invention relates to an improved runtime machine for supporting method level caching.

One consideration in application development is how to achieve performance requirements for an application across multiple hardware and software platforms. For many applications caching data can significantly improve the performance of response times by saving computed results in a cache associating the saved results with properties of the request and obviating computations for subsequent similar requests by serving responses from the cache. In particular enhanced performance may be achieved for object oriented programming language applications by caching the outputs of methods such as by caching a hash table generated when a method is run.

To improve the performance of applications across multiple platforms many applications today are written to run on cross platform runtime machines such as virtual machines and interpreters. Examples of virtual machines include but are not limited to Java Virtual Machine JVM Java and JVM are registered trademarks of Sun Microsystems Inc. and Common Language Runtime CLR . Examples of interpreters include but are not limited to PERL and PYTHON. Different versions of a runtime machine are written for various computer platforms running various operating systems where any application written for the runtime machine can be operated on any of the platforms instead of a developer having to produce a separate version of the application for each computer and operating system.

Typically for a runtime machine to run atop the operating system or hardware platform and execute an application the runtime machine requests a portion of the cache heap from the operating system and manages the allocated portion of the cache heap. Currently however cache management by runtime machines does not include programming language support for caching data at the method level. Thus to implement method level caching for applications written to run on a runtime machine users are limited to writing custom code for a particular platform to manually store results of methods in the cache such as by manually maintaining hash maps or users are limited to writing applications to run through an additional layer of software with specialized libraries or APIs which control caching where the additional layer of software runs atop the runtime machine.

Requiring a user to customize code for a platform for manual caching or to implement an additional software layer which supports method level caching however overlooks the goal of reusability of one version of an application across multiple platforms running on top a runtime machine at each platform. A user may write customized code to manually control method level caching based on the cache size cache scheme and cache coherence for one platform but for a different platform the code would have to be rewritten to provide enhanced performance on that platform. Further a user may write customized code with caching commands for method level caching supported by a specialized software layer but then for the application to run on a particular platform that additional software layer is required in addition to the runtime machine.

Therefore there is a need for a method system and program for supporting fine grained method level caching through a runtime machine in the portion of the cache heap allocated to the runtime machine. In addition there is a need for an interface through which a user may select during runtime whether to direct the runtime machine to cache the output of a particular method.

Therefore the present invention provides in general an improved runtime machine such as a virtual machine or interpreter which supports caching of method results.

In one embodiment a computer system includes a disk space comprising at least one type of memory and an operating system for controlling allocations and access to the disk space. A runtime machine includes a virtual machine controller or interpreter controller to run applications through at least one of the operating system or directly on at least one processor of the computer system. In addition the runtime machine manages a selected virtual disk space allocated to the runtime machine by the operating system and manages a separate method cache within the selected virtual disk space. The runtime machine controls caching within the method cache of a separate result of at least one method of the application marked as cache capable. For a next instance of the method detected by the runtime machine the runtime machine accesses the cached separate result of the method in lieu of executing the method again.

The runtime machine may detect whether a method is cache capable by analyzing the application code for an application for a marking identifying the method within the application code as cache capable where the marking includes one of a tagged interface an annotation or a class level modifier. A developer or the runtime machine may mark a method as cache capable in the application code.

In addition or alternatively the runtime machine may detect whether a method within the application code is cache capable by analyzing the method at runtime to determine whether the method is a candidate for caching. In particular the runtime machine analyzes each method to determine whether all the arguments of the method are cacheable. If all the arguments of the method are cacheable then the runtime machine marks the method as cache capable within the application code. When the runtime machine is implemented with an interpreter controller the application code represents source code which is interpreted by the interpreter controller at runtime. When the runtime machine is implemented with a virtual machine controller the application code at runtime represents bytecode which a compiler builds prior to runtime from the source code of the application. Separately prior to runtime if the runtime machine compiles the source code of the application into bytecode the runtime machine may analyze each method to determine whether the method is suitable for caching and marks each method which is suitable for caching as cache capable within the compiled bytecode for the application.

The runtime machine may also detect whether a method is cache capable through a user selection through a user interface supported by the runtime machine. The runtime machine presents the user via the user interface with a list of methods for the application and the user may select via the user interface one or more methods for the runtime machine to mark as cache capable in the application code run by the runtime machine for the application.

In addition the runtime machine may detect whether a method is cache capable from a separate cache property file accessible separate from the application. The runtime machine accesses the cache property file which specifies a selection of methods for marking as cache capable. The runtime machine marks the selection of methods of the application from the cache property file as cache capable in the application code run by the runtime machine for the application.

In accessing the cached result of a method for a next instance of the method the runtime machine first performs a hashing function to calculate a hash index for the method using at least one object graph of at least one argument of the method as inputs to the hashing function. The runtime machine searches the method cache with the hash index and upon detecting a cache hit detects whether the method entry at the hash index is valid. If the method entry at the hash index is valid then the runtime machine uses the method entry as the result for the method. If the method entry at the hash index valid is not valid then the runtime machine runs the method and caches the result of the method in the method cache at the hash index location. In addition if the runtime machine searches the method cache with a hash index and there is a cache miss the runtime machine runs the method and caches the result of the method in the method cache at the hash index location.

With reference now to the figures and in particular with reference now to a block diagram illustrates one embodiment of a stack in which a runtime machine which supports method level caching is implemented. In the example a stack for running on a computer system or a network of computer systems includes a runtime machine . Runtime machine provides an environment for running applications through an operating system or directly on a processor of a computer system not depicted . It is important to note that as used herein runtime machine implements a virtual machine or interpreter such as but not limited to virtual machines such as a Java Virtual Machine JVM Java and JVM are registered trademarks of Sun Microsystems Inc. or Common Language Runtime CLR and interpreters such as PERL or PYTHON. Applications include application code written in object oriented programming languages supported by runtime machine wherein the application code of applications can run on different computer platforms through a different runtime machine specified for the each of the different platforms. As described herein application code may refer to but is not limited to the source code of an application compiled bytecode from the source code executed bytecode or interpreted source code. Applications may also include middleware such as Websphere Websphere is a registered trademark of International Business Machines Corporation or other service software layers atop which applications can run and which runtime machine views as an application.

Operating system interfaces with disk space which may include cache. In one embodiment operating system allocates a portion of disk space specifically for management by runtime machine as illustrated by virtual disk space which may also be referred to as the heap or cache allocated to runtime machine . Runtime machine controls cache allocations and data storage within the virtual disk space . In addition in controlling caching within the virtual disk space runtime machine may also control garbage collection or other cache management to periodically remove unused or expired data or to rearrange data to create larger blocks of unused space for allocation. Virtual disk space may include either or both of physical representations and logical representations of disk space 

An application programming interface API layer provides libraries and support through which applications runtime machine and operating system may communicate with a user. API layer may include API libraries packaged with runtime machine for enabling a user interface through which a user may select operation parameters for runtime machine .

Advantageously runtime machine supports method level caching. As described herein a method is used in object oriented programming to refer to a programmed procedure which is defined as part of a class or included in any object of the class. In addition other types of object oriented methods may be implemented. It will be understood that runtime machine may also support caching of other types of methods.

In the example to support method level caching runtime machine includes a method support layer which enables runtime machine to determine whether a method is suitable for caching to control caching of the results of cache capable methods to virtual disk space and to control accesses to previously cached results of a method from virtual disk space .

In one example in determining whether a method is suitable for caching method support layer directs runtime machine to analyze application code for applications and separate cache property files accessible separate from application code to detect whether a method has been marked as cache capable within the code or in the separate cache property file. In particular method support layer may include a library that defines language commands for marking a method as cache capable and for specifying an amount of time that the result of the method is valid when cached. Thus applications may include application source code that includes programmed cache capable commands marking cache capable methods or a separate cache property file may designate one or more cache capable methods as illustrated at reference numeral .

In another example in determining whether a method is suitable for caching method support layer may direct runtime machine to analyze application code for applications to decide whether a method is cache capable. In addition method support layer may enable runtime machine responsive to analyzing application code and deciding that a method is suitable for caching to add commands to the application code to specify the particular method as cache capable.

In a further example in determining whether a method is suitable for caching runtime machine may be packaged with method APIs in API layer . Runtime machine may call method APIs to prompt a user to select whether a method is cache capable whether to cache a cache capable method how long to cache a cache capable method and other parameters of method level caching supported by method support layer .

Referring now to a block diagram depicts one embodiment of a runtime machine for controlling method level caching within the cache managed by the runtime machine. It will be understood that in other embodiments additional or alternate components may be implemented by a runtime machine for controlling method level caching.

Runtime machine controls the execution of application code of applications . In one example runtime machine may include a virtual machine VM controller where virtual machine controller compiles source code of application code into binary instructions also referred to as bytecode and executes the bytecode at runtime on operating system or directly on a processor. In another example application code may represent bytecode already compiled by a virtual machine compiler. Further in another example runtime machine may implement an interpreter where application code represents source code for an interpreted language which interpreter controller translates and executes at runtime on operating system or directly on a processor. It is important to note that runtime machine is described herein as implementing either virtual machine controller or interpreter controller however in another example runtime machine may implement both virtual machine controller and interpreter controller or may implement multiple instances of one or more of virtual machine controller and interpreter controller .

In the example virtual disk space includes an application heap managed by runtime machine from operating system for one or more applications. In addition in the example virtual disk space includes a method cache allocated by runtime machine from operating system for caching method results.

According to an advantage runtime machine supports method level caching by determining when a method is suitable for caching in method cache and if the method is cache capable passing the method to cache comparison unit . As previously noted with respect to runtime machine may determine whether a method is suitable for caching at one or more points in handling application code.

In particular in one example in determining whether a method is suitable for caching an application developer may specify suitability by marking particular methods as cache capable within source code . In one example virtual machine controller detects methods marked as cache capable within compiled bytecode of application code . In another example as interpreter controller executes the source code of application code interpreter controller detects those method marked as cache capable.

In the example within an object oriented programming language based application a developer may select to mark specific methods as cache capable within the source code by marking one or more objects or classes of a method or the method itself using tags annotations or class level modifiers for example. In addition virtual machine controller and interpreter controller may also mark methods as cache capable using tags annotations or class level modifiers. For example with reference now to code depicts a method specified as cache capable through the class level modifier of CacheCapable illustrated at reference numeral . In addition with reference to code depicts a method specified as cache capable through an annotation of CacheCapable as illustrated at reference numeral .

In another example in determining whether a method is suitable for caching virtual machine controller or interpreter controller determine at runtime that a method is a candidate for caching by checking each argument of the method and each object graph the method returns to determine if the method includes all cache capable objects. If the arguments of a method and returned result are all cache capable then virtual machine controller or interpreter controller mark the method as cache capable and pass the method to cache comparison unit . In one example in determining whether a method is cache capable virtual machine controller or interpreter controller detect any primitive types of arguments such as int or string as cache capable but detects any non primitive types of arguments such as another object s file handle or connection to a file system such as file system as not cache capable.

In yet another example in determining whether a method is suitable for caching virtual machine controller determines prior to runtime during compilation of the source code of application code into bytecode whether each method should be cached and annotates within the bytecode those methods which are cache capable. In particular it is important to note that virtual machine controller may perform statistical analysis of method arguments and return objects of the compiled source code to determine whether to mark a method as cache capable.

In addition in another example in determining whether a method is suitable for caching a cache property file may include global cache capable settings. In one example cache property file may specify one or more particular methods as cache capable. In another example cache property file may specify one or more types of methods or types of objects or classes as cache capable. Further cache property file may specify one or more methods which should be cached with priority over other methods. In addition it will be understood that cache property file may include additional or alternate types of cache settings including settings for the size of virtual disk space settings for the size of method cache settings for the maximum method return result to be cached in method cache and settings for turning off method level caching. Further cache property file may also include methods marked as not cache capable even though the method would be a candidate for caching or may be marked as cache capable within the coding of the application.

At runtime virtual machine controller or interpreter controller of runtime machine may access cache property file or during compilation VM controller may access cache property file to detect designated cache capable methods. In the example cache property file is an XML file stored at a particular address within a particular location within file system . In other embodiments the file type and locations for storing cache property file may vary. In addition in other embodiments runtime machine may access cache property file from a storage device other than file system . Further in other embodiments runtime machine may access multiple cache property files from multiple locations within file system or distributed across multiple file systems. Moreover an application or runtime machine may include a cache property file bundled with the application or runtime machine and installed within file system when the application or runtime machine is installed or run.

Moreover in determining whether a method is suitable for caching runtime machine may call method level APIs to prompt a user via a console to analyze and select the cacheable setting for a method. For example runtime machine may prompt a user via console with a list of each detected methods within application code wherein the user may designate whether each method is cache capable. In another example runtime machine may prompt a user via console with a list of each detected method marked within the code as cache capable wherein the user may designate whether a particular cache capable method should be cached during runtime. In addition runtime machine may provide the user via console with information indicating current cache allocations to virtual disk space percentage of memory heap in use and other cache statistics wherein a user may request adjustment of the allocation amounts.

In one embodiment cache property file specifies the selection of method level APIs to be called to present a user with method level cache information and selections. In addition in one embodiment as a user makes selections via console method level APIs are called which update cache property file with the user selections.

During runtime virtual machine or interpreter of runtime machine detect a cache capable method and pass execution control of the method to cache comparison unit . As previously noted virtual machine controller or interpreter controller may detect application code already marked with cache capable methods at compile time or by a developer interpreter controller or virtual machine controller may analyze application code at runtime and mark cache capable methods virtual machine controller may analyze application code at compile time and mark cache capable methods interpreter controller or virtual machine controller may detect a method selected to be cache capable in cache property file or interpreter controller or virtual machine controller may detect a user selection during runtime for a method to be cache capable. In addition interpreter controller or virtual machine controller may detect that a user selection during runtime via console or a specification in cache property file overrides developer specifications for methods. For example a method specified as cache capable in application code may be overridden by a setting in cache property file specifying that the method is not cache capable.

Cache comparison unit supports method level caching by searching method cache for previously stored results of a method storing results of a method and managing how long method results are cached. In addition it will be understood that cache comparison unit may perform additional functions in managing virtual disk space and analyzing methods to determine whether a method is cache capable.

In one embodiment upon receiving execution control of a cache capable method cache comparison unit implements a hash function to return a hashvalue using the object graphs of each argument to the cache capable method as inputs. Next cache comparison unit searches method cache using the determined hashvalue as an index. It will be understood that additional or alternate types of functions may be implemented to calculate an index into the cache to determine whether there is a cache hit or cache miss for a method.

If cache comparison unit detects a cache miss for the hashvalue in method cache then cache comparison unit executes the method and caches the result in method cache . Otherwise if cache comparison unit detects a cache hit for the hashvalue in method cache cache comparison unit inspects the timestamp for the cache entry in method cache to determine if the cache entry is stale because the amount of time passed since the timestamp exceeds a timeout setting for the method. If the cache entry is stale cache comparison unit executes the method and caches the result in method cache . If the cache entry is not stale then cache comparison unit uses the cached result from method cache .

In determining whether a method entry is stale the timeout setting for the method may be specified in the method code using an annotation or keyword for example. For example with reference now to code depicts an object with an annotation illustrated at reference numeral specifying a method level cache timeout of CacheTimeout 100 and CacheRes min to specify a timeout of 100 minutes. In code additional keywords illustrated at reference numeral CT 100 and CR M specify a method level cache timeout of 100 minutes. It is important to note that while the examples of timeout settings in illustrate timeout settings in minutes other increments of time may be set.

A developer may specify the timeout settings for methods when coding the application. In addition if runtime machine modifies a method entry as cache capable interpreter controller or virtual machine controller may access cache property file to determine what timeout periods to associate with message entries globally or by object types. Further cache property file may include global or object level timeout periods which override any timeout periods coded by the developer in the application.

In addition as to setting the timeout setting for a method a user may select via console a timeout setting for a particular method a selection of methods and a type of method. In addition cache property file may specify that a user should be prompted via console to select whether to extend a timeout setting which has expired for a particular method or type of method.

For a cacheable method additional control settings may be specified for a particular method or in cache property file based on the operating conditions of the system such as the processor load the cache load the frequency of garbage collection or other settings. For example cache property file may specify that if runtime machine is performing garbage collection at a frequency which exceeds a particular threshold then the timeout settings for a particular method or type of method should be adjusted.

With reference now to a block diagram illustrates a computer system in which the present invention may be implemented. The controllers and systems of the present invention may be performed in a variety of systems including a variety of computing systems such as computer system communicatively connected to a network such as network .

Computer system includes a bus or other communication device for communicating information within computer system and at least one processing device such as processor coupled to bus for processing information. Bus preferably includes low latency and higher latency paths that are connected by bridges and adapters and controlled within computer system by multiple bus controllers. When implemented as a server computer system may include multiple processors designed to improve network servicing power. Where multiple processors share bus an additional controller not depicted for managing bus access and locks may be implemented.

Processor may be a general purpose processor such as IBM s PowerPC processor that during normal operation processes data under the control of an one or more layers described in stack including but not limited to operating system and runtime machine and other code accessible from a dynamic storage device such as random access memory RAM a static storage device such as Read Only Memory ROM a data storage device such as mass storage device or other data storage medium.

In one embodiment the operations performed by processor may control runtime machine support for method level caching as depicted in the operations of flowcharts of and in other operations described herein. Operations performed by processor may be requested by operating system or runtime machine or other code or the steps of the present invention might be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

The runtime machine for supporting method level caching of the present invention may be provided as a computer program product included on a computer readable or machine readable medium having stored thereon the computer readable program that when run on computer system causes computer system to perform a process according to the present invention. The terms computer readable medium or machine readable medium as used herein includes any medium that participates in providing instructions to processor or other components of computer system . Such a medium may take many forms including but not limited to storage type media such as non volatile media and volatile media. Common forms of non volatile media include for example a floppy disk a flexible disk a hard disk magnetic tape or any other magnetic medium a compact disc ROM CD ROM or any other optical medium punch cards or any other physical medium with patterns of holes a programmable ROM PROM an erasable PROM EPROM electrically EPROM EEPROM a flash memory any other memory chip or any other medium from which computer system can read and which is suitable for storing instructions. In the present embodiment an example of a non volatile medium is mass storage device which as depicted is an internal component of computer system but will be understood to also be provided by an external device. Volatile media include dynamic memory such as RAM .

Moreover the function management tool of the present invention may be downloaded or distributed as a computer program product wherein the program instructions may be transmitted from a remote computer such as a server to requesting computer system by way of data signals embodied in a carrier wave or other propagation medium via network to a network link e.g. a modem or network connection to a communications interface coupled to bus . In one example where processor includes multiple processor elements is a processing task distributed among the processor elements whether locally or via a network may represent a consumer program product where the processing task includes program instructions for performing a process or program instructions for accessing Java Java is a registered trademark of Sun Microsystems Inc. objects or other executables for performing a process. Communications interface provides a two way data communications coupling to network link that may be connected for example to a local area network LAN wide area network WAN or directly to an Internet Service Provider ISP . In particular network link may provide wired and or wireless network communications to one or more networks such as network . Further although not depicted communication interface may include software such as device drivers hardware such as adapters and other controllers that enable communication. When implemented as a server computer system may include multiple communication interfaces accessible via multiple peripheral component interconnect PCI bus bridges connected to an input output controller for example. In this manner computer system allows connections to multiple clients via multiple separate ports and each port may also support multiple connections to multiple clients.

Network link and network both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system may be forms of carrier waves transporting the information.

In addition computer system may include multiple peripheral components that facilitate input and output. These peripheral components are connected to multiple controllers adapters and expansion slots such as input output I O interface coupled to one of the multiple levels of bus . For example input device may include for example a microphone a video capture device a card reader a body scanning system a keyboard a mouse or other input peripheral device communicatively enabled on bus via I O interface controlling inputs. In addition for example an output device communicatively enabled on bus via I O interface for controlling outputs may include for example one or more graphical display devices audio speakers and tactile detectable output interfaces but may also include other output interfaces. In alternate embodiments of the present invention additional or alternate input and output peripheral components may be added.

Those of ordinary skill in the art will appreciate that the hardware depicted in may vary. Furthermore those of ordinary skill in the art will appreciate that the depicted example is not meant to imply architectural limitations with respect to the present invention.

Referring now to an illustrative diagram depicts one example a user interface through which a user may adjust a cache property file or adjust method level cache settings during runtime of an application. In the example an illustration of a user interface for console is depicted. In the example a user may make selections using the placement of cursor and an input or through other inputs available for selecting among the entries within console .

In one illustration of the advantage of runtime machine supporting method level caching a first developer designs a three dimensional 3D multi player video game engine application to run on runtime machine . In a demonstration of the speed of the first developer s 3D engine application against the speed of other 3D engine applications each of the competing developers is required to run their application on the same set of hardware and on the same runtime machine which supports method level caching without any middleware. The hardware provided for the competition has less powerful CPU s but more memory than what the first developer used for testing the 3D engine application.

In the example the first developer as a user may determine a percentage of the methods in the application which are the most computationally intensive and mark these methods as cache capable to take advantage of the increased memory resources. In one embodiment the user may directly edit cache property file and specify the selection of methods to be marked as cache capable by runtime machine . In another embodiment the user may invoke the user interface illustrated in console and make selections within console which trigger edits to cache property file .

In particular in the example the user may select to adjust the percentage of virtual disk space from among the available disk space from 5 the percentage of virtual disk space allocated as method cache from 20 and the maximum percentage of the cache which can be allocated to a single method result from 1 as illustrated within selection area . During runtime the user may also select to adjust the allocation percentages in an attempt to increase performance.

In addition in particular in the example the user may view a list of methods which runtime machine detects as cache capable and which the user has selected to mark as cache capable including classes level1Field level1Fans level1Effects and object playerID as illustrated at reference numeral and the user may select from a list of methods which runtime machine detects as candidates for caching but the user has not yet selected to mark as cache capable including classes level1Terrace level1Player and level1Scoreboard. In one example runtime machine may analyze source code during compilation into bytecode and present the user with a list of methods which are candidates for caching from which the user may select which methods to mark as cache capable. In another example during runtime as methods run runtime machine may present methods which are candidates for caching to the user. Further a user may select to remove a method from the list of cache capable methods illustrated at reference numeral and place the method back in the list illustrated at reference numeral .

Further in particular in the example the user may select to adjust the timeout settings for runtime. In the example illustrated at reference numeral the user has selected a general timeout setting of 5 minutes and a particular object setting for the object playerID of 20 minutes. In selecting cacheable methods although not depicted the user may assign the timeout setting and other variables for controlling the amount of time that a cached method results remains valid.

By enabling the developer to adjust methods marked as cache capable on the fly and by enabling the developer to adjust methods marked as cache capable via cache property file a developer can quickly adjust an application to run most efficiently on a runtime machine based on the CPU power memory size and other hardware characteristics of a platform without having to actually adjust the code of an application or rely on additional middleware to perform caching functions.

With reference now to a high level logic flowchart depicts a process and program for a runtime machine running application code which includes cache capable methods. In the example the process starts at block and thereafter proceeds to block . Block depicts a determination whether a runtime machine detects an application to run. When the runtime machine detects an application then the process passes to block . In one example the runtime machine may detect an application and first compile the source code of the application into bytecode including cache capable markings in the compiled bytecode where the runtime controller executes the bytecode at runtime. In another example the runtime machine may detect an application for execution and interpret and execute the source code of the application at runtime. Although not depicted a runtime machine implementing a virtual machine controller or interpreter controller may require additional steps in executing an application.

Block illustrates accessing a cache property file specifying properties of the runtime machine cache and method level caching specifications. Next block depicts the process performed for each method during execution. Thereafter block illustrates a determination whether the method is marked as cache capable in the cache property file. If the method is marked as cache capable in the cache property file then the process passes to block . Block illustrates marking the method as cache capable and the process returns to block .

Returning to block if the method is not marked as cache capable in the cache property file the process passes to block . Block depicts a determination whether the method is specifically marked as not cache capable in the cache property file. If the method is specifically marked as not cache capable in the cache property file then the process passes to block . Block depicts processing the method as not cache capable and the process returns to block .

Returning to block if the method is not specifically marked as not cache capable then the process passes to block . Block illustrates a determination whether a method is marked as cache capable in the application code. If the method is marked as cache capable in the application code then the process passes to block . Otherwise if the method is not marked as cache capable in the application code then the process passes to block . Block depicts analyzing each argument of a method to determine if the argument is cacheable. Next block illustrates a determination whether any argument in a method is not cacheable. If any argument is not cacheable then the process passes to block . If all the arguments are cacheable then the process passes to block .

Referring now to a high level logic flowchart illustrates a process and program for a runtime machine managing execution of a cache capable method. In the example the process starts at block and thereafter proceeds to block . Block depicts a determination whether the virtual machine controller or interpreter controller detects a cache capable method. When the virtual machine controller or interpreter controller detects a cache capable method then the process passes to block . Block illustrates passing execution of the method to the cache comparison unit and the process passes to block .

Block depicts the cache comparison unit performing a hash function to calculate a hash index for the method using the object graphs of each argument of the method as inputs. Next block illustrates searching the method cache with the hash index. Thereafter block illustrates a determination whether there is a cache hit for the hash index in the method cache. If there is not a cache hit then the process passes to block . Block depicts executing the method and caching the result in the method cache at the hash index. Next block illustrates returning execution control of the method to the virtual machine controller or interpreter controller and the process ends.

Otherwise returning to block if there is a cache hit then the process passes to block . Block illustrates inspecting the timestamp for the entry. In one example the method cache may include a timestamp stored with the method result entry. In another example the cache comparison unit may access the cache property file for a timestamp or prompt the user to select a timestamp. Next block depicts a determination whether the cache entry for the method is valid because based on the timestamp the data has not become stale. If the cached entry is not valid then the process passes to block . If the cached entry is valid then the process passes to block . Block illustrates using the cached result for the method and the process passes to block .

While the invention has been particularly shown and described with reference to a preferred embodiment it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention.

