---

title: Unified notification platform
abstract: Notifications are managed in a unified notification platform that receives messages from disparate services, formats, and protocols, and with disparate attributes and meta-attributes. The unified notification platform provides for user defined meta-attributes to allow rapid classification of incoming messages accordingly to user relationships to message senders, including family, friends and co-workers. Incoming messages are received by a message queue component, serialized and prioritized according to a rules engine. Various user interfaces provide views and reports on the serialized messages. In particular a non-modal notification pop-up is disclosed. The unified notification platform exposes an application programming interface provides automatable and remotable programmatic access for application developers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09503415&OS=09503415&RS=09503415
owner: T-Mobile USA, Inc.
number: 09503415
owner_city: Bellevue
owner_country: US
publication_date: 20110127
---
Convergence is where a single platform unifies data and applications traditionally hosted on different platforms. Convergence may be from the perspective of a hardware device. In this case an example of device convergence may be a mobile phone equipped with a stylus and a touch screen to support software for calendaring note taking and other functionality typically hosted in a personal device assistant PDA . Alternatively convergence may be from the perspective of software applications. In this case an example of software application convergence may be Unified Messaging where voicemail messages are rendered as electronic mail email thus obviating the need to check for pending messages on two mailboxes on two different and separate platforms. Yet another form of convergence may be from the perspective of data formats and or protocols. In this case an example of data format and or protocol convergence is the blurring of packet networks which traditionally carried only application data and switch networks which traditionally carried only voice data. Post convergence packet networks support protocols to carry voice data and conversely switch networks support protocols to carry email internet browsing and other application data.

The present widespread market acceptance of mobile cellular devices has driven many variations and combinations of hardware software and data format and or protocol convergence. As processing power for mobile devices increases and input output devices such as transducers and touch screens miniaturize handheld form factor devices have been merged into mobile phones. Mobile music player functionality PDA functionality digital still camera functionality video camera functionality audio recorder functionality and geolocation functionality are but a few of the many device platforms that have been converged into a mobile phone device platform. The effort to pack such a large amount of functionality into a mobile phone has required a tremendous and expensive investment in the industry as well as a veritable technical tour de force.

However successful device convergence does not necessarily lead to successful application convergence. For example a mobile phone equipped with sufficient memory to carry a library of music and a headphone jack to render music may not necessarily have user friendly software to quickly search and retrieve a particular song. It is possible for a user interface to be so inconvenient to use that a typical user may simply not make use of present hardware functionality.

Similarly successful device convergence does not necessarily lead to successful data format and or protocol convergence. For example a mobile phone may have a protocol stack capable of receiving application data over a cellular transport. However the mobile phone may not have network drivers that expose an application programming interface API sufficiently rich to enable a wide range of applications. It is possible for an API to be so lacking or difficult to use that application developers are not able to provide users with applications that fully exploit the possibilities afforded by data format and or protocol convergence.

In either of these situations any market advantage achieved by converging hardware functionality is lost. In general overcoming tremendous difficulties in convergence may not be rewarded in the market without corresponding improvements in user experience and application developer support.

This disclosure relates to a platform to unify messages on mobile devices which may include mobile phones netbooks laptop computers and mobile tablets. Specifically this disclosure describes a platform to review messages from disparate sources formats and transports. This platform collectively referred to herein as a unified notification platform comprises a user interface that enables unified message review without blocking workflow of other running applications a unified message queue a rules engine to allow rich customization of unified message queue behavior and an application programming interface to provide applications developers programmatic access to the aforementioned user interface message queue and rules engine.

The unified notification platform provides many features to eliminate discontinuities in the user s experience with a unified message queue and with the user s experience with the unified message queue as integrated with a mobile device as a whole. The user interface includes a non modal notification pop up window which does not block access to other user interfaces when the pop up appears. In this way the user s workflow and train of thought is not interrupted while receiving notifications.

The unified notification platform may couple the user interface with a unified message queue that recognizes not only data format attributes of incoming messages but also user relationship centric meta attributes. Examples of user relationship centric meta attributes may include message information whether the message source is work related or alternatively whether the message is from a parent guardian. In this way a work related alert may be prioritized over personal alerts such as Tweets and Facebook notifications. In particular notification systems were originally developed to alert users of events thus freeing users from repeatedly checking messages. Due to the present mass of notifications from disparate applications users are in effect trained to ignore notifications and periodically check messages obviating the design goals of notifications.

The unified notification platform may support user customization via a rich rules engine. Because the unified message queue supports not only data format attributes but user relationship centric meta attributes of messages the rules engine may be configured according to user relationship centric patterns. For example a child s cell phone may be configured via the rules engine to display messages from a parent guardian first or to suppress all other messages until the parent guardian s messages are read first. The notification pop up and or unified message queue may be customized to suppress or purge notifications during sleep periods as not to present a user with a disproportionately large number of notifications upon return.

A user notification platform exposes all aspects of the notification pop up user interface the unified message queue and the rule engine via a rich application programming interface API . Accordingly the API provides application developers with full access to all features for custom applications. In particular the notification pop up interface the unified message queue and the rules engine may support automatable and remotable properties methods and programmatic events thereby enabling scripting.

As noted above the present unified notification platform removes various user experience discontinuities with unified messaging via providing a non modal notification pop up user interface a unified message queue a rules engine and an API. illustrates an example operation of the unified notification platform.

A user may host the unified notification platform on a client device . The client device may be a mobile device including but not limited to mobile phones netbooks laptop computers and mobile tablets. In alternative embodiments the client device may be standalone personal computer terminal or non portable embedded system. In yet other embodiments the user may host the unified notification platform on a distributed system comprising one or more servers and the client device . In the distributed embodiment the unified notification platform may be hosted fully or in part on one or more servers. Accordingly the unified notification platform has broad applicability to a wide range of hosts.

Client device displays a user interface that may couple to a message queue component which may be configured via rules executed by a rules engine . The message queue component may access one or more message queues specific to particular message data format message transport message attribute or message user relationship centric meta attribute. Accordingly message queues act at least as initial receiving queues to perform message specific processing such as packet payload extraction decompression decryption verification and classification by attribute and or meta attribute.

Messages may arrive from one or more message sources . A message source may be differentiated by a data protocol for example a first source representing email over SMTP and a second source representing SMS text messages. Alternatively a message source may be differentiated by an application source such as Twitter notifications email notifications voicemail notification and operating system device notifications. Yet another message source differentiator may be user relationship centric meta attributes for example differentiating personal notifications from Facebook from emergency email notifications from the user s employer.

Each message source asynchronously broadcasts messages respectively to an address associated with a user s message queue component . The address may relate to the user s client device or in a distributed embodiment may relate to one or more servers which serve data to the user s client device depending on the hosting location of the message queue component .

It is to be noted that the various messages may be comprised of multiple parts. For example email is typically transmitted over packet networks. Accordingly large emails may be separated into multiple packets which arrive separately. By way of another example some notifications are transacted where a first portion containing the data is locked until a second portion containing a transaction commit operation enables access.

Accordingly the various messages are sent to their respective message specific queues for processing. The message specific queues may be the internal processing queues for a particular protocol or data format. Alternatively the message specific queues may be separate queues specific to the message queue component . An example of message queue component specific queue is a queue that recognizes attributes or user relationship centric specific meta attributes of messages.

The rules engine asynchronously manages a virtual queue consolidating the various message specific queues . The rules engine extracts messages from the various message specific queues in the virtual queue prioritizes the extracted messages and then presents the messages to client device in a user interface according to the specified rules. The user interface on client device may be a non modal notification pop up window that does not block the operation of software user interface of other opened applications

Client device may comprise a processor a hardware user interface potentially comprising a keyboard and or custom button a hardware display and a memory .

The custom button may be a dedicated button or hardware control operative that may be mapped to a particular software function. In one embodiment the custom button may activate a notification pop up user interface. In another embodiment the custom button may trigger a refresh of the message queue.

Hardware display may be a touch screen supporting virtual keyboards. Accordingly the keyboard may be optional. Alternatively for personal computer and other terminal based embodiments the hardware display may be a monitor separate from a standalone device.

Memory includes both short term and long term memory and may host the unified notification platform. Examples of short term memory include static random access memory SRAM and dynamic random access memory DRAM . Examples of long term memory include programmable read only memory PROM and hard disks.

Both short and long term memory both on board and removable computer readable media. Computer readable media includes at least two types of computer readable media namely computer storage media and communications media.

Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other non transmission medium that can be used to store information for access by a computing device.

In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transmission mechanism. As defined herein computer storage media does not include communication media.

The unified notification platform as hosted in memory comprises a message queue component including one or more message specific queues a rules engine including data operations rules and message setting rules a virtual queue a software display module and a software notification module .

The message queue component is comprised of various message specific queues and a virtual queue of messages. It may comprise a rules engine or may alternatively be coupled to an external rules engine.

The various message specific queues operate to receive messages and notifications that must be processed together. As noted above there is a large range of bases for separate processing such as different protocols reconstituting messages differently and different messages and notifications being subject to different security schemes.

The message queues may optionally be associated with message queue software drivers to perform the message specific processing. In this way the message queue component may be extended to support new data formats protocols attributes and meta attributes over time. Additionally the messages queue software drivers may allow data operations on the various message specific queues .

The rule engine may perform data operations on both the various message specific queues and a virtual queue of messages. The rules engine may operate to read a script of data operations rules which when execute create one or more directives to create retrieve update modify and delete messages as well as retrieve attribute meta attribute and queue statistics on the various message specific queues and the virtual queue . The rules engine may also set and retrieve message attributes and meta attributes according to message attribute setting rules on the various message specific queues and the virtual queue . Thus not only may the rules engine may manage a virtual queue of messages filtered from the various message specific queues but may also perform management operations on the various message specific queues such as purging queues and auditing. The message queue component rules engine and virtual queue are described in greater detail below with respect to .

The software display module provides unified notification platform specific user interface. An example unified notification platform specific user interface may be a non modal notification pop up window as described below with respect to .

The software notification module provides a clearinghouse to both receive and broadcast software notifications within the unified notification platform. Specifically the software notification module enables the receipt of custom events to trigger actions within the unified notification platform. Examples may include subscribing to custom button events such that when pressed the software display module displays a notification pop up window. Alternatively a keyboard chord such as CTRL M could be mapped to the software display module as well.

Conversely events within the unified notification platform could be exposed via the software notification module and subscribed to. One example may include receipt of a high priority message where a subscribing third party application proactively displays an alert to the user. By way of another example message addition software events and reordering operation software events within the virtual queue may be subscribed to by a utility to track provide audit and debug information.

The unified notification platform supports extensibility and application development support via an application programming interface API . Specifically the API programmatically exposes properties methods and programmatic events of the unified notification platform. Via a software library developers may program third party applications hosted on the client device . The API may be automatable and remotable to enable scripting languages access to the unified notification platform. Rules engine or an external rules engine may invoke API to perform operations on the various message queues the virtual queue and other portions of the unified notification platform. Accordingly notification management may be effected both by custom applications running on the client device or alternatively via applications running remote of the client interfacing via the network or input output ports.

The unified notification platform supports a wide range of user interfaces via software display module . Specifically any data relating to the virtual message queue the various message queues and the messages and notifications within may be aggregated and reported.

Example aggregations may include message count by message service message count by message thread and message thread count.

A message count by message service report provides counts of the number of messages and notifications for messages requiring the same processing. SMS text and SMTP mail are two different services based on transport and protocol stack. However services may be defined by a combination of attributes and user relationship centric meta attributes. Accordingly Facebook notifications and Twitter tweets might be examples of two different services. Since the various message queues are defined in the same terms message count by message services may be calculated by invoking queue counts from the respective drivers of the various message queues . Alternatively a version of the message count by message service report may be implemented via performing message and notification counts by attributes and or meta attributes in the virtual queue .

A message count by message thread report provides counts of messages and notifications related by message thread. For example an email thread consisting of an initiating email a response email and a response to the response would have a message count of three. In a message queue that combined voicemail and email an initiating phone call replied to via a response email would have a message count of two despite the two messages having different transports. In the event that the unified messaging provides for processing in the same message queue the attributes and meta attributes may be reviewed to identify and count which messages and notifications belong to the same message thread. In the latter example messages and notifications from different messages queues may have to be counted together. Accordingly in one embodiment the virtual queue could be searched to identify which messages and notifications belong to the same message thread.

A message thread count report is related to the message count by message thread report. The message thread count report simply reports a count of message threads presently managed by the unified notification platform. For example a unified notification platform that had a message thread relating to Classroom Assignment and another message thread relating to After Work Basketball Game would have a message thread count of two. The message threads could be identified in the same ways that the message count by message thread reports disclosed above.

The aforementioned is not intended to be an exhaustive list of reports. A person having ordinary skill in the art will recognize variations to the aforementioned reports and all other reports herein.

Message and notification operations in particular searching and sorting may depend on what message attributes and meta attributes are associated with the messages and notifications. In particular message attributes are property values associated with a message that relate to routing and the contents of the message. Typically attributes are not user definable and are artifacts of the routing protocol. Table 1 below enumerates some example message attributes 

Message and notification meta attributes are property values associated with a message and are generally user defined. The meta attributes are defined to facilitate identifying messages and notifications that are to be processed together for example in the same message queue. Table 2 below enumerates some example message and notification meta attributes 

As can be seen from Table 2 some of the message and notification meta attributes describe user relationships. User relationship information may be utilized to increase or decrease the priority level of messages and or to change the behavior of the unified notification platform. An example of a unified notification platform behavioral change may be to block all other messages and notifications until all messages marked with a parent guardian flag are read. Another example would be to display all messages and notifications marked with a work flag first.

In particular behavioral changes of the message queue component may be effected via rules executed in the rules engine . Notwithstanding the emphasis on user relationship information not all behavioral changes in the message queue component are specific to user relationship information. For example rules may be set to perform an operation after a predetermined time period has passed. Additionally rules by be set conditions from events external to the message queue component. For example the message queue may block access to messages where a service payment has been missed. Operation of the rules engine is described in more detail with respect to .

It is possible for the set of message and notification attributes to overlap with the set of message and notification meta attributes. For example both Table 1 and Table 2 above have a source identifier originating application field. Whether data is an attribute or meta attribute may depend on context. Thus although an attribute X and a meta attribute Y are to store the same data their values may be set by different programs. Accordingly this provides a vehicle by which to verify and authenticate incoming messages. For example the rules engine may introduce logic to determine whether the source identifier attribute and the source identifier meta attribute are consistent. Where the values are inconsistent the rules engine may quarantine or otherwise block access to the message. Alternatively an attribute may store a cryptographic key from one party and a meta attribute may store a security certificate from another party. Upon receipt the rules engine might perform a check to ensure the cryptographic key properly corresponded to the security certificate. In this way the rules engine in concert with attributes and meta attributes may perform spoof checking security certification spam filtering and other security functions.

One example user interface for the unified notification system is a notification pop up window that displays summaries of messages message threads and or contents of the unified message queue in a non modal window.

Non modal windows are active windows in a graphical user interface that do not block the operation of software user interface of other opened applications. Non modal windows are the converse of modal windows that deactivate all other user interface elements except for those within the modal dialog box. Examples of modal windows are alert dialog boxes or confirmation dialog boxes e.g. a warning window stating Do you really want to delete file X . While the developer intent is to ensure the user s attention is directed to the modal dialog box in many scenarios such as multi tasking mobile devices the effect is often to inconvenience a user whose attention must be directed elsewhere. For example a user in the midst of typing an email may lose his or her train of thought when presented with a modal alert.

Throughout this period because the notification pop up window B is non modal the user is not interrupted in his or her use of the Gallery application A. The user may continue to review digital pictures A and the Gallery application A continues to receive user input. Because the non modal notification pop up window B only covers the title bar of the Gallery application A the user s substantive view of the Gallery application A is not obstructed.

The user may enter a reply message in the reply box C. The user may subsequently press the Send button C to send the entered reply. In other embodiments the user may enter in line comments in the incoming message or notification as part of the reply. Upon sending the non modal notification pop up window C disappears. Alternatively the user may cancel operation by pressing the exit button C at any time.

If the user responds to the first message before it disappears operation is as discussed with respect to . In the meantime the user is not interrupted in his or her operation of the underlying application.

The notification pop up user interface or alternative user interfaces may be coupled to a message queue component and rules engine. The message queue component and rules engine may manage a large number of disparate message notifications messages and message threads. In particular the message queue component and rules engine converges messages not only from different mediums such as voicemail and email but also different protocol stacks such as SMTP and SMS messages and from different application sources such as system alerts and social networking notifications. Because the disclosed message queue component and rules engine not only leverages data formats information about incoming messages but also information about the originating application of incoming messages the message queue component and rules engine enable aggregated summaries of a much wider range of messages and notifications than previous unified messaging efforts. For example a user may prioritize different application sources. A user may assign a high priority to work related alerts for example a server administrator receiving a notification of a server crash. In contrast a user may assign a low priority to social Tweets or Facebook notifications. A message queue that merely aggregated different messages with different transports and data formats would hide the server crash notification in a mass of personal social networking notifications. Accordingly the user would be obliged to search his or her notifications manually on a periodic basis which obviates the advantage of receiving rather than polling for notifications.

The rules engine reads rules as input into the unified notification platform and populates the virtual queue with messages according to the rules . The rules engine comprises a rules reader a rules resolver and a rules interpreter .

The rules reader operates to read the input rules . The rules may be in the form of a text file a script or alternatively in a binary format. The rules reader will tokenize and parse the rules and will search for syntax errors. If no syntax errors are identified or if no rules can be extracted operation ceases. However if rules can be extracted from the input rules the extracted rules are then forwarded to the rules resolver .

Rules resolver operates to resolve contradictory rules. The rules engine may have multiple rules applied. The rules engine may apply heuristics to resolve contradictory rules. One example heuristic is to prioritize the most recently set rule. Another example heuristic is to prioritize create operations and deprioritize delete operations. The heuristics may be specified in a configuration file or alternatively may be hardcoded as defaults into the rules engine. Because the rules engine exposes its functionality via an API the resolution heuristics as well as other rules operations may be extended programmatically.

Upon resolving the extracted rules the rules are then interpreted by rules interpreter . Whenever a message enters one of the various message queues the message is scanned by the rules interpreter. Based on the rules the rules interpreter will extract the incoming message into the virtual queue.

The rules interpreter effects operations on the various message queues and the virtual queue via programmatic invocation of drivers . Each of the various message queue has its own respective driver . In addition to performing message specific processing the drivers provide entry points to perform linear data structure operations on the various message queues and the virtual queue .

These linear data structure operations act as functional primitives for the rules . The drivers may also support linear data structure operations on each queue respectively including but not limited to stack operations such as top push and pop queue operations such as top push and remove array operations such as indexed random access reorder search and sort. In particular reordering searching and sorting of messages and notifications within queues according to attributes and meta attributes may be supported.

In addition to performing data operations on queues the drivers may modify the queued messages or notifications themselves and or their attributes and meta attributes. For example where the rules engine identifies that message with a potential virus the rules engine may neutralize the message by setting an attribute marking the message as suspect and may disable embedded scripts and executables in the message while preserving text. Additionally the drivers may read messages and or attributes and meta attributes. For example the rules engine could perform caller id by displaying the sender identifier attribute as part of the notification. Since the rules engine has access to all queues and may both read and modify messages and their attributes and meta attributes the rules engine may mix and match data from different queues . For example the rules engine might compare messages from different queues and mark messages considered redundant.

For example if the rules interpreter has a rule to prioritize parents messages first the rules interpreter may determine whether the incoming message has a parent guardian flag meta attribute set. If the message entered into a message queue driver would provide a notification to the rules interpreter . The rules interpreter would then invoke the driver to extract the incoming message and delete it from the message queue . If the message had its parent guardian flag meta attribute set the rules interpreter might set the priority meta attribute to a high value and place the message in the virtual queue accordingly. Otherwise the rules interpreter might place the incoming message into the end of the virtual queue for ordinary processing.

The rules engine may periodically receive new rules have rules deactivated or deleted or have rules modified. Upon receipt the rules engine may update or refresh the various message specific queues and or the virtual queue according to the rules changes. As above the queue updates are effect via functional primitives exposed by the drivers .

As can be seen from the foregoing discourse rules are executed by the rules interpreter in terms of functional primitives exposed by drivers .

At any point the virtual queue may be accessed for viewing or other reporting. Viewing and reporting is performed by the software notification module . The software notification module is coupled to receiving input notifications from the system such as button presses and notifications from the rules engine and message queue component . The software display module is also coupled with the software display module to produce viewing and reporting user interfaces.

The software notification module may receive an indicator from the rules engine that a new message has been placed in the virtual queue . At that point the software notification modules can trigger the software display module to display a user interface such as the non modal notification pop up. The software notification module may also receive input from the user in the form of button presses to effect changes to the user interface displayed by the software display modules .

Alternatively the user may enter input for processing by the software notification module to invoke the message queue component and the software display module to activate views and reports such as the example message count reports described above.

Input need not come in the form of ordinary button presses which may also be handled by the client device s operating system but also in the form of remote invocations via an API.

Operation of the uniform notification platform user interface may be suppressed upon request. For example if the user deactivates the client device for sleep for device recharging or other reasons the user faces the potential of receiving a deluge of pending messages as indicated by the user interface. For these situations the user may trigger an alert suppression command. shows a flowchart of an example notification suppression operation.

At block the unified notification platform receives a suppression command. The suppression command could be via a hotkey or alternative from a configuration dialog displayed by the unified notification platform. A suppression command may be inferred programmatically as well. For example if the client device is locked or a user has not logged on the user interface may be suppressed.

Because suppression may be implemented as a directive to ignore notifications the directive may support logic to conditionally ignore notifications. Specifically the rules engine may apply conditions as to when notifications are ignored and when they are not. For example the user may apply a rule to ignore all notifications except those for work and with a date time stamp between 2 00 AM and 4 00 AM. In that way when the user turns off suppression the user may immediately receive those notifications as per the applied rule.

At blocks and the unified notification platform receives a first message and a second message. Although notifications are suppressed the operation of the message queue component and the rules engine is still in operation. It is only the user interface that is suppressed. Accordingly the messages are serialized or ordered and placed into the virtual queue as in ordinary operation.

At block the software notification module traps notifications from the message queue component and the rules engine that incoming messages have been received. Rather than invoking the software display module the software notification module simply discards the trapped notifications. In this way the user interface is suppressed.

In the meantime at block the unified notification platform awaits a predetermined event to reactivate the user interface. The predetermined event may be a reserved hotkey or alternatively a change to a user configuration dialog. The predetermined event may be part of another user action such as unlocking the client device or logging on.

In the event the predetermined event occurs at block the unified notification platform may refresh the user interface by updating the virtual queue and retrieving data from the virtual queue according to the rules engine .

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

