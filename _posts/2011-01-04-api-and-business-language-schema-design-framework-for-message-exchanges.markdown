---

title: API and business language schema design framework for message exchanges
abstract: A server system facilitates an exchange of messages with a remote client application. The server system includes a plurality of application servers hosting a plurality of applications. A plurality of Application Program Interfaces (APIs) provides programmatic access to the plurality of applications, each of the APIs being configured to receive request messages compiled by the remote client application. First and second request messages, respectively addressed to first and second APIs of the plurality of APIs by a remote client application, each comprise at least one common data component. Further, the first request message includes a first payload specific to the first API, and the second request message includes a payload specific to the second API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08352968&OS=08352968&RS=08352968
owner: eBay Inc.
number: 08352968
owner_city: San Jose
owner_country: US
publication_date: 20110104
---
This application is a continuation of U.S. application Ser. No. 12 771 981 filed Apr. 30 2010 entitled API and Business Language Schema Design Framework for Message Exchanges which is a continuation of U.S. application Ser. No. 10 997 767 filed Nov. 24 2004 entitled API and Business Language Schema Design Framework or Message Exchanges which claims the priority benefit of the filing date of U.S. Provisional Application No. 60 524 782 filed Nov. 24 2003 entitled Business Language Schema Design Framework for Message Exchanged in Trading Community which are incorporated herein in their entirety by reference.

The present application relates generally to the technical field of application program interfaces APIs and language schemas.

Buyers sellers and other business partners are increasingly utilizing electronic trading systems e.g. electronic marketplaces to collaborate and to do business with each other. Part of this collaboration may involve for example linking operational business processes. Business processes may be linked by the exchange of information in agreed sequences and within agreed timeframes between buyer and seller applications and affiliated third party business service providers.

To facilitate the above mentioned exchange of business information buyer and seller applications as well as applications of third party business service providers may expose Application Program Interfaces APIs which allow applications to make calls e.g. function calls to other applications to either request or send information. However as the number of buyers sellers and third party applications participating in the exchange of business information increases the technical challenge of enabling this multitude of applications to exchange information increases. For example the development of applications that are able to access APIs of a large number of other applications becomes increasingly burdensome and technically challenging.

According one aspect of the present invention there is provided a server system to facilitate an exchange of messages with a remote client application. The server system includes a plurality of application servers hosting a plurality of applications. A plurality of Application Program Interfaces APIs provides programmatic access to the plurality of applications each of the APIs being configured to receive request messages compiled by the remote client application. First and second request messages respectively addressed to first and second APIs of the plurality of APIs each comprise at least one common data component. Further the first request message includes a first payload specific to the first API and the second request message includes a payload specific to the second API.

A business language schema design framework for message exchanges in a trading system is described. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be evident however to one skilled in the art that the present invention may be practiced without these specific details.

An exemplary embodiment of the present invention is discussed below within the context of a network based commerce system that supports a network based electronic marketplace. Buyers and sellers utilizing buyer and seller applications as well as third party business service providers interact utilizing the electronic marketplace as a forum. Business processes may be driven by a wider range of electronic marketplace operational considerations so as to enable buyers and sellers to conduct transactions utilizing the electronic marketplace. In one embodiment of the present invention a buyer and seller communication model is proposed that identifies the requirements for message exchange sequences message exchange timings and the purpose of each message exchange.

In one embodiment message exchanges comply with a business language schema component model. The business language schema design framework enables an electronic marketplace server system e.g. the commerce system to support a wide range of commerce transactions including auction fixed price buying and selling product catalogs searches and payments. These transactions provide examples of communications between buying and selling applications via the electronic marketplace as well as communications with other third party business service providers.

In an exemplary embodiment there is provided a schema component model that provides an abstract definition of the business message payloads. Payloads may be defined in a way to support extensibility which enables other types of commerce transactions models to be made available via the marketplace e.g. for electronic procurement reverse auctioning credit check and shipment logistic activities .

The business language schema catalogs common business message components that may be utilized for any number of business communications facilitated by an electronic marketplace e.g. auction fixed price buying and selling product catalog search catalog based listings and electronic payment in support of item purchases . The business language schema in one embodiment enables a wide range of business applications to interoperate with XML web services APIs and externally located and internally hosted clients.

Request response message payload components are defined by the business language schema which may be utilized to enable the building of a range of messages that may flow back and forth from buyers sellers and third party business service providers to marketplace XML web services these web services enabling trading parties to list find and sell items and services.

In various exemplary embodiments message exchanges may be made utilizing the business language based message exchange model of an exemplary embodiment of the present invention with both external and internal business applications over synchronous communication and asynchronous communication links. Further document oriented synchronous messaging as well as document oriented asynchronous messaging may be supported. As will be described in further detail below a message packaging format may be a flavor of the XML messaging format e.g. SOAP 1.1 SOAP 1.2 ebXML or an e mail format such as MIME or any other arbitrary message packaging format . Further transport protocols used may include HTTP HTTPS SMTP or some other arbitrary transport protocol needed for particular business applications hosted remotely at a trading entity that requires moving data.

A schema design framework for a business language is accordingly provided in an exemplary embodiment of the present invention to support message payload definitions for a multitude of use cases and for use with a multitude of APIs. This may be accomplished via an extensibility model that includes base components and business message components that support new transaction models and messaging components. Specifically the base components provide a definition of basic core component types basic components and aggregate components including an abstract messaging framework. The business message components are based on the business information requirements for a particular use case.

Regarding the business messaging components based on the business information requirements of a particular use case the definitions of the basic set of messaging components are needed for a legacy transaction model can be supported utilizing the above mentioned base components in support of business message components. In one exemplary embodiment the business language components for use in an electronic trading environment such as that described below with respect to may include item item transaction shipping details payment address user buyer seller and transaction components.

It will be appreciated that over the course of time many new types of business processes may be employed by a trading community e.g. buyers sellers and third party service providers that utilize an electronic marketplace and accordingly that interface with services exposed by the electronic marketplace. Such new types of applications may exploit different types of transaction interfaces e.g. APIs exposed by an electronic marketplace. An exemplary embodiment of the present invention enables the reusability of certain components both at a messaging and an application level while providing for the extensibility to accommodate such new types of business processes and applications. Accordingly an exemplary embodiment of the present invention proposes an abstract message payload framework that can be extended for many different types of messages and over different protocols as may be required.

Accordingly in one embodiment the business language schema design framework of the present invention may be utilized to achieve reusability layering extensibility as well as ease of use and interoperability between a number of business processes and applications.

Further the exemplary business language schema design framework seeks to avoid XML Schema Definition XSD features that present interoperability issues e.g. WSDL and SOAP in processes deployed on client application runtimes. Further the exemplary framework seeks to take advantage of a wide a range of client run time environments and development tools e.g. ranging from public domain to commercially available software and to decrease the cost of maintenance to clients to easily interpret messages by exploiting underlying reusable base and aggregate business components as well as extensibility features. An embodiment of the present invention also seeks to import extend and or restrict schemas for a wide range of enumerated code types e.g. ISO currency and country codes to use name spaces that enable modularity of business message components and corresponding XML web services APIs that consume and produce the resulting messages and to satisfy the customization and extensibility needs of widely differing trading communities and transaction models. For example the business language schema design framework seeks to be reusable in consumer to consumer C2C business to consumer B2C and business to business B2B trading communities.

In order to facilitate a framework for standardizing business information semantics in a flexible and yet interoperable manner according to one embodiment there may be provided application specific message payload components that link back to a common set of core data components from which they are derived. Below are described core component concepts.

Core Component Type CCT a core component type is in one embodiment a low level construct that may have no meaning on its own. A core component type has a content component and additional components e.g. mandatory or optional which give it a specific meaning. An example of a core component type is an amount where the content part is a number e.g. 87 and another required part is a unit e.g. a Euro .

Basic core components a basic core component represents in the exemplary embodiment a core business concept e.g. a unique business semantic definition . This may be accomplished by employing a core component type CCT or a primitive data type e.g. XSD data types to which some other semantically unique object e.g. a weight element is an instance of the core component type CCT Measure Type .

Aggregate core components aggregate core components in one exemplary embodiment encapsulate two or more basic core components which represent higher level business concepts e.g. shipping address is an instance of Address Type . Each aggregate core component may have its own business semantic definition.

Having above provided a high level introduction amore detailed description of an exemplary trading system centered around a network based commerce system will now be described with reference to .

Turning specifically to the network based commerce system an Application Program Interface API server and a web server are coupled to and provide programmatic and web interfaces respectively to one or more application servers . Specifically the API server exposes multiple APIs to users of the commerce system . Each of these APIs supports one or more function calls to applications of the system .

The application servers host one or more marketplace applications and payment applications . The application servers are in turn shown to be coupled to one or more databases servers that facilitate access to one or more databases .

The marketplace applications provide a number of marketplace functions and services to users that access the commerce system . The payment applications likewise provide a number of payment services and functions to users. The payment applications may allow users to quantify for and accumulate value e.g. in a commercial currency such as the U.S. dollar or a proprietary currency such as points in accounts and then later to redeem the accumulated value for products e.g. goods or services that are made available via the marketplace applications . While the marketplace and payment applications and are shown in to both form part of the network based commerce system it will be appreciated that in alternative embodiments of the present invention the payment applications may form part of a payment service that is separate and distinct from the commerce system .

Further while the system shown in employs a client server architecture the present invention is of course not limited to such an architecture and could equally well find application in a distributed or peer to peer system. The various marketplace and payment applications and could also be implemented as standalone software programs which do not necessarily have networking capabilities.

The web client it will be appreciated accesses the various marketplace and payment applications and via the web interface supported by the web server . Similarly the programmatic client accesses the various services and functions provided by the marketplace and payment applications and via the programmatic interface provided by the API server . The programmatic client may for example be a seller application e.g. the TurboLister application developed by eBay Inc. of San Jose Calif. to enable sellers to author and manage listings on the commerce system in an off line manner and to perform batch mode communications between the programmatic client and the network based commerce system .

A number of fixed price applications support fixed price listing formats e.g. the traditional classified advertisement type listing or a catalogue listing and buyout type listings. Specifically buyout type listings e.g. including the Buy It Now BIN technology developed by eBay Inc. of San Jose Calif. may be offered in conjunction with an auction format listing and allow a buyer to purchase goods or services which are also being offered for sale via an auction for a fixed price that is typically higher than the starting price of the auction.

Store applications allow sellers to group their listings within a virtual store which may be branded and otherwise personalized by and for the sellers. Such a virtual store may also offer promotions incentives and features that are specific and personalized to a relevant seller.

Reputation applications allow parties that transact utilizing the network based commerce system to establish build and maintain reputations which may be made available and published to potential trading partners. Consider that where for example the network based commerce system supports person to person trading users may have no history or other reference information whereby the trustworthiness and credibility of potential trading partners may be assessed. The reputation applications allow a user for example through feedback provided by other transaction partners to establish a reputation within the network based commerce system over time. Other potential trading partners may then reference such a reputation for the purposes of assessing credibility and trustworthiness.

Personalization applications allow users of the commerce system to personalize various aspects of their interactions with the commerce system . For example a user may utilizing an appropriate personalization application create a personalized reference page at which information regarding transactions to which the user is or has been a party may be viewed. Further a personalization application may enable a user to personalize listings and other aspects of their interactions with the commerce system and other parties.

In one embodiment the network based commerce system may support a number of marketplaces that are customized for example for specific geographic regions. A version of the commerce system may be customized for the United Kingdom whereas another version of the commerce system may be customized for the United States. Each of these versions may operate as an independent marketplace or may be customized or internationalized presentations of a common underlying marketplace.

Navigation of the network based commerce system may be facilitated by one or more navigation applications . For example a search application enables key word searches of listings published via the commerce system . A browse application allows users to browse various category catalogue or inventory data structures according to which listings may be classified within the commerce system . Various other navigation applications may be provided to supplement the search and browsing applications.

In order to make listings available via the network based commerce system as visually informing and attractive as possible the marketplace applications may include one or more imaging applications utilizing which users may upload images for inclusion within listings. An imaging application also operates to incorporate images within viewed listings. The imaging applications may also support one or more promotional features such as image galleries that are presented to potential buyers. For example sellers may pay an additional fee to have an image included within a gallery of images for promoted items.

Listing creation applications allow setters conveniently to author listings pertaining to goods or services that they wish to transact via the commerce system and listing management applications allow setters to manage such listings. Specifically where a particular seller has authored and or published a large number of listings the management of such listings may present a challenge. The listing management applications provide a number of features e.g. auto relisting inventory level monitors etc. to assist the seller in managing such listings. One or more post listing management applications also assist sellers with a number of activities that typically occur post listing. For example upon completion of an auction facilitated by one or more auction applications a seller may wish to leave feedback regarding a particular buyer. To this end a post listing management application may provide an interface to one or more reputation applications so as to allow the seller conveniently to provide feedback regarding multiple buyers to the reputation applications .

Dispute resolution applications provide mechanisms whereby disputes arising between transacting parties may be resolved. For example the dispute resolution applications may provide guided procedures whereby the parties are guided through a number of steps in an attempt to settle a dispute. In the event that the dispute cannot be settled via the guided procedures the dispute may be escalated to a third party mediator or arbitrator.

A number of fraud prevention applications implement various fraud detection and prevention mechanisms to reduce the occurrence of fraud within the commerce system .

Messaging applications are responsible for the generation and delivery of messages to users of the network based commerce system such messages for example advising users regarding the status of listings at the commerce system e.g. providing outbid notices to bidders during an auction process or to provide promotional and merchandising information to users .

Merchandising applications support various merchandising functions that are made available to sellers to enable sellers to increase sales via the commerce system . The merchandising applications also operate the various merchandising features that may be invoked by sellers and may monitor and track the success of merchandising strategies employed by sellers.

The network based commerce system itself or one or more parties that transact via the commerce system may operate loyalty programs that are supported by one or more loyalty promotions applications . For example a buyer may earn loyalty or promotions points for each transaction established and or concluded with a particular seller and be offered a reward for which accumulated loyalty points can be redeemed 

The tables also include an items table in which are maintained item records for goods and services that are available to be or have been transacted via the commerce system . Each item record within the items table may furthermore be linked to one or more user records within the user table so as to associate a seller and one or more actual or potential buyers with each item record.

A transaction table contains a record for each transaction e.g. a purchase transaction pertaining to items for which records exist within the items table .

An order table is populated with order records each order record being associated with an order. Each order in turn may be with respect to one or more transactions for which records exist within the transactions table .

Bid records within a bids table each relate to a bid received at the network based commerce system in connection with an auction format listing supported by an auction application . A feedback table is utilized by one or more reputation applications in one exemplary embodiment to construct and maintain reputation information concerning users. A history table maintains a history of transactions to which a user has been a party. One or more attributes tables record attribute information pertaining to items for which records exist within the items table . Considering only a single example of such an attribute the attributes tables may indicate a currency attribute associated with a particular item the currency attribute identifying the currency of a price for the relevant item as specified in by a seller.

Having above described an exemplary trading environment within which an exemplary embodiment of the present invention maybe deployed further details regarding a business language schema design framework according to an exemplary embodiment of the present invention for message exchanges e.g. within the trading environment are now described. is block diagram illustrating a client server architecture that may be deployed for example as part of the trading environment described above with reference to . Referring specifically to abstract request response messages are sent between one of N third party systems such as third party system and a server system that is accessed via a number of APIs exposed by respective API servers

Thus in broad terms the third party system using the client application compiles a request message which is directed to an API e.g. AddItem GetItemTransaction etc. of the server system . Each API in turn provides access through supported function calls to one of a plurality of applications indicated generally by arrow that have access to a database .

Turning now to further details regarding the exemplary client application hosted on a third party system are shown. The client application includes an abstract request response message process component for processing the request response messages shown in . In particular the abstract request response message process component comprises an Error Processor and a Version Processor . The client application further comprises an API specific component that includes XML schema definitions for the various API s with which the client application is configured to communicate e.g. API  and API  shown in . A number of possible front end transport technologies such as SOAP MIME and HTTP are shown to be supported by a transport handler .

The client application also includes a message handler and a serialization deserialization handler in addition to the API specific component . Specifically each third party system may host a client application which can exploit the abstract request response message via any one of the following processing components 

ii A message handler which supports the message envelope processing capabilities e.g. HTTP POST Raw Data stream SOAP MIME etc. 

The transport handler and the message handler can be formed from any standard commercially available Software Development Kit SDK to which a third party has access in its development and runtime deployment environments.

The abstract request serialization and response deserialization handler can be developed for client applications once and reused multiple times thus reducing the cost of interfacing and also providing consistent interfacing with API based application services exposed by the commerce system over a wide range of transport and messaging particles. Such a write once and use multiple times deployment is useful for trading communities regardless of use case and other infrastructure components in support of transport security and messaging protocols.

Turning now to at the server side an exemplary API Server comprises a front end Presentation tier which receives request messages and sends response messages a Business tier and a Data components tier . The Business tier includes components corresponding to the various APIs indicated generally by arrow . The benefits on the server side in terms of creating response payloads is that as for request payloads basic response components are compilable using reusable components

The structure of exemplary abstract request and response messages wilt now be described in detail with reference to . Referring first to the abstract request message an exemplary abstract request message comprises a Detail Level component and an associated DetailCodeType . This advantageously allows the client application to request a required level of detail within a listing for example relating to a particular item listed on the commerce system . The level of detail requested may range from a most detailed to a least detailed level. The abstract request message further comprises an Error Language component and an associated Language Identification Tag and a Version ID component and an associated Version Identifier . The abstract request message is then completed by providing a Request Payload component for carrying any type of XML data .

An exemplary abstract response message includes a Time Stamp component and an associated DateTime and an Acknowledgement component and an associated AckCodeType . These components are used to acknowledge receipt of a request message of the received from a client application .

The abstract response message further includes a Correlation ID component and associated String Identifier an Error s Data component and associated data a Version ID a Build component and a Response Payload component for receiving any type of XML data .

The Correlation ID component and associated String identifier allow the abstract response message to be correlated with a particular incoming request message and to indicate this correlation to the requesting client application .

Thus there is some commonality in the abstract request and abstract response messages and namely they both can carry any type of data and both include version information.

The Error Language component and the Error Data s component ensure that the API request response messages consistently use manage and communicate error components. Part of this is the ability to communicate versioning information identifying what version of an API a particular API server is using to communicate with a client application of a third party system e.g. a client and . Thus for example if a third party system sends a request message that includes incorrect data or that does not comply with the published requirements of a target API the Error Data s component is used by the target API to communicate information regarding the error back to the client application . Thus when an error is detected a response message is generated by the relevant API this response message being either a long message or a short message and including an error code and associated severity code. This response message is sent to the relevant client application thereby informing the client application as to the nature of the error.

Regarding the version of the API that the API server is using versioning information is included in both a request message from a client application to the API server as well as a response message from the API server back to the client application . This is indicated schematically by blocks and in . Thus the respective version components in the request and response messages indicate a particular version of the API on the API server . In so doing and in view of the fact that the API version used by the API server typically changes the client application will have a way of detecting when it needs to upgrade the schema that it uses to format and generate request messages to the relevant.

An embodiment of the present invention facilitates extension of the behavior of the APIs in terms of the request and response message structures. In other words the abstract request and response models can be extended to enable API requests and responses between a third party system and any number of APIs provided by one or more API servers . For example a particular server system may expose a number of APIs each conforming to the basic request response messages described above. Thus for example the basic request response messages can be extended to enable an AddItem API or a GetItem API or a GetAccount API. Thus for example for a third party system wishing to exchange item information with the commerce system the basic abstract request message may be extended with the addition of information conforming to a schema understood by a GetItem API.

In other words this arrangement allows a third party system hosting an appropriately configured client application to communicate with multiple APIs with a degree of uniformity and predictability. In one embodiment a uniform data processing model is utilized and supported by a number of APIs thereby allowing developers of client applications to reuse parts of their code.

The abstract request and response data processing component of a client application allows a client application developer to create and modify a client application to communicate with multiple APIs using a common portion of code. The abstract request and response data processing framework can be reused by a client application for a number of APIs exposed by the commerce system for example.

Dealing more specifically with the re usability of the business language schema data components in a specific exemplary deployment environment of a trading environment such as that illustrated in schema components may be defined such that they can be reused for multiple cases of purchasing and selling items listed via the network based commerce system . Examples of such reuse are provided below 

1 Listing an item utilizing an AddItem API a client application may be configured to list an item to be sold in specific regions of the world and to recognize acceptable payment and shipment options for purchasing and shipping items in such a specific region. 2 Revising and relisting an item utilizing ReviseItem and RelistItem APIs a client application may be configured to enable the revision and relisting of existing items such that the item properties are revised or a completely new listing for the item is created should the item not previously have been sold. 3 Getting information about an item utilizing GetItem GetSellerList or GetBidderList APIs a client application may be configured to retrieve information about a particular item or multiple items that are actively listed via the network based commerce system .

In all of the above use cases the client application is required to send information back to a network based commerce system regarding items listed for sale via the commerce system . This may require description of an structure in a consistent manner such that the client applications from which the API calls originate understand the semantics of an item listed by a seller on the e commerce system . However since the context of each call from a client application is different in each use case scenario a different degree of information needs to be provided such that some data components are included or excluded.

Utilizing the item listing use case scenario described above the issues described above can be addressed utilizing 1 an data component model and 2 multiple data validation levels.

Turning first to the data component model in terms of this model an item has required optional data components. These components internally also have child components that are required and optional components.

Accordingly a single item component definition may be used for multiple API use cases with the developers and designers of the APIs being able to select which elements of the item component must be present and which elements of an item component do not need to be present.

Turning now to the multiple data validation levels when a client application sends an API request message payload an API processing payload may in one embodiment include the following sequence of validations 

 a Schema Level Data Validation the API request message payload is validated with respect to an underlying schema specific to the API message payload e.g. utilizing the XML schema definition for the item data component .

 b API Specific Syntactic Data validation This involves additional data level validation to ensure that the client application has sent required data elements that are specified in the XML schema definition to the option elements but that are defined as required elements by the relevant API. c Business Application Data Validation This validation involves checking for a wide range of business application level validations.

The above sequence of validations it will be noted utilizes a single definition of key business data components such that data variability in request response messages can be supported in a controlled manner using the required validation logic for the business use case. For example for the following the three exemplary APIs GetItem GetItem Transaction and SellerList the same definition of an business definition component can be used on the client side yet the APIs will return response messages with varying API data structures. This enables uniformity in a semantic definition yet allows the return of different views of the business component according to use case. Examples of response are provided in the attached Computer Program Listing Appendix.

Accordingly a server system e.g. a network based commerce system that exposes multiple business application services can utilize these multiple exposed business applications in communicating with multiple client applications in a way that the client applications can understand and communicate. For example information about an item with varying syntactic characteristics that correspond to an item is communicated e.g. information about an item with varying syntactic characteristics that correspond to a data item component with a common semantic definition . The above contributes to the reusability of data components within for example a trading community with multiple use cases.

To develop a client application that communicates with multiple APIs or to modify an existing client application to talk to multiple APIs a developer downloads or imports XML schema definitions for each of the multiple APIs. For example for an exemplary GetTransactionDetail API the developer will need to import or download the corresponding schema for this API and in particular the GetTransactionDetail request message as well as the GetTransactionDetail response message. Thereafter the client application will need to integrate these schema processing components with their own e.g. as part of the API specific component .

The above described business language schema design framework is able to cater for messages being compiled in different data formats ranging from a raw ACP format to SOAP to MIME to HTTP. Thus for example the same message data format can be used to transfer a request payload from a client application to the server yet with the response payload being sent from the server to the client application in a different message format. From the point of view of the client application a common data processing mechanism may be utilized. In other words the request payload and response payload are transport and message data format independent.

With reference to in exemplary use case scenarios the abstract request response message may be extended to an item listing use case and a payment application use case . For the item listing use case an abstract message may be extended to be an Add Item Request Response message or a Get Item Transaction Request Response message . For the payment application use case the abstract message may be extended to be a Refund Transaction Request Response or a Get Item Transaction Request Response merely for example.

The request response message exchange between the client application and the API server will now be described with reference to . On the client application side of the message exchange the operations involved in the content occasion compiling a request message are as follows 

determining the abstract request message payload data comprising for example the required level of detail and the version of the XML schema definition for a specific API e.g. API  being used by the client application indicated by block 

invoking an API specific component and identifying the API specific XML schema definitions indicated by block 

creating the API specific portion of the message from data using the API specific component indicated by block 

transmitting the wrapped extended request message via a network to the API server indicated by block .

At the API server the operations involved in compiling a response message for the client application can be summarized as follows 

generating a time stamp acknowledgement correlation ID error and version data and including this data into the abstract portion of the response messages indicated by block 

identifying the appropriate response data and including this in the extended portion of the response message indicated by block 

transmitting the wrapped extended response message via a network to the client application indicated by block .

An embodiment of the present invention further utilizes enumerated code types. This feature is described with reference to an example such as the ListingDuration code type. Enumerated code types can be used for information components that may have a fixed set of values. For example ListingDuration code type identifies how long an item may be listed on the commerce system . There are typically three different values that ListingDuration code type may assume namely 7 10 or 14 days. These can be enumerate in some constant data structure e.g. weeks so that for example a duration of 14 days can be formalized with the number 2 . Accordingly any ListingDuration code type can only correspond to 7 or 14 days. If the ListingDuration code type is attributed a value of 21 or 15 then such a value would violate the relevant XML schema definition.

According to one embodiment of the present invention as and provides a forced element when encountering a value that violates an XML schema definition. Thus a default value is provided as the enumerated code type can change over a period of time. Thus in one month an original XML schema definition may define 7 10 14 and 21 day duration values but the next month the updated up XML schema definition may be updated to remove the duration value of 21 days. Thus when a client application utilizing the original XML schema attempt to provide a 21 day duration value against an updated API this will be registered as a violation. To address this the updated API will insert a default value which can carry any value into the response payload of a response message provided by the updated API and to the according client application .

Thus an indication of a 21 day duration value duration value against the updated API of the commerce system will be accepted but as the updated API will issue a warning to the relevant client application that it needs to upgrade the relevant XML schema. In use the default value is only inserted by the API server into the response message when the server detects that the client is using an outdated version of the schema.

The method commences at block with the client application including its version identifier e.g. version ID identifying the version of an XML schema definition stored by the client application within a request message addressed to a particular target API. An example of the version identifier is provided below 

At block an API of the server system receives the request message from the client application and determines from the version identifier that the client application is utilizing a different and older version of an API schema supported by the relevant target API .

At block the targeted API composes a response message including a response payload and includes within the payload instances of specific enumerated code types for an element e.g. CustomCode . This indicates that the API has defined new additional enumerated codes that may not be understood and correctly processed by the client application in view of its updated XML schema definition for the targeted API. The CustomCode element being returned in such scenarios will prevent the client application from experiencing a communication breakdown with the API due to incremental schema changes and evolutions that may occur as part of the commerce system for example revising API based application service offerings.

API client has up to date version of API schema to communicate with XML Web Service APIs e.g. GetUser API. Hence the server system XML Web Service API returns the up to date enumeration code value China for the enumerated code element.

API client has up to date version of API schema as specified in sub element in GetUserRequest message below to communicate with XML Web Service APIs GetUser API. Hence XML Web Service API returns in response message 

The exemplary computer system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT . The computer system also includes an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse a disk drive unit a signal generation device e.g. a speaker and a network interface device .

The disk drive unit includes a machine readable medium on which is stored one or more sets of instructions e.g. software embodying any one or more of the methodologies or functions described herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable media.

The software may further be transmitted or received over a network via the network interface device .

While the machine readable medium is shown in an exemplary embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical media and magnetic media.

Although the present invention has been described with reference to specific exemplary embodiments it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the invention. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

