---

title: Systems and methods for adaptive copy on write
abstract: In one embodiment, a user or client device communicates with a distributed file system comprised of one or more physical nodes. The data on each of the physical nodes store metadata about files and directories within the file system. Some of the embodiments permit a user to take a snapshot of data stored on the file system. The snapshot may include a single file, a single directory, a plurality of files within a directory, a plurality of directories, a path on the file system that includes nested files and subdirectories, or more than one path on the file system that each includes nested files and directories. In some embodiments, systems and methods intelligently choose whether to use copy-on-write or point-in-time copy when saving data in a snapshot version of a file whose current version is being overwritten. In some embodiments, systems and methods allow snapshot users to return from a snapshot directory to the immediate parent directory from which the user entered into the snapshot.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08200632&OS=08200632&RS=08200632
owner: EMC Corporation
number: 08200632
owner_city: Hopkinton
owner_country: US
publication_date: 20110114
---
This application is a continuation of and claims benefit of priority to U.S. application Ser. No. 11 894 756 filed Aug. 21 2007 now U.S. Pat. No. 7 882 068 entitled SYSTEMS AND METHODS FOR ADAPTIVE COPY ON WRITE which is hereby incorporated by reference in its entirety herein and which was filed on the same day as the following U.S. applications application Ser. No. 11 894 739 entitled SYSTEMS AND METHODS FOR PORTALS INTO SNAPSHOT DATA and application Ser. No. 11 894 697 entitled SYSTEMS AND METHODS FOR READING OBJECTS IN A FILE SYSTEM both of which are hereby incorporated by reference in their entirety herein.

A portion of the disclosure of this patent document includes material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyrights whatsoever.

This invention relates generally to a computer system and more specifically to taking snapshots of data in a computer system.

The amount of data stored on digital computing systems has increased dramatically in recent years. Accordingly users have become increasingly reliant on the storage devices of these systems to store this data. Typically the data stored on the storage devices undergo modifications. These modifications may arise from user intervention periodic system updates or alterations computer initiated processes or some other source. Whatever the source of the modifications it is often useful to preserve and permit access to previous versions of the data such as for example files and directories. Some instances of when access to previous versions may be useful include but are not limited to inadvertently deleted or overwritten data providing external access to older versions of data while newer versions are being updated and determining changes to storage device usage over time.

One response to preserving older versions of files has been to copy the entire contents of the storage device to a backup or second storage device. A digital computing system employing this technique will often encounter numerous problems. One copying entire data systems is time consuming and delays write requests to data on the storage device. Second this type of backup is financially expensive because it often requires the purchase of additional storage space. Finally this option does not permit system flexibility. Backups of portions of the file system can reduce the time and expense encountered with traditional methods.

Moreover the aforementioned problems are amplified when modern large capacity storage devices and distributed storage systems comprising numerous large capacity storage devices are considered.

Because of the foregoing challenges and limitations there is a need to provide a more efficient manner in which to provide snapshots of data in a system.

In one embodiment a method of determining whether to use Copy On Write COW or Point In Time Copy PITC for storing multiple versions of at least a portion of a file is provided. The method may include receiving a request to modify a portion of a file determining whether to perform a Point In Time Copy operation if it is determined to perform a Point In Time Copy performing a Point In Time Copy operation on the portion of the file and if it is determined not to perform a Point In Time Copy performing a Copy On Write operation on the portion of the file.

In another embodiment a computer readable medium is provided having instructions stored thereon for determining when the instructions are executed whether to use Copy On Write COW or Point In Time Copy PITC for storing multiple versions of at least a portion of a file. The instructions may include receiving a request to modify a portion of a file determining whether to perform a Point In Time Copy operation if it is determined to perform a Point In Time Copy performing a Point In Time Copy operation on the portion of the file and if it is determined not to perform a Point In Time Copy performing a Copy On Write operation on the portion of the file.

In another embodiment a storage module is provided having instructions stored thereon for determining when the instructions are executed whether to use Copy On Write COW or Point In Time Copy PITC for storing multiple versions of at least a portion of a file. The storage module may include a computer readable medium having instructions stored thereon a processor capable of executing the instructions and a memory system for storing a copy of at least a portion of a file according to the instructions executed on the processor wherein the instructions may include receiving a request to modify a portion of a file determining whether to perform a Point In Time Copy operation if it is determined to perform a Point In Time Copy performing a Point In Time Copy operation on the portion of the file and if it is determined not to perform a Point In Time Copy performing a Copy On Write operation on the portion of the file.

In another embodiment a method is provided of ascending a file system capable of distinguishing based on relative depth between multiple unique paths to the same directory. The method may include receiving a request to ascend from a child directory to an expected parent directory the expected parent directory being one of multiple possible parent directories determining the expected parent directory by evaluating in part a relative depth value of the child directory and ascending to the expected parent directory.

In another embodiment a system is provided of ascending a file system by distinguishing based on relative depth between multiple unique paths to the same directory. The system may include a processor a memory system coupled to the processor the memory system storing a file system and a navigation module comprising instructions executable by the processor to operate on the file system the instructions comprising receiving a request to ascend from a child directory to an expected parent directory the expected parent directory being one of multiple possible parent directories determining the expected parent directory by evaluating in part a relative depth value of the child directory and ascending to the expected parent directory.

For purposes of this summary certain aspects advantages and novel features of the invention are described herein. It is to be understood that not necessarily all such advantages may be achieved in accordance with any particular embodiment of the invention. Thus for example those skilled in the art will recognize that the invention may be embodied or carried out in a manner that achieves one advantage or group of advantages as taught herein without necessarily achieving other advantages as may be taught or suggested herein.

Systems methods processes and data structures which represent one embodiment of an example application of the invention will now be described with reference to the drawings. Variations to the systems methods processes and data structures which represent other embodiments will also be described.

For purposes of illustration some embodiments will be described in the context of a distributed file system. Embodiments of a distributed file system suitable for accommodating embodiments of snapshots disclosed herein are disclosed in U.S. patent application Ser. No. 10 007 003 titled SYSTEMS AND METHODS FOR PROVIDING A DISTRIBUTED FILE SYSTEM UTILIZING METADATA TO TRACK INFORMATION ABOUT DATA STORED THROUGHOUT THE SYSTEM filed Nov. 9 2001 which claims priority to Application No. 60 309 803 filed Aug. 3 2001 U.S. patent application Ser. No. 10 281 467 entitled SYSTEMS AND METHODS FOR PROVIDING A DISTRIBUTED FILE SYSTEM INCORPORATING A VIRTUAL HOT SPARE filed Oct. 25 2002 and U.S. patent application Ser. No. 10 714 326 entitled SYSTEMS AND METHODS FOR RESTRIPING FILES IN A DISTRIBUTED FILE SYSTEM filed Nov. 14 2003 which claims priority to Application No. 60 426 464 filed Nov. 14 2002 all of which are hereby incorporated by reference herein in their entirety.

For purposes of illustration some embodiments will also be described with reference to updating data structures in a file system using information stored in related data structures of the file system. Embodiments of a file system capable of updating data structures with information stored in related data structures of a file system are disclosed in U.S. patent application Ser. No. 11 255 337 titled SYSTEMS AND METHODS FOR ACCESSING AND UPDATING DISTRIBUTED DATA and is hereby incorporated by reference in its entirety.

In one embodiment of a distributed file system metadata structures also referred to as inodes are used to monitor and manipulate the files and directories within the system. An inode is a data structure that describes a file or directory and may be stored in a variety of locations including on disk and or in memory. The inode in memory may include a copy of the on disk data plus additional data used by the system including fields associated with the data structure.

As used herein a file is a collection of data stored in one unit under a filename. A directory similar to a file is a collection of data stored in one unit under a directory name. A directory however is a specialized collection of data regarding elements in a file system. In one embodiment a file system is organized in a tree like structure. Directories are organized like the branches of trees. Directories may begin with a root directory and or may include other branching directories. Files resemble the leaves or the fruit of the tree. Files typically do not include other elements in the file system such as files and directories. In other words files do not typically branch. Although in the illustrated embodiment an inode represents either a file or a directory in other embodiments an inode may include metadata for other elements in a distributed file system in other distributed systems in other file systems or other systems.

As used herein data structures are collections of associated data elements such as a group or set of variables or parameters. In one embodiment a structure may be implemented as a C language struct. One skilled in the art will appreciate that many suitable data structures may be used.

Some of the figures and descriptions relate to an embodiment of the invention wherein the environment is that of a distributed file system. The present invention is not limited by the type of environment in which the systems methods processes and data structures are used. The systems methods structures and processes may be used in other environments such as for example other file systems other distributed systems the Internet the World Wide Web a private network for a hospital a broadcast network for a government agency an internal network of a corporate enterprise an intranet a local area network a wide area network a wired network a wireless network and so forth. It is also recognized that in other embodiments the systems methods structures and processes may be implemented as a single module and or implemented in conjunction with a variety of other modules and the like.

In one embodiment a user or client device is connected to a distributed file system comprised of one or more physical nodes for example storage devices . The data on each of the physical nodes are arranged according to inodes which store metadata about files and directories within the file system. In particular each inode points to locations on a physical disk that store the data associated with a file or directory.

Some of the embodiments disclosed herein permit a user to take a snapshot of data stored on the file system. The snapshot may include a single file a single directory a plurality of files within a directory a plurality of directories a path on the file system that includes nested files and subdirectories or more than one path on the file system that each includes nested files and directories.

A path to a file or directory specified to create a snapshot will be referred to herein as the root of the snapshot. For example the command snap create ifs data dir creates a snapshot of directory dir and the files and directories nested within dir. Accordingly dir is the root of the snapshot. In one embodiment if the root of the snapshot is a file then the snapshot is of the file only. Thus the file is governed by the snapshot. If the root of the snapshot is a directory then the root of the snapshot and all files and directories nested within the root of the snapshot as well as their descendents are governed by the snapshot. Accordingly in some embodiments more than one snapshot may govern a particular file or directory.

Additionally the most current version of data on the file system will be referred to as the current version HEAD version or active version whereas previous versions will be referred to as snapshot data the snapshot version or past versions. In one embodiment if the current version of a file or a directory has been deleted from the system it is possible for a file or directory to have snapshot versions but not have a current version.

In one embodiment when a snapshot is created it is created in constant time. That is no copying of data is required. Instead a snapshot is created by creating a snapshot tracking data structure associated with the new snapshot a mini snapshot s if applicable and an indication in the governance list field of the metadata structure associated with the root of the snapshot. A snapshot is said to be created in constant time because substantially little time is required to create the snapshot. Accordingly snapshot creation does not substantially interfere with read requests to files and directories governed by the snapshot. This feature and other features of the embodiments disclosed herein will be described in more detail below.

In a distributed file system comprises various physical nodes that communicate over a communication medium . In one embodiment the communication medium is the World Wide Web. In other embodiments as described above the distributed file system may be comprised of one or more hard wired connections between the physical nodes or any combination of communication types known to one with ordinary skill in the art.

In the depicted embodiment the physical nodes are either interfaces such as a personal computer a mainframe terminal or a client application or data storage systems . It will be appreciated by one with ordinary skill in the art that the distributed file system may comprise one or a plurality of interfaces and one or a plurality of data storage systems. In one embodiment the interfaces may comprise data storage systems such as for example data storage systems and .

In one embodiment the snapshot module is capable of executing the processes and methods described herein. The word module refers to logic embodied in hardware or firmware or to a collection of software instructions possibly having entry and exit points written in a programming language such as for example C or C . A software module may be compiled and linked into an executable program installed in a dynamically linked library or may be written in an interpreted programming language such as for example BASIC Perl or Python. It will be appreciated that software modules may be callable from other modules or from themselves and or may be invoked in response to detected events or interrupts. Software instructions may be embedded in firmware such as an EPROM. It will be further appreciated that hardware modules may be comprised of connected logic units such as gates and flip flops and or may be comprised of programmable units such as programmable gate arrays or processors. The modules described herein are preferably implemented as software modules but may be represented in hardware or firmware. Moreover although in some embodiments a module may be separately compiled in other embodiments a module may represent a subset of instructions of a separately compiled program and may not have an interface available to other logical program units.

In one embodiment the processor receives and processes requests to create snapshots to delete snapshots to read snapshot data to modify data governed by a snapshot and or other snapshot related processes. In other embodiments the processor executes some or all of the processes and or methods described herein. In yet other embodiments the processor calls the snapshot module to execute snapshot related processes.

In one embodiment the storage device stores files and directories of the file system and the inode metadata associated with the files and directories. Examples of the arrangements of files and directories stored on the storage device can be found in . In some embodiments the storage device may be a physical disk. In other embodiments the storage device may comprise a plurality of physical disks in communication with one another and or the bus. In yet other embodiments the storage device may include a magnetic storage medium an optical disk a random access memory a hard drive and a partitioned portion of a hard drive.

The data storage system may run on a variety of computer systems such as for example a computer a server a smart storage unit and so forth. In one embodiment the computer may be a general purpose computer using one or more microprocessors such as for example an Intel Pentium processor an Intel Pentium II processor an Intel Pentium Pro processor an Intel Pentium IV processor an Intel Pentium D processor an Intel Core processor an xx86 processor an 8051 processor a MIPS processor a Power PC processor a SPARC processor an Alpha processor and so forth. The computer may run a variety of operating systems that perform standard operating system functions such as for example opening reading writing and closing a file. It is recognized that other operating systems may be used such as for example Microsoft Windows 3.X Microsoft Windows 98 Microsoft Windows 2000 Microsoft Windows NT Microsoft Windows CE Microsoft Windows ME Microsoft Windows XP Palm Pilot OS Apple MacOS Disk Operating System DOS UNIX IRIX Solaris SunOS FreeBSD Linux or IBM OS 2 operating systems.

As depicted the root of the file system is ifs . From here files and directories branch outward each with a corresponding inode. In one embodiment inodes that correspond to directories may have one or more child inodes and possibly even one or more grandchild great grandchild inodes and or other descendents. In another embodiment inodes that correspond to files do not have any child inodes. For example inode four corresponds to the directory data and has child inodes one hundred five thousand and nine thousand. The grandchild inodes of inode four include inodes one hundred one one hundred two five thousand one and five thousand two the great grandchild inodes of inode four include inodes five thousand three and five thousand four. In other embodiments inodes corresponding to files may have child inodes grandchild inodes and so forth.

The dashed lines in correspond to snapshots of the file system . In one embodiment each of the snapshots has a snapshot identifier snapshot ID . In one embodiment the snapshot ID provides an indication as to the relative time the snapshot was created. For example if the snapshot ID of snapshot A is greater than the snapshot ID of snapshot B it is understood that snapshot A was created after snapshot B. In one embodiment the snapshot ID is assigned to snapshots based on a monotonically increasing global snapshot counter global count . In other embodiments the snapshot ID may be randomly assigned or otherwise be unrelated to the relative time the snapshot was created.

In snapshot one has snapshot ID . The root of snapshot one is data and is represented by the path ifs data . Thus directory data is the root of snapshot one . Accordingly data and all of the files and directories nested within data are governed by snapshot one .

Snapshot two has snapshot ID . The root of snapshot two is represented by the path ifs data dir. Thus directory dir is the root of the snapshot two . Accordingly dir and all of the files and directories nested within dir are governed by snapshot two . Additionally because dir is also governed by snapshot one dir and all of the nested files and directories under dir are governed by both snapshot one and snapshot two .

Snapshot three has snapshot ID . The root of snapshot three is represented by the path ifs data dir dir file . Thus file is the root of snapshot three . Because no files or directories are nested within file file is the only file or directory governed by snapshot three . However file is also governed by snapshot one because it is a file nested within data which is governed by snapshot one .

In the depicted embodiment current versions of the files and directories within the file system are represented using rectangles for example data . Virtual directories that provide access to snapshot data are represented using double rectangles for example .snapshot . Files and directories associated with snapshot one are represented using ovals for example data files and directories associated with snapshot two are represented using triangles for example data and files and directories associated with snapshot three are represented using trapezoids for example data . In one embodiment the snapshot versions of files and directories on a file system are virtual files and directories.

As shown in the top level .snapshot directory is a subdirectory of the root of the file system ifs. The top level .snapshot directory includes subdirectories for each of the three snapshots snap for snapshot one snap for snapshot two and snap for snapshot . Using an operating system compatible change directory command for example cd for UNIX a user can access the snapshot data for snapshot one using the path ifs .snapshot snap . Once at this path the file system will appear as the file system at the time snapshot one was created. For example file from snapshot one can be accessed using the path ifs .snapshot snap data dir dir file .

The ifs .snapshot snap subdirectory is similar in many respects to the snap subdirectory . The file system appears as it did at the time of snapshot two was created. However because snapshot two governs only dir and the files nested within it the parent directory to dir data includes enough information to access the snapshot version of dir . As used herein ancestor directories that are not governed by a snapshot but include children files or directories to navigate to snapshot data are referred to as mini snapshots. For example though the current version of data has as its children file dir and dir the mini snapshot of data for snapshot two has its only child dir .

Mini snapshots serve as stand ins for the portions of the directory tree between the file system root and the root of a snapshot. Consequently snapshot data can be accessed in an intuitive way without being computationally expensive.

For example the .snapshot snap directory utilizes three mini snapshot directories data dir and dir to provide access to the snapshot version of file governed by snapshot three . Accordingly each of the mini snapshot directories do not store information unrelated to accessing file data does not store information related to file or dir dir does not store information related to file and dir does not store information related to file.

The embodiment depicted in also shows how snapshot data can be accessed via .snapshot subdirectories nested within the file system hierarchy . Each directory that includes or in some instances formerly included data with a snapshot version also has a .snapshot subdirectory. These .snapshot subdirectories are similar to the .snapshot subdirectory of ifs in that they preserve the intuitive feel of the file system when accessing snapshot versions. Accordingly the .snapshot subdirectories also utilize mini snapshots.

One example of a nested .snapshot subdirectory can be found within data . The .snapshot subdirectory includes three subdirectories snap snap and snap . Because data is the root of snapshot one the subdirectories and files located within snap appear as the subdirectories and files of data at the time that snapshot one was created.

Similarly dir includes a .snapshot subdirectory that includes snapshot data related to snapshot one snap and snapshot three snap . The data within snap can be accessed as if ifs data dir was accessed at the time that snapshot one was taken. However the data within snap is limited to only file because snapshot three only governs file . Accordingly dir and dir are mini snapshots that provide access to file .

The .snapshot subdirectory found within dir also includes data associated with snapshot one and snapshot three . Subdirectory snap includes the snapshot versions of file and file . In contrast subdirectory snap only includes the snapshot version of file because file is the root of snapshot three .

Subdirectory dir also includes a .snapshot subdirectory . Nested within .snapshot are subdirectories snap and snap . Each of snap and snap include versions of file and file that correspond to the versions of file and file at the times that snapshot one and snapshot two were created.

In one embodiment the .snapshot subdirectories are virtual directories that are not explicitly represented on disk. Information necessary to create the snapshot data found in each virtual directory can be found by consulting the inode of the parent of the virtual directory and the snapshot tracking data structures associated with each snapshot version of the files and or directories nested within the parent. The virtual directory can be created by a determining which snapshots govern each of the files and directories and b accessing the data associated with each version. In some embodiments to preserve the intuitive feel of the file system the subdirectories to the .snapshot directories that specify the snapshot version for example snap snap and snap are also virtual directories. In other embodiments the .snapshot directories and or their subdirectory s are non virtual directories that are explicitly represented on disk.

In the depicted embodiment the fields in the inode metadata structure include but are not limited to the mode field the LIN field the last snapshot identifier field last snapshot ID and the governance list field . In other embodiments the metadata structure may include fewer or more fields such as a reverse lookup hint field a name field and or a field indicating the amount of data referenced by the inode. In addition the metadata structure may be stored using a different type of data structure.

The governance list field includes all of the snapshot IDs that govern the particular inode. In other words if the inode corresponds to a version s of a file or directory the snapshot ID associated with the version s appears in the governance list of the inode. For example when a snapshot of a file or a directory is created but before any modifications to the file or directory have been made the governance list of the current version will include the snapshot ID of the newly created snapshot. However when that file or directory is modified the inode associated with the snapshot version will have the snapshot ID in the governance list and the current version will store an empty set in its governance list. Accordingly a current version of a file without any snapshot versions will also store an empty set in its governance list. The governance list may be implemented using a variety of data structures known to one with ordinary skill in the art such as a linked list or an array.

The last snapshot ID field includes information about the corresponding file or directory that was modified. After modification the version of the modified file or directory is updated or painted with the global count that is the snapshot ID at the time the modification is made . In one embodiment updating the inode with the global count serves to indicate the last time the governance list of the inode was modified.

In one embodiment the metadata is implemented using an array. In another embodiment the metadata is implemented using a linked list. A person with ordinary skill in the art will recognize that the metadata can be implemented using a variety of data structures.

In one embodiment a snapshot tracking data structure or snapshot tracking file is created each time a snapshot is created. Accordingly a snapshot tracking file is associated with each snapshot. The snapshot tracking file provides information regarding each file or directory governed by a snapshot that was modified or deleted after the snapshot was taken.

In one embodiment the snapshot tracking file can be used to determine which files and directories of a particular version are examined when deleting a snapshot. In another embodiment the snapshot tracking file can be used to track information about a particular snapshot. This information may include but is not limited to disk usage.

In one embodiment the snapshot tracking file LIN field is a unique identifier associated with the snapshot tracking file and is similar in purpose to the LIN associated with a file or a directory.

In one embodiment the snapshot ID field is the genesis snapshot ID of the snapshot that the snapshot tracking file corresponds to. In one embodiment the genesis snapshot ID is equal to the global count at the moment the corresponding snapshot was created. In another embodiment the snapshot ID field is equal to the time or a representation of the time that the snapshot was created. In yet another embodiment the snapshot ID field is some other identifier that indicates a correspondence with a related snapshot.

In one embodiment the LIN field s stores the LINs associated with files or directories that have been modified or deleted from the file system after the corresponding snapshot was created. In another embodiment the LIN field s stores the LINs of files or directories that have been read after the snapshot was created. In yet another embodiment the LIN field s stores the LINs of files and directories accessed before a subsequent snapshot is created. While illustrates a set of six LIN fields it is recognized that a wide number of LIN fields may be included and or a variable number of LIN fields may be used depending on the number of modified LINs.

In one embodiment the snapshot tracking file is a fixed length array that stores empty sets for LIN fields that have not yet been populated. In other embodiments the snapshot tracking file is a linked list that adds entries each time a file or directory is modified or deleted. A person with ordinary skill in the art will recognize that a snapshot tracking file can be implemented using a variety of suitable data structures.

In one embodiment the LIN table comprises a plurality of rows . Each row stores data for a particular version of a file or a directory. Each row is comprised of several fields which may include but are not limited to a LIN field a snapshot ID field a mini snapshot flag and a reference or pointer field . In another embodiment the LIN field and the snapshot ID field comprise a single field. For example the LIN snapshot ID pair may be represented using a sixteen byte binary value with the LIN occupying the most significant bits of the sixteen byte value and the snapshot ID occupying the least significant bits. In another embodiment the LIN table may include fewer or more fields such as for example the mode the governance list the creation date and so forth.

The LIN field includes the LIN of the inode version that a particular row in the LIN table references.

The snapshot ID field includes the genesis snapshot ID of the inode version that a particular row in the LIN table references.

In one embodiment the mini snapshot flag field indicates whether a directory is a mini snapshot rather than a version of a directory in the file system. In some embodiments a mini snapshot is indicated when the flag is set. In other embodiments a mini snapshot is indicated when the flag has been cleared.

In one embodiment the reference field includes a pointer to the inode that corresponds to a LIN snapshot ID pair represented in the LIN table. For example row includes the LIN snapshot ID pair which points to inode . Accordingly inode four hundred fifty includes in its metadata the same LIN . Also inode four hundred fifty includes a governance list that provides a representation of the snapshots that govern this version of inode four hundred fifty. In one embodiment the governance list does not store the same value s as the genesis snapshot ID stored in the LIN table .

In some embodiments the LIN table references inodes that further reference metatrees . Metatrees are data structures specific to a version of a file or directory. In one embodiment metatrees associated with a directory inode store references to the children of the inode. For example the metatree for inode four stores references to children with LIN one hundred LIN five thousand and LIN nine thousand . Thus the current version of inode four has three children. Metatree has only one entry because it is a mini snapshot for a file or directory nested within inode one hundred. Therefore though the current version and a previous version indicate that inode four has three children the inode associated with the mini snapshot only references the child necessary to access data governed by snapshot .

Row in the LIN table has the mini flag set in the mini snapshot flag field . In the depicted embodiment when the flag is set the row in the LIN table references a mini snapshot. Accordingly row references inode which is a mini snapshot associated with snapshot ID . In one embodiment the metadata for an inode associated with a mini snapshot does not include a governance list. In this embodiment a governance list is not needed because no data stored in the data blocks of the inode can be altered because subsequent versions of mini snapshots cannot exist. That is mini snapshots are only used to facilitate downward navigation to snapshot data.

Row in the LIN table references inode . In one embodiment the snapshot ID associated with row is MAX INT. MAX INT represents a binary value wherein all of the bits are set for example all bits are set to . In one embodiment the value MAX INT is used to represent the current version of a file or directory. For example whenever the user wishes to modify a file or directory with snapshot ID MAX INT the user knows that the current version of the file is being modified. In another embodiment the current version can be assigned a snapshot ID wherein all bits are cleared for example all bits are set to . In a further embodiment the current version can be assigned a snapshot ID with an empty set or some other representation that identifies the current version.

In one embodiment each row is implemented using a fixed length array. In another embodiment each row is implemented using a linked list. In yet another embodiment the rows are associated with one another using an array or a linked list. A person with ordinary skill in the art will recognize that the LIN table can be implemented using a variety of different data structures.

Next a snapshot tracking file is created with fields including for example the snapshot ID field and the LIN field s empty. Then the global count is accessed and added to the snapshot ID field of the snapshot tracking file .

After the snapshot tracking file has been created and the global count added decision block determines whether the root of the snapshot is also the root of the file system. If it is the root of the file system the operations in blocks and can be skipped. However if it is not the root of the file system a for loop for all ancestors of the root of the snapshot to the root of the file system is initiated.

For all of these ancestors a mini snapshot is created . In one embodiment creating a mini snapshot includes two steps. First an inode is created. The inode comprises at least a mode field and a LIN field. In one embodiment the mode field indicates that the inode is associated with a directory because in the exemplary embodiment files cannot have children. In other embodiments where either files or directories may have children the mode field indicates either a file or a directory. The LIN field indicates the LIN of the corresponding ancestor of the root of the snapshot. Second a reference is created that points to a child of the ancestor in the path to the root of the snapshot. In some embodiments a mini snapshot is a virtual data structure that is created when a snapshot version with mini snapshots is accessed.

In one embodiment after the mini snapshots for all ancestors up until but not including the root have been created the for loop ends . In another embodiment the for loop ends when mini snapshots have been created for all ancestors including the root directory. After the for loop ends the genesis snapshot ID is added to the governance list of the inode associated with the current version of the root of the snapshot .

In another embodiment multiple paths to multiple roots of a snapshot are accepted. It is recognized that a person with ordinary skill in the art would be capable of modifying process to accommodate a snapshot that has multiple roots.

While illustrates one embodiment of a create snapshot operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

The process of modifying a file or directory begins by executing the painting operation depicted in . After the painting process terminates decision block determines whether the file or directory that will be modified is governed by a snapshot. The painting process in part can determine whether the file or directory is governed by a snapshot. If the file or directory is governed by a snapshot then the create snapshot version of file or directory process is executed. However if the file or directory is not governed by a snapshot the create version of file or directory process is skipped.

Next decision block determines whether a file or a directory is being modified. If a file is being modified the file COW process is executed. However if a directory is being modified the directory COW process is executed. Then after either the file COW process or the directory COW process finishes executing the operation ends .

While illustrates one embodiment of a create snapshot operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In one embodiment the painting process begins at decision block by asking whether the last snapshot ID stored in the file or directory to be modified or target file dir is less than the global count. As discussed previously the global count can be used to indicate the relative time when a snapshot was created or when the governance list of a particular inode was updated. Thus in the depicted embodiment the global count is a value that is greater than or equal to any snapshot ID stored in the system. If the last snapshot ID is not less than the global count then we know that the snapshot ID is equal to the global count and the governance list of the inode is therefore up to date. Then the process ends .

However if the last snapshot ID is less than the global count two variables are initialized EXAMINED MINIMUM last snapshot ID 1 and EXAMINED DIRECTORY parent inode of the target file dir. Next a while loop initiates and executes the operations nested within it while EXAMINED MINIMUM is less than or equal to the global snapshot count. Therefore even if the snapshot ID was one less than the global count the operations in the while loop will execute at least once because EXAMINED MINIMUM must be greater than the global snapshot count to terminate the while loop .

Next a for loop considers each inode version of the EXAMINED DIRECTORY. Within for loop is nested for loop which considers snapshot ID in the governance list of the considered inode version.

Thus for each snapshot ID of a particular inode version decision block asks whether the snapshot ID is greater than or equal to EXAMINED MINIMUM. If it is not the next snapshot ID is considered . In other words if the snapshot ID is not greater than or equal to EXAMINED MINIMUM the governance list of the target file dir was updated after the particular snapshot was taken. Thus the snapshot ID is ignored because it would already be included in the governance list of the target file dir.

However if the snapshot ID is greater than or equal to EXAMINED MINIMUM the snapshot ID is added to the governance list of the target file dir . In other words the snapshot associated with the particular snapshot ID is more recent than the last time the target file dir was painted . Thus the governance list of the target file dir is updated .

Next after each snapshot ID in a particular version has been considered the for loop ends and the next version of EXAMINED DIRECTORY as dictated by for loop is considered. Then after all of the snapshot IDs of all of the inode versions of EXAMINED DIRECTORY have been considered for loop ends .

Decision block then determines whether EXAMINED DIRECTORY is the root of the file system. If it is the root of the file system the while loop breaks . After breaking the last snapshot ID field of the target file dir is updated with the global snapshot count to indicate when it was last painted. Then the painting process ends.

However if EXAMINED DIRECTORY is not the root of the file system EXAMINED MINIMUM is assigned a value equal to the greater of EXAMINED MINIMUM and last snapshot ID of EXAMINED DIRECTORY 1 . In other words block determines whether the EXAMINED DIRECTORY or the child of the EXAMINED DIRECTORY which was previously considered by for loops and was last painted. Then if EXAMINED DIRECTORY is not out of date as determined by the global snapshot count and the condition presented in the while loop EXAMINED DIRECTORY is updated to be the parent of the previous EXAMINED DIRECTORY given these conditions a trivial operation and the while loop ends because EXAMINED MINIMUM is equal to the global count. Then the last snapshot ID field of the target file dir is updated with the global count to indicate when it was last painted and the process ends .

Alternatively if EXAMINED MINIMUM is still less than or equal the global snapshot count the operation of reassigning EXAMINED DIRECTORY to the parent of the previous EXAMINED DIRECTORY is meaningful because the snapshot IDs of all inode versions of the new EXAMINED DIRECTORY are considered in order to update the governance list of the target file dir . The while loop persists until one of two conditions occur the EXAMINED DIRECTORY is the root of the file system or the EXAMINED DIRECTORY is one that is not out of date . When either of these conditions occur as explained above the last snapshot ID of the target file directory is updated and the process ends .

While illustrates one embodiment of a painting operation it is recognized that other embodiments may be used. For example the process may also paint ancestors of the target file dir or may use other looping instructions. Alternatively the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In one embodiment the creating a snapshot version process begins by adding the LIN of the target file dir to the snapshot tracking file associated with the governing snapshot . As stated previously a list of all modified files or directories governed by a snapshot can be used when deleting the snapshot or performing other functions. Next the inode of the target file dir is copied . The copy is then added to the LIN table . The LIN table stores the LIN of the target file dir and the highest snapshot ID in the governance list of the file to be modified. Then the create snapshot version process ends.

While illustrates one embodiment of a creating a snapshot version operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In the depicted embodiment the process begins in decision block which determines whether there is a previous version of the target file. If there is not a previous version of the target file the version of the target file can be modified without performing a COW. A COW is unnecessary when a version of the target file does not have a previous version because that version does not need to be preserved. After the version of the target file has been modified the process ends .

However if there is a previous version of the target file decision block asks whether there is a ditto record or indicator for the block address location s BADDR to be modified in the previous version. As used herein BADDRs are used to refer to the physical address of a data block on disk. In the illustrated embodiments files are comprised of inodes which store the metadata. The inode references a plurality of BADDR locations stored in a metatree. The BADDR locations can either point to a data block located on a physical disk or reference the next version of the target file referred to herein as a ditto record . If a BADDR location is accessed and it includes an address then it will use the address to locate data on the physical disk. However if the BADDR location includes a ditto record the process will look to that BADDR location in the metatree of the next most recent version. If a ditto record is located in that BADDR location the process will look to the BADDR location in the metatree of the same BADDR location in the metatree of the next most recent version. This process continues until a BADDR location is reached that includes an address. Then the data is retrieved from the physical disk or the cache.

In one embodiment the metatree is comprised of an array. In other embodiments the metatree is comprised of a linked list. In yet other embodiments the metatree is comprised of a hybrid of a linked list and a plurality of arrays. A person with ordinary skill in the art will recognize that other data structures are considered suitable for storing information related to file data.

In decision block if a ditto record is not found at a BADDR location s an address has been found. Thus the data has already been COWed to the BADDR location s . In other words the corresponding BADDR location s has been modified at least once the snapshot was created. Therefore the BADDR location s can be modified in the current version directly and the process ends .

However if a ditto record exists at the BADDR location s the ditto record is removed . Then data from the BADDR location s of the target file is copied to the BADDR location s of the previous version . Next the BADDR location s of the target file are modified and the process ends .

While illustrates one embodiment of a file COW operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location. Additionally other embodiments may represent and store data common to more than one version using different data structures such as for example using a physical model a hybrid model or a log based model.

In the depicted embodiment process begins in decision block by determining whether the entry is being added to a target directory or whether an entry within the target directory is being modified or removed. In one embodiment if an entry is being added to the current version it is unnecessary to COW the new entry because previous versions of the target directory do not include the new entry. Consequently the entry can be added to the metatree associated with the target directory . Then the genesis snapshot ID of the entry in the metatree of the target directory is set to the global snapshot count and the process ends .

If however an entry in the target directory is being modified or removed decision block asks whether the genesis snapshot ID of the entry is more recent than the most recent snapshot ID in the governance list of the target directory. If the snapshot ID of the entry is more recent than the most recent governing snapshot the entry is not governed by a snapshot. Therefore the entry can be removed or modified without COWing the entry to a previous version of the target directory.

However if the snapshot ID of the entry is not as recent as the latest governing snapshot the entry is copied to the next most previous version of the target directory before the target directory can be removed or modified . In some embodiments the entry is copied to the same location in the metatree of the previous version.

After the target directory has been modified the genesis snapshot ID of the entry is set to the global count and the process ends .

While illustrates one embodiment of a directory COW operation it is recognized that other embodiments may be used. For example an entry may be added removed or modified in any version of the directory. Additionally the inputs and outputs may be passed as values references and or stores in an accessible memory location.

The delete snapshot process begins by accepting a delete snapshot request from a user client application application or other source. Next a for loop considers all files and or directories in the snapshot tracking file. As previously discussed in one embodiment the snapshot tracking file comprises a list of all files and directories that were modified or deleted after the snapshot was created.

For each considered file decision block asks whether a previous snapshot governs the snapshot to be deleted. If there is not a previous governing snapshot the snapshot version of the considered file or directory can be deleted . In one embodiment the version of the file or directory is deleted without any copy operations because previous versions do not store data referenced by future versions.

Next the inode associated with the snapshot of the considered file or directory is deleted . Then the LIN snapshot ID pair for the considered version of the file or directory is deleted from the LIN table . Then for loop considers the next file or directory in the snapshot tracking file.

However in decision block if there is a previous snapshot decision block asks whether a file or directory is being considered by the for loop . If a file is being considered data is copied to BADDR locations in a previous version of the file if the particular BADDR location includes a ditto entry referencing the deleted snapshot.

If however decision block considers a directory for loop considers each file or directory referenced by the directory considered by for loop . For each referenced file or directory process considers whether the snapshot ID of the referenced file or directory is less than or equal to the highest snapshot ID in the governance list of the previous snapshot . If it is the reference to the file or directory is copied to the previous version. This comparison of snapshot IDs determines whether the referenced file or directory was created after the next most previous snapshot was created. Thus if the referenced file or directory was created after the previous snapshot then COWing the referenced file or directory is unnecessary because the referenced file or directory did not exist at the time the previous snapshot was created. After all of the referenced files or directories have been considered the for loop ends .

After the file or directory in the snapshot tracking file has been COWed operations and execute. Then after all of the files and directories in the snapshot tracking file have been considered the for loop ends . Next the snapshot tracking file associated with the snapshot is deleted and the delete snapshot process ends .

While illustrates one embodiment of a delete snapshot operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In one embodiment the read file process begins by receiving the LIN of the file version to be read and the snapshot ID of the file version . In another embodiment the path to the file version is received. In one embodiment the snapshot ID of the file version is stored in an in memory cache structure. In embodiments that utilize the user interface described with respect to the path includes a .snapshot subdirectory if a snapshot version is sought.

Next the process gets the inode that corresponds to the received LIN snapshot ID pair. This step can be performed using lookup techniques known to those with ordinary skill in the art.

After the inode has been retrieved a for loop considers each BADDR location in the portion of the metatree being read. Then for each BADDR location decision block asks whether there is a real BADDR record exists. If a real BADDR record exists the process looks up the BADDR on the physical disk and retrieves data. However if a real BADDR record does not exist the process reads the next inode version . Again the process will determine if a real BADDR record exists in the next version . The process will continue looking to subsequent versions until it finds a real BADDR record in the considered BADDR location. When a real BADDR record is found the process looks up the BADDR on the physical disk and retrieves the data.

After all of the BADDR locations in the portion of the metatree being read have been considered the for loop ends and the read file process ends .

While illustrates one embodiment of a read file operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In one embodiment the directory lookup process begins by receiving a target file or directory. The target file or directory is the version of a file or directory a user or client application wishes to access from a particular snapshot. Next the process receives the LIN snapshot ID of the particular snapshot the relevant snapshot of a parent directory the relevant directory that may or may not include the target file or directory.

Then a for loop considers all snapshots of the relevant directory that have a snapshot ID greater than or equal to the snapshot ID of the relevant snapshot. In one embodiment the range of snapshots are considered from oldest to newest. Considering the snapshots in this way can speed up the lookup operation for target files or directories that have been modified frequently. That is if the target file or directory has been modified frequently the COWed version of the target file or directory is more likely to appear as an entry in an older version of the relevant directory rather than a newer version of the relevant directory. In other embodiments the for loop considers the range of snapshots from newest to oldest. Considering snapshots in this order is more efficient for target files directories that are rarely if ever modified because they are more likely to appear in a newer version of the relevant directory.

For the snapshot being considered the process performs a lookup in the metatree of the relevant directory for the target file or directory. In other embodiments the lookup may be performed in another data structure that stores entries corresponding to the children of the relevant directory.

Next decision block asks whether an entry matching the target file or directory is found in the metatree of the considered version of the relevant directory. If it is not the next snapshot is considered and the lookup is repeated . However if a matching entry is found in the considered version decision block asks whether the genesis snapshot ID of the matching entry is less than the snapshot ID of the relevant version. If the genesis snapshot ID of the entry is less than the snapshot ID of the relevant version the for loop breaks and the location or path of the appropriate version of the target file or directory is returned . Then the process ends .

However if the genesis snapshot ID of the matching entry is not less than the snapshot ID of the relevant version the matching entry was a version created after the relevant snapshot and was therefore not an entry in the relevant version of the relevant directory. The process then considers the next snapshot within the range. If the for loop considers every snapshot within the range and is unable to find a matching entry with a genesis snapshot ID less than the snapshot ID of the relevant version the for loop ends . Thus the process returns an indication that the target file or directory was not found .

While illustrates one embodiment of a directory operation it is recognized that other embodiments may be used. For example the inputs and outputs may be passed as values references and or stores in an accessible memory location.

Because the depicted embodiment returns only one entry from the relevant version at a time an index is used. The index serves as a bookmark that indicates which entry in the relevant version the read directory operation returned last. In the depicted embodiment the bookmark is implemented using a variable named NEXT INDEX. In one embodiment NEXT INDEX is the key of the directory entry in the B tree structure of the relevant directory. It will be appreciated by one with skill in the art that the key is a value that is a identifier of the entry that is unique to at least one of a file system a B tree a storage node and a storage device. Accordingly NEXT NAME is the name of the entry that has a key equal to NEXT INDEX.

Additionally because the read directory operation returns one entry at a time the process returns an entry in response to an index value PREVIOUS INDEX that corresponds to the key of the last entry returned by the operation. The use of PREVIOUS INDEX helps ensure that process does not return entries that were previously returned. Thus process is a function of PREVIOUS INDEX.

The process begins by receiving the snapshot ID of the relevant snapshot . Then the process gets all snapshots with snapshot IDs greater than or equal to the snapshot ID of the relevant snapshot . In one embodiment the process retrieves this range of snapshots because entries for a particular version of a directory are stored either as an entry in that directory version or in subsequent versions. Thus the process looks at the relevant version or look ahead to retrieve entries located within the relevant version. After the inodes are retrieved the process creates the variable NEXT NAME and the variable NEXT INDEX initializing it to a value of MAX INT .

Then a for loop considers each of the retrieved inodes. Next a nested for loop considers each entry in the version considered by for loop starting at a location in the relevant directory corresponding to PREVIOUS INDEX 1.

Decision block asks whether the index of the considered entry is greater than NEXT INDEX. For the first entry considered the index of the entry will not be greater than NEXT INDEX because NEXT INDEX is initialized to MAX INT. However for subsequent considered entries if the index of the entry is greater than NEXT INDEX the for loop breaks and the next version of the relevant directory is considered .

If the index of the considered entry is not greater than NEXT INDEX decision block asks whether the genesis snapshot ID of the entry is less than or equal to the snapshot ID of the relevant version. If it is not the next entry in the version is considered .

However if the genesis snapshot ID of the considered entry is less than or equal to the snapshot ID of the relevant version the entry was created before the relevant version and is therefore a child of the relevant version of the relevant directory. Thus NEXT NAME is assigned a value that corresponds to the name of the considered entry and NEXT INDEX is assigned a value that corresponds to the index of the entry . Next for loop breaks and the next inode version is considered . However if all of the entries in the considered version have neither an entry index greater than NEXT INDEX nor a genesis snapshot ID less than or equal to the snapshot ID of the relevant version for loop ends and the next version is considered .

Even if the operation of block executes in a previous iteration of for loop the next version is considered because there could exist an entry that has an index that is greater than PREVIOUS INDEX 1 but less than the present value of NEXT INDEX. After all versions of the relevant directory within the range have been considered for loop ends . Next decision block asks whether NEXT NAME stores a value. If it does store a value an entry within the relevant version with an index greater than PREVIOUS INDEX was found and the process returns NEXT NAME and NEXT INDEX . However if NEXT NAME does not store a value no entry in the relevant version with an index greater than PREVIOUS INDEX was found and the process returns NO MORE ENTRIES EXIST .

While illustrates one embodiment of a directory operation it is recognized that other embodiments may be used. For example all entries may be returned by recursively calling operations and reassigning PREVIOUS INDEX to equal NEXT INDEX each time the operations are called. Additionally the inputs and outputs may be passed as values references and or stores in an accessible memory location.

In the embodiment discussed above inodes associated with files reference BADDR locations in a metatree that store either real BADDR records or ditto records which reference the next version of the file. For ease of reference this file structure implementation will be referred to as the logical model. However it is recognized that other file structure implementations exist such as for example a physical model a hybrid model and a log based model. Each of these models is described in detail below.

The snapshot version of the file only references data blocks on the physical disk that have been modified and thereby COWed since the snapshot was created. Accordingly because BADDR locations were modified BADDR locations reference data blocks . The remaining BADDR locations in the snapshot version include ditto records which reference the next most recent version . Accordingly ditto records such as and can represent large amounts of data by acting as a compact place holder.

The snapshot version of the file references data blocks in the same way that the current version references data blocks. BADDR locations references the same data blocks as BADDR locations because the data was not modified after the snapshot was created and BADDR locations similarly reference the same data blocks as BADDR locations . However BADDR locations reference different data blocks than BADDR locations because this portion of the file was modified and consequently COWed. Accordingly BADDR locations reference data blocks .

The physical model offers identical snapshot version and current version read times because real BADDR locations are stored in all BADDR locations of the snapshot version. That is the indirection of the physical model is not present. However the physical model may be less desirable than the logical model because unchanged portions of the metatree cannot be compactly stored using ditto records.

The hybrid model may be more desirable than the logical model when a large number of snapshots have been modified frequently because the indirection in between data structured in the logical model may slow down read operations. However lookups for delete snapshot operations in a potentially large metatree of the hybrid model may be computationally expensive.

The log based model may be more desirable than the other models because snapshot data can be stored compactly permitting tracking of even single byte modifications. However the log based model may be less desirable than the other models because read operations are more computationally expensive.

Before the snapshot governed the file the governance list of the file stored an empty set indicating that no snapshots govern the file. Reference to illustrates the creation of the snapshot of the file shown in . The process received the path of the file as the root of the snapshot. Next a snapshot tracking data structure not shown in was created that corresponds to the snapshot taken of the file . The global count at the time the snapshot was created is added to the snapshot tracking data structure . This value is the snapshot ID. In this example the snapshot ID is .

Because the file is not the root of the file system a mini snapshot is created for each of the ancestors of the file to the root of the file system . Next the snapshot ID is added to the governance list of the inode associated with the current version of the file . Thus though the governance list of the snapshot was formerly an empty set the snapshot of the file is created once the snapshot ID is added to the governance list of the file s inode .

Additionally the LIN table includes an entry that references the current version of the file. The entry indicates the LIN of the file and the genesis snapshot ID of the inode MAX INT. MAX INT is used to indicate that the entry references the most current version of the file. In the depicted embodiment the LIN table does not include an entry for snapshot ID either before or after snapshot creation because the current version was not modified after the snapshot was created. In this embodiment if a user or client application wishes to access snapshot a lookup in the LIN will reveal no entry for snapshot and consequently the inode with the next highest snapshot ID MAX INT is accessed. In other embodiments the LIN table may include an entry with LIN and genesis snapshot ID that references the current version of the file. In other words there would be two entries in the LIN table that reference the same inode.

When the second snapshot was created process of was executed in a similar manner as described above with respect to snapshot . For this snapshot the global count was at the time the second snapshot was created. Therefore the governance list of the inode associated with the current version listed snapshot IDs and . Immediately after snapshot was created the LIN table did not change. Thus a lookup for snapshot ID would yield no match and the next highest snapshot ID MAX INT would be accessed.

Next the data associated with BADDR locations in the current version were modified. Reference to illustrates the relevant operations for modifying the current version of the file. The process begins by calling the painting process depicted in . In the painting process decision block asks whether the snapshot ID of the target file dir is less than the global count. Because we assume that the global count is the snapshot ID is equal to the global count. Thus the operations of the painting process are not required and process ends .

Next decision block asks whether the file is governed by a snapshot. The governance list of the current version indicates that both snapshots and govern the current version of the file. Thus the create snapshot version of file dir process is called. First the LIN of the file is added to the tracking file of the governing snapshot not shown . Next the inode of the file is copied . The copy of the inode is represented by data structure in . Accordingly the inodes of the current version and snapshot version differ in that the snapshot version is governed by snapshot IDs and whereas the current version is no longer governed by a snapshot. Finally the LIN of the snapshot version is added to the LIN table . As depicted LIN with snapshot ID is added to the LIN table. Notably snapshot ID does not have to be added to the LIN table because snapshots and reference the same metatree locations.

Then decision block asks whether a file or a directory is being modified. Because a file is being modified the file COW process of is called. The file COW process first asks whether a previous version of a file exists . In this example previous versions corresponding to snapshot IDs and exist. Thus decision block asks whether there is a ditto record for the BADDR locations to be modified in the previous version. Because there have been no previous modifications to the file all BADDR locations in the previous version include a ditto record. Thus the ditto record from BADDR locations in the snapshot version are removed and the original data from BADDR locations in the current version are copied to BADDR locations in the snapshot version . Next the BADDR locations in the current version can be modified . Thus the snapshot version includes ditto records for BADDR locations and . BADDR locations includes references to the portion of the physical disk that stores the COWed data.

As discussed above with respect to the snapshot creation process adds the snapshot ID of the snapshot to the governance list of the current version . Assuming that the global snapshot count at the time the snapshot is taken is snapshot ID is added to the governance list of the current version and a snapshot tracking file associated with snapshot not shown is created.

Next a user or client application wishes to modify the data associated with BADDR locations in the current version. Assuming that the global count is the painting process is bypassed because the snapshot ID is equal to the global count . Next the LIN is added to the snapshot tracking file associated with snapshot the inode of the current version is copied so as to correspond to snapshot and the new inode is added to the LIN table . As shown the LIN table includes new row with the LIN snapshot ID pair . This row points to the inode associated with snapshot .

Next because a file is being modified the file COW process is called. Because there exists a previous version of the file with a ditto record in the BADDR locations to be modified the data in BADDR locations from the current version are copied to BADDR locations of snapshot . Next the data associated with BADDR locations in the current version may be modified. Thus in snapshot BADDR locations include a reference to the physical disk and BADDR locations include ditto records.

Notably in order to modify the current version governed by snapshot changes to the metatrees associated with snapshot IDs and are not required. Therefore snapshot version is read in the following way for BADDR locations the ditto record references version which includes references to the physical disk for BADDR locations ditto records in version and reference the current version which includes references to the physical disk BADDR locations include direct references to the physical disk and for BADDR locations ditto records in version and reference the current version which includes references to the physical disk. Therefore to read the entire contents of version the metatrees for version version and the current version need to be accessed.

Then the inode and metatree associated with version can be deleted and the reference in the LIN table to snapshot can be deleted . In other embodiments the entire row in the LIN table may be deleted. Because only one file was under consideration for loop ends and the snapshot tracking file associated with snapshot is deleted.

After the deletion of snapshot a read operation on version proceeds in the following manner. First the inode of the file is received and each BADDR location in the region being read is considered. For locations data can be accessed by performing a lookup of the BADDR locations on the physical disk because a real BADDR record exists for these locations. However for BADDR locations the next inode version needs to be read to find a real BADDR record. Thus a lookup on the physical disk relies on real BADDR records . Similarly a read on BADDR locations occurs in a similar way to BADDR locations because a real BADDR record exists. A read on BADDR locations occurs in a similar way to BADDR locations because a ditto record exists.

Assuming the global snapshot count is at the time the first snapshot of dir is created creation of a snapshot with a root of dir first creates a snapshot tracking file and adding snapshot ID to the snapshot tracking file . Then a mini snapshot for each parent of dir to the root is created because dir is not the root of the file system . Next snapshot ID is added to the governance list of the current version of dir .

Then the directory COW process is executed because a file included in dir is being modified. When removing an entry the directory COW process asks whether the genesis snapshot ID of file is more recent than the snapshot . Because the genesis snapshot ID of file is and the governing snapshot ID is the entry for file is copied to the same key location in the metatree for snapshot . Next file is removed from the current version . Generally after a file is modified the genesis snapshot ID of the file in the current version is set to the global snapshot count . However in this example the genesis snapshot ID for file is not set to the global snapshot count because file was deleted from the current version.

As discussed above with respect to snapshot is created by adding snapshot ID to the governance list of the current version. Additionally a snapshot tracking file with snapshot ID is created. Then when a request to modify file is accepted the inode of the current version is copied. The copied inode includes the snapshot ID in its governance list and the governance list of the current version includes an empty set. Before file can be modified it is copied to snapshot because its snapshot ID is greater than genesis snapshot ID of file. After the COW is complete file is modified in the current version . Accordingly the genesis snapshot ID of file in the current version is set to global count indicating when file was last modified.

Next file with LIN is added to dir when the global count was . illustrates how an entry may be added to a directory governed by a snapshot. First the entry is added to the metatree associated with the inode of the current version . Then in the LIN table the snapshot ID for the entry is the same as the snapshot ID of the current version . Also the genesis snapshot ID of file in the metatree of the current version of dir is set to the global count.

In order to perform a lookup operation for a particular file or directory in a particular version of dir the directory lookup process first receives the target file or directory and the LIN snapshot ID pair of the relevant directory . For example assume that the target file or directory is file and that the lookup operation is directed to the version of dir snapshot ID pair .

For loop first examines snapshot and determines that there is no matching entry in the local portion of the tree . Next snapshot is considered. A matching entry for file exists in the local portion of the tree . Thus to determine if the matching entry was included in the current version of dir decision block asks whether the snapshot ID is less than the snapshot ID of the relevant version. Here the snapshot ID for file in snapshot is and the snapshot ID of the relevant version is . Therefore the for loop breaks and the location and or the path of file with genesis snapshot ID is returned.

In order to perform a read directory operation for a particular version of dir the read directory process first receives the inodes for the snapshot versions that have snapshot IDs greater than the snapshot ID of the relevant version. For example assume that the read directory operation is directed to snapshot of the dir . Accordingly the inodes for snapshot and the current version are received. To retrieve each entry in version of dir the read directory operation examines each entry in each received inode version . If the genesis snapshot ID of the considered entry is less than or equal to the snapshot ID of the relevant version the process returns the name of the entry . However if the snapshot ID of the entry is greater than the snapshot ID of the relevant entry the process considers the next entry .

In the illustrated example the process first considers file in version . It is returned as an entry in this version of dir because its snapshot ID is less than the relevant snapshot ID . Similarly the snapshot ID of each entry in the current version is considered. Therefore dir is the only entry returned because the entries for file and file each have snapshot IDs greater than the snapshot ID of the relevant version. Thus a read directory operation for the entire contents of snapshot version of dir would indicate that dir includes file with genesis snapshot ID and dir with genesis snapshot ID .

As described above with respect to in some embodiments data associated with a modified file or directory is COWed. In other words data from the current version of the file or directory is copied using a COW process before permitting the modification of the current version. As described in greater detail below data may also be copied using a Point In Time Copy PITC process. In some circumstances it may be more advantageous to use PITC rather than COW. Some embodiments therefore implement adaptive COW choosing based on the type of modification and or other factors whether to use COW PITC or a combination of both.

For purposes of illustration only the embodiments described herein include file systems that write data contiguously in sixteen block clusters with 8 kB data blocks in other words in groups of 128 kB. For example the 512 kB file described above with reference to is divided into four 128 kB portions. These portions are grouped together in groups of two and corresponding parity data 128 kB is created for each pair. The sixteen block cluster pairs and their respective parity data are stored on respective nodes of the cluster of computer nodes . Each respective sixteen block cluster including the parity data is written in contiguous physical address space. One skilled in the art will appreciate that there are many suitable cluster sizes for writing contiguous data including for example one block four blocks five blocks sixteen blocks one hundred and thirty five blocks one thousand blocks and so forth. One skilled in the art will also appreciate that there are many suitable block sizes including for example 1 kB 4 kB 5 kB 128 kB 1 megabyte and so forth.

In the examples described below reference is made to metatrees BADDRs and physical storage . In the illustrated embodiments metatrees correspond to different versions of a file such as the current version of a file or various snapshot versions of the same file. Metatrees include BADDRs which are the instructions for finding the various data blocks that comprise a given version of a file. BADDRs store in the illustrated embodiments either a physical address or a ditto record. The physical addresses are addresses to data blocks of physical storage . Physical storage may be any suitable storage device including a hard disk drive heterogeneous or homogeneous arrays of drives random access memory RAM flash storage and so forth. As described above with reference to ditto records indicate that a BADDR references another BADDR in the next version of the file. A ditto record instructs the file system to look at the corresponding BADDR in the next version of the file system the next metatree which may either include a physical address or another ditto record directing the file system to look at the corresponding place in the next version of the file the next metatree and so forth. In some embodiments a ditto record may comprise a flag value that indicates that the file system should look for the address in the corresponding BADDR in the data structure of the next version of the file. In other embodiments a ditto record may be an address for example to a data structure of the next version of the file. As used herein the next version of the file refers to next most current version.

The partial overwrite only overwrites the first data block 0 to 7 kB . To perform a COW a new data block is allocated in physical storage to store the value of the data block being overwritten. The contents of data block are then copied to data block . The BADDR of snapshot metatree is assigned the address of data block . After the overwrite the current version of the file still includes data blocks and and the snapshot version includes data blocks and . The snapshot metatree includes BADDR to the newly allocated data block and a BADDR with a ditto record pointing to the BADDR in the current metatree .

To perform a PITC the copied block data block is transferred from the current version of the file to the snapshot version of the file. Accordingly the value of BADDR of the current metatree which is the address of data block is transferred to the snapshot metatree . A new data block data block is then allocated in physical storage and written with the overwrite value. The BADDR of current metatree is now assigned the address of data block . After the PITC the current version of the file includes data blocks and and the snapshot version of the file includes data blocks and . The snapshot metatree now includes BADDR with the address of data block and still includes BADDR with a ditto record referencing BADDR in current metatree . The current metatree now includes BADDR with the address of data block and still includes BADDR with the address of data block .

Although COW and PITC achieve the same functionality saving a copy of the original data in a snapshot version before allowing the current version to be modified COW and PITC have distinct advantages and disadvantages. With respect to COW the main advantage is that the layout of the current version of the file is unaffected as described above with respect to A and A . In other words the contiguous data blocks allocated when the file was created are kept intact allowing them to be read more quickly than if the blocks were non contiguous. In contrast the PITC process is faster to execute but does not preserve the contiguous layout of the current version of the file as described above with respect to B and B . Because it may be more advantageous in some circumstances to use PITC rather than COW some embodiments implement adaptive COW choosing based on certain factors whether to use COW PITC or a combination of both.

The adaptive COW process executes the states between and for the contiguous portions of the file being deleted or overwritten. In some embodiments the contiguous portions are sixteen block clusters of 8 kB blocks in other words 128 kB portions of the file or the remaining portion after a file has been divided into sixteen block clusters including an entire file that is less than a sixteen block cluster 128 kB though other cluster sizes and or number of cluster blocks may be used. In state the adaptive COW process determines whether the relevant contiguous portion is being entirely deleted or overwritten. The relevant contiguous portion is the contiguous portion of the file that is being operated on during one pass of the loop defined by states to . If the relevant contiguous portion is not being entirely deleted or overwritten the adaptive COW process executes a normal COW operation in state as described above with reference to . If the relevant contiguous portion is being entirely deleted or overwritten then the adaptive COW process determines in state whether any blocks in the relevant contiguous portion have been COWed previously. If any of the blocks in the relevant contiguous portion have been COWed previously the adaptive COW process executes a normal COW in state as described in greater detail above with reference to . If none of the blocks of the relevant contiguous portion have been COWed previously then the adaptive COW process uses PITC to transfer the entire relevant contiguous portion in state as described in greater detail above with respect to .

Because the entire file is being overwritten the adaptive COW process uses PITC to transfer the block addresses from the current version of the file to the snapshot version of the file. Specifically the address values of data blocks and stored in the BADDRs of the current metatree are transferred to the corresponding BADDRs in the snapshot metatree . Two new blocks data blocks and in physical storage are then allocated. The BADDRs in current metatree are then assigned the addresses of the newly allocated data blocks. Thus the current version of the file includes the contiguous data blocks and on physical storage and the snapshot version of the file also includes the contiguous data blocks and on physical storage .

Because the entire file is being overwritten there is no disadvantage to transferring the list of block addresses corresponding to the current version of the file to the snapshot version of the file. The current version is completely erased eliminating any need to keep contiguous blocks in the current version of the file. After the adaptive COW process executes the PITC the snapshot metatree includes BADDRs with block addresses for data blocks and in physical storage .

FIGS. C C and C illustrate two successive partial overwrites of a 144 kB file. FIG. C illustrates the snapshot version and the current version of the file prior to the first partial overwrite. Prior to the first partial overwrite the snapshot version and the current version of the file are identical. None of the data blocks of the file have previously been modified. Thus the snapshot metatree has a list of BADDRs that include ditto records pointing to the corresponding BADDRs in the current metatree . Both the current version and the snapshot version of the file include data blocks to and in physical storage . The first partial overwrite is to data blocks to and 0 to 135 kB .

FIG. C illustrates the snapshot version and the current version of the file after the first partial overwrite. Because the partial overwrite included a sixteen block cluster of contiguous address space the adaptive COW process used PITC to copy the sixteen block cluster of contiguous address space to the snapshot version of the file. Thus the block addresses referencing data blocks to in physical storage were transferred from the current metatree to the snapshot metatree . Because the remaining overwritten block data block 128 to 135 kB cannot be transferred using PITC without affecting the contiguity of the remaining two block cluster of the file this overwritten block is COWed. In other words if data block were transferred to the snapshot version of the file a newly allocated data block for the current version of the file data block would no longer be contiguous with the remaining data block of the current version of the file data block . Thus data block is COWed. The block address of BADDR remains with the current metatree a new data block is allocated and BADDR of snapshot metatree is assigned the block address of data block replacing the ditto record. Because the last data block of the file was not modified the snapshot version and the current version of the file both include data block . After the overwrite the current version of the file includes data blocks to and on storage . After the overwrite the snapshot version of the file includes data blocks to and on storage .

FIG. C illustrates an example of a partial overwrite of a portion of a file that has been previously COWed. In the illustrated example the file system overwrites the last two data blocks data blocks and 128 to 143 kB of the 144 kB file previously overwritten as described above with reference to FIG. C. Although the second overwrite includes contiguous data blocks on storage the adaptive COW process does not use PITC because one of the data blocks was previously COWed during the first overwrite described above with reference to FIG. C. Thus the previously unmodified data block 136 to 143 kB is COWed. After the second partial overwrite the last two data blocks of the current version of the file data blocks and are still contiguous. A newly allocated block now preserves the overwritten data previously unmodified in the first overwrite in the snapshot version of the file. Thus the current version of the file includes data blocks to and and the snapshot version of the file includes data blocks to and .

The adaptive COW process uses PITC before deleting both the trailing single data block data block and the second sixteen block cluster. The partial delete also includes the deletion of a single block within the first sixteen block cluster data block . Because this data block corresponds to a cluster that is not entirely deleted this data block is COWed. Thus a new data block is allocated and the contents of data block are copied to data block prior to the deletion of data block . The snapshot metatree now includes BADDRs with block addresses for data blocks to and on physical storage . Thus the current version of the file includes data blocks to and the snapshot version of the file includes data blocks to to and .

In some embodiments an adaptive COW process may use PITC for the single block within the sixteen block cluster that was not entirely overwritten. The PITC operation may be faster than the COW and the contiguity of the remaining fifteen blocks would not be affected. Data block however would not be available for a subsequent append operation affecting possibly the contiguity of a future current version of the file. One of skill in the art will appreciate that there are different suitable ways to implement an adaptive COW process.

The file includes data blocks corresponding to three different clusters including two sixteen block clusters and a two block cluster. The partial overwrite affects all three clusters. The partial overwrite affects the last eight blocks 64 to 127 kb of the first sixteen block cluster 0 to 127 kB . It also overwrites the entire second sixteen block cluster 128 to 255 kB . Finally it overwrites the first data block 256 to 263 kB of the two block cluster. Because the second sixteen block cluster is completely overwritten and because no blocks have been previously COWed the second sixteen block cluster blocks to is copied using PITC. Because the entire first sixteen block cluster blocks to is not overwritten the last eight blocks data blocks to are copied using COW. Similarly because the entire two block cluster data blocks and is also not entirely overwritten the first overwritten block data block is also copied using COW. After the partial overwrite the current version of the file includes data blocks to to and which are all contiguous within their respective sixteen block maximum clusters. The current version of the file includes data blocks to to to and . The block addresses of data blocks to were transferred from the current metatree to the snapshot metatree . The BADDRs in the current metatree were assigned the block addresses for the newly allocated data blocks to . The BADDRs in the snapshot metatree were assigned the block addresses for the newly allocated data blocks to and .

As described above with reference to to access snapshot data users may navigate in some embodiments through a snapshot portal a.snapshot directory a special directory that includes snapshots of directories in the file system. In some embodiments snapshots of the same directory may be accessed through many multiple portals. Because there are multiple possible paths to the same snapshot directory the file system tracks how a directory was entered in order to facilitate subsequent ascent to an expected parent directories. In some embodiments the expected parent directory of a particular directory is the parent directory from which the particular directory was entered. In other words in some embodiments the expected path for ascent is the path previous path of descent. It is possible to track a directory entry without duplicating stored data for each possible path and without explicitly recording the path entry point. In one embodiment a directory identifier LIN a snapshot identifier snapid and a depth value are tracked to allow entry into a child directory and exit back through the same parent directory. An example file system is discussed to illustrate snapshot portals in more detail.

As illustrated in dir is included in two snapshots snapshot one also called SNAP or snap with snapshot ID and snapshot two also called SNAP or snap with snapshot ID . As described above with reference to snapshot data may be accessed by navigating through virtual directories. The top most virtual directory is the entry point to the snapshot data it is the .snapshot directory and is also referred to below as the snapshot portal or portal . There are three snapshot portals through which a user may enter to access the snapshots of directory dir . These are .snapshot directory in the dir directory .snapshot directory in the data directory and .snapshot directory in the ifs directory. Thus the three portals correspond to each one of the directories in the path ifs data dir . In the illustrated embodiment there is a portal for each directory in which there is some data for which a snapshot has been requested. It will be appreciated by one skilled in the art that there are other suitable ways to implement snapshot portals including not maintaining a portal for each directory in which there is some data for which a snapshot has been requested.

The .snapshot directories and the snapshot portals include subdirectories for the snapshots that have been requested for the data accessible through the portal. For example the .snapshot directory the portal for the ifs directory includes subdirectories snap and snap both relevant to dir as well as subdirectory snap not illustrated here because it is not relevant to dir . The .snapshot directory the portal for the data directory includes subdirectories snap and snap both relevant to dir as well as subdirectory snap not illustrated here because it is not relevant to dir . Finally the .snapshot directory the portal for the dir directory includes subdirectories snap and snap . It does not include a subdirectory for snapshot three because snapshot three does not include any data within the dir directory .

Thus in the illustrated embodiment the three portals through which snapshot data in dir may be accessed include two snapshot subdirectories corresponding to the two snapshots relevant to dir . Thus there are a total of six snapshot directories corresponding to dir three directories corresponding to the three portals for snapshot one and three directories corresponding to the three portals for snapshot two . The pathnames of each of these six directories is illustrated in described in greater detail below.

Because there are three different directory paths for entering a snapshot of dir there are also three possible exit points for returning from a snapshot of dir . For example if a user desires to exit the snapshot of dir corresponding to snapshot one by for example executing a cd. in a UNIX shell the user might expect to return to one of three directories including .snapshot ifs data dir .snapshot snap ifs data .snapshot snap or data ifs .snapshot snap data . In the embodiments described below the user exits to the directory from which the user entered. To distinguish between directories that correspond to the same snapshot data the embodiments described below describe the files in the file system with the following fields LIN snapid and depth.

In some embodiments the files and directories in file system are assigned a unique identifier such as for example a LIN. Thus for example dir the current version of dir is assigned a LIN of . In some embodiments the directories corresponding to the snapshot versions of a directory share the same LIN as the current version. Thus for example dir the current version of dir represented by the path ifs data dir has the same LIN as snap the snapshot version for snapshot one of dir represented by the path ifs data dir .snapshot snap and snap the snapshot version for snapshot two of dir represented by the path ifs .snapshot snap data dir . Furthermore the snapshot directories that are accessible through portals of other directories also share the same LIN as the current version. Thus for example dir ifs data .snapshot snap dir dir ifs data .snapshot snap dir dir ifs .snapshot snap data dir and dir ifs .snapshot snap data dir also share the same LIN of . Additionally the .snapshot directory portal of a directory also shares the same LIN. Thus .snapshot directory the portal for dir has a LIN of .

In the illustrated embodiments the snapshots are assigned a unique identifier such as for example a snapid. Thus for example snapshot one is assigned snapid and snapshot two is assigned snapid . In some embodiments snapids may be certain special values that indicate specific types of files. For example a snapid of may indicate the current version of a file or a snapid of may indicate a snapshot portal. Directories within the same snapshot share the same snapid. Thus for example dir ifs .snapshot snap data dir data ifs .snapshot snap data and snap ifs .snapshot snap all share the same snapid of but different LINs. This is also true for the different directories accessible through different portals corresponding to the same snapshot directory. Thus for example snap ifs data dir .snapshot snap dir ifs data .snapshot snap dir and dir ifs .snapshot snap data dir also share the same snapid of .

In the illustrated embodiments some directories will share both the same LIN and snapid if they correspond to the same directory and the same snapshot. For example snap ifs data dir .snapshot snap dir ifs data .snapshot snap dir and dir Ms .snapshot snap data dir all share the same snapid of and also the same LIN of . Accordingly these directories are distinguished instead by a depth field. The depth field indicates how far a particular snapshot directory is from its respective snapshot portal. Thus snap has a depth of dir has a depth of and dir has a depth of . In some embodiments snapshot portals and the current versions of files do not have a depth. For example snapshot portals and current versions of files may have depths of .

There are two ways in which the file system hierarchy is typically traversed. First a request may descend the file system hierarchy such as for example to access a subdirectory of the relevant directory the directory from which the request is descending . Second a request may ascend the file system hierarchy such as for example to access the parent directory of the relevant directory the directory from which the request is ascending . It is noted that a request may access a file system hierarchy using an absolute address which explicitly designates the directory being accessed.

The following provides one embodiment of a process used by the systems and methods described herein to descend the file system hierarchy using the identifier of the relevant directory. The file system determines the identifier of the requested child using the identifier of the relevant directory and the name of the requested child. One embodiment of this process is described in greater detail below with reference to . The following also provides one embodiment of a process used by the systems and methods described herein to ascend the file system hierarchy using the identifier of the relevant directory. The file system determines the identifier of the parent from which the user entered into the relevant directory using the identifier of the relevant directory. One embodiment of this process is described immediately below with reference to .

With reference to the below it is helpful to consider an example of a change to the current version of the file system hierarchy after a snapshot has been taken. For example if dir LIN of were moved from ifs data to ifs after the creation of snapshot one then the LIN of the parent of hypothetical current node ifs dir would be indicating ifs . This information is relevant to ascending descending the current portions of the file system hierarchy. For the snapshot data ifs .snapshot snap data dir ifs data .snapshot snap dir and ifs data dir .snap shot snap however the relevant information for ascending descending is the LIN of the parent of dir at the time of the snapshot. At the time of the snapshot data was the parent of dir so the LIN of is the relevant information for the snapshot versions of dir because that is the LIN of the parent of dir at the time the snapshot was taken.

In state the return child process determines whether the snapid of the relevant directory is a special number indicating that the relevant directory is the current version of the directory. For example a special number of may indicate in some embodiments the current version of the directory. If the snapid indicates that the relevant directory is the current version of the directory then the return child process determines in state whether the requested name of the child is .snapshot . If the requested name is .snapshot then the requested child is the snapshot portal of the relevant directory. In other words the request is a request to enter snapshot data in the file system hierarchy. The return child process then proceeds in state to change the snapid to indicating that the requested child directory is the .snapshot or portal directory. The LIN and the depth of a portal are the same as its parent so the LIN and the depth remain unchanged. The return child process then proceeds to state returning the unchanged LIN the changed snapid and the unchanged depth. If the requested name is not .snapshot then the requested child is not a portal but rather a child of a directory that is not a snapshot directory. Thus the return child process proceeds in state to change the LIN to be the LIN of the requested child and leaves the snapid and the depth unchanged. To determine the LIN of the requested child the return child process may call a process not illustrated that uses for example the LIN of the relevant directory the unchanged snapid indicating that the relevant directory is a current version of a directory and the requested child name. The return child process then proceeds to state and returns the changed LIN the unchanged snapid and the unchanged depth.

If the snapid is not a special number indicating the current version of the file then the return child process determines in state whether the snapid is a special number indicating a portal. For example the value of may indicate a portal. If the snapid is a special number indicating a portal then the return child process proceeds in state to change the snapid to the snapid of the snapshot version corresponding to the requested child. In other words if the relevant directory is the portal of a snapshot then the requested child will be the name of one of the snapshot versions. For example with reference to if the relevant directory is .snapshot ifs .snapshot then a request descending from .snapshot may request the snapshot directory corresponding to snapshot one snap with snapid snapshot two snap with snapid or illustrated in snapshot three snap with snapid . Thus if a user requests snap the return snapid would be assigned the value . Then the return child process changes in state the depth to a value indicating that the requested child is a child of a portal or in other words is one generation removed from a portal . In some embodiments the depth of a child of a portal is . The LIN remains unchanged because the LIN of a child of a portal is the same as the LIN of the portal. The return child process then returns in state the unchanged LIN the changed snapid and the changed depth.

If the snapid is not a special number indicating a portal or the current version of the file as determined in state then the snapid indicates a particular snapshot version and the relevant directory is one of the directories corresponding to that particular snapshot version. In other words the relevant directory is a descendent of a portal. In some embodiments the descendents of a portal the snapshot directories have unique LINs as they correspond to unique files the current versions in the file system . Thus in state the return child process changes the LIN to be the LIN of the requested child of the current version of the relevant directory a snapshot version at the time the snapshot was taken. The return child process looks for the LIN of the requested child of the current version at the time the snapshot was taken because the children of the current version may have changed since the snapshot was taken. To determine the LIN of this requested child the return child process may call a process not illustrated that uses for example the LIN and snapid of the relevant directory and the requested child name. In state the return child process increments the depth by a value of one as the child is one level more away from the portal. The depth distinguishes different instances of the snapshot directory in the file system hierarchy. The descendents of a portal share the same snapid so the snapid remains unchanged. The return child process then returns in state the changed LIN the unchanged snapid and the changed depth.

In state the return parent process determines whether the snapid of the relevant directory is a special number indicating the relevant directory is the current version of the directory and not a snapshot version. For example in some embodiments a value may indicate the current version of a directory and not a snapshot version. If the snapid of the relevant directory indicates the current version of the directory and not a snapshot version then the identifier of the parent is the same as the relevant directory except for the LIN. This is the case because the parent directory of a current version is also a current version of the parent directory so the snapid of the parent will also be for example and the depth of the parent will also remain for example . Thus the return parent process proceeds in state to change the LIN to be the LIN of the parent directory and the snapid and the depth remain unchanged. To determine the LIN of the parent the return parent process may call a process not illustrated that uses for example the LIN of the relevant directory and the unchanged snapid indicating that the relevant directory is a current version of a directory . Then in state the return parent process returns the changed LIN the unchanged snapid and the unchanged depth.

If the snapid of the relevant directory does not indicate that it is the current version of the file then the relevant directory must be either a snapshot portal a .snapshot directory or a snapshot directory. In state the return parent process determines whether the snapid is a special number indicating that the relevant directory is a portal. For example in some embodiments a value of may indicate that the relevant directory is a portal. If the relevant directory is a portal then the parent directory is the current version of the parent directory. Thus the return parent process proceeds in state to change the snapid to the special number indicating the current version of the directory for example . The LIN remains unchanged as the portal has the same LIN as the current version of the portal s parent directory. Similarly the depth remains unchanged as the portal and the current version of a directory both have a depth of for example . Then in state the return parent process returns the unchanged LIN the changed snapid and the unchanged depth.

If the relevant directory is not a portal and also not the current version of the directory as already determined in state then it is a snapshot directory or in other words a descendent of the portal. In some embodiments the descendents of a portal have a depth that is equal to the number of generations of separation between the descendent and the portal. The parent of a portal descendent is one generation closer to the portal. Thus the return parent process proceeds in state to decrement the depth by for example one. Then the return parent process determines in state whether the depth indicates that the relevant directory would return to a portal. In other words the return parent process determines whether the relevant directory is a child directory of a portal directory. In some embodiments the value after the decrement may indicate that the parent directory is a snapshot portal. If the relevant directory is a child directory of a portal then its depth in some embodiments would be indicating that it is one generation away from the portal. After decrementing the depth in state the depth value would be . If the decremented depth value indicates that the relevant directory is returning to a portal in other words that the relevant directory is a child of a portal then the return parent process proceeds in state to change the return snapid to be the special number indicating a snapshot portal for example . The LIN remains unchanged because the LIN of a child of a portal corresponds to the LIN of the parent directory of the portal in other words the current version of the directory in which the portal is found. The return parent process then proceeds in state to return the unchanged LIN the changed snapid and the changed depth.

If the depth does not indicate that the parent directory is a portal then the relevant directory is a descendent of a child of a portal and the parent of the relevant directory is a descendent including possibly a child of a portal in other words a snapshot directory. In some embodiments the descendents of a portal the snapshot directories have unique LINs as they correspond to unique files the current versions in the file system . Thus the return parent process then changes in state the LIN to be the LIN of the parent of the current version of the relevant directory a snapshot version at the time the snapshot was taken. The return process looks for the LIN of the parent of the current version at the time the snapshot was taken because the parent of the current version may have changed since the snapshot. To determine the LIN of this parent the return parent process may call a process not illustrated that uses for example the LIN and snapid of the relevant directory. In the illustrated embodiment the descendents of a child of a portal have unique LINs as they provide access to a snapshot of a unique file in the file system . The LINs of the descendents of a child of a portal are also different than the LIN of the child. However the descendents of a child of a portal and the child of a portal share the same snapid so the snapid remains unchanged. The return parent process then proceeds in state to return the changed LIN the unchanged snapid and the changed depth.

From state to state the user requests to navigate from snap back to .snapshot . Logically there are at least three different directories to which the file system might return including .snapshot ifs data dir .snapshot snap snap ifs data .snapshot snap and data ifs .snapshot snap data . In the illustrated embodiments the file system returns the user to the parent directory from which the user entered. Return parent process implements this design decision. Accordingly because the relevant directory snap is a child of a portal the return parent process returns a LIN of a portal has the same LIN as its children a snapid of the parent is a portal and a depth of portals do not have depth . From state to state the user requests to exit the portal by navigating from .snapshot to dir which is the current version of its file. Because the relevant directory .snapshot is a portal the return parent process returns a LIN of a portal s parent the current version of its file has the same LIN as the portal a snapid of the parent of a portal is the current version of its file and a depth of current versions have no depth . From state to the user requests to navigate from dir to data . Because the relevant directory dir is a current version of its file the return parent process returns a LIN of the LIN of the parent of the relevant directory a snapid of the parent of a current version is also a current version and a depth of current versions have no depth . From state to the user requests to navigate from data back to ifs . Because the relevant directory data is the current version of its file the return parent process returns a LIN of the LIN of the parent of the relevant directory a snapid of a parent of a current version is also a current version and a depth of current versions have no depth .

From state to state the user requests to navigate from dir back to snap . Because the relevant directory dir is a snapshot directory and because its parent snap is not a portal the return parent process returns a LIN of the LIN of the parent a snapid of a parent of a snapshot directory has the same snapid and a depth of the parent is one generation from the portal . From state to the user requests to navigate from snap back to .snapshot . Because the relevant directory snap is a child of a portal the return parent process returns a LIN of a portal has the same LIN as its children a snapid of the parent is a portal and a depth of portals do not have depth . From state to state the user requests to exit the portal by navigating from .snapshot to data which is the current version of its file. Because the relevant directory .snapshot is a portal the return parent process returns a LIN of a portal s parent the current version of its file has the same LIN as the portal a snapid of the parent of a portal is the current version of its file and a depth of current versions have no depth . From state to the user requests to navigate from data back to ifs . Because the relevant directory data is the current version of its file the return parent process returns a LIN of the LIN of the parent of the relevant directory a snapid of a parent of a current version is also a current version and a depth of current versions have no depth .

From state to state the user requests to navigate from dir to data . Because the relevant directory dir is a snapshot directory and because its parent data is not a portal the return parent process returns a LIN of the LIN of the parent a snapid of a parent of a snapshot directory has the same snapid and a depth of the parent is one generation from the portal . From state to the user requests to navigate from data back to snap . Because the relevant directory data is a snapshot directory and because its parent snap is not a portal the return parent process returns a LIN of the LIN of the parent a snapid of a parent of a snapshot directory has the same snapid and a depth of the parent is two generations from the portal . From state to the user requests to navigate from snap back to .snapshot . Because the relevant directory snap is a child of a portal the return parent process returns a LIN of a portal has the same LIN as its children a snapid of the parent is a portal and a depth of portals do not have depth . From state to state the user requests to exit the portal by navigating from .snapshot to ifs which is the current version of its file. Because the relevant directory .snapshot is a portal the return parent process returns a LIN of a portal s parent the current version of its file has the same LIN as the portal a snapid of the parent of a portal is the current version of its file and a depth of current versions have no depth .

While certain embodiments of the invention have been described these embodiments have been presented by way of example only and are not intended to limit the scope of the present invention.

By way of example the following alternatives are also contemplated. Although the data structures described herein have been directed to a distributed system some embodiments of the invention may be used in a single file system. Additionally or alternatively it will be recognized by one with ordinary skill in the art that the depicted embodiments may be modified to accommodate file structures under the logical model physical model hybrid model and or log based model. Further in addition to adding the snapshot ID to the root of the snapshot upon snapshot creation the snapshot ID may be added to some or all of the files and directories governed by the snapshot. Additionally it is recognized that the root of a snapshot can be a single file or directory or more than one file or directory. Embodiments of a systems and methods for performing a reverse lookup are disclosed in U.S. patent application Ser. No. 11 507 075 titled SYSTEMS AND METHODS OF REVERSE LOOKUP filed on Aug. 18 2006 and is hereby incorporated by reference in its entirety.

The above mentioned alternatives are examples of other embodiments and they do not limit the scope of the invention. It is recognized that a variety of data structures with various fields and data sets may be used. In addition other embodiments of the flow charts may be used.

