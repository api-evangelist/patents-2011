---

title: System and method for collecting and evaluating statistics to establish network connections
abstract: An apparatus and method are described for collecting and evaluating statistics for different network addresses and/or subnets when establishing network connections. For example, a method according to one embodiment comprises: receiving a set of potential network addresses for establishing a connection to a remote host; evaluating routing statistics associated with each of the potential network addresses; prioritizing the set of potential network addresses based on the evaluation; and initially attempting to connect to the remote host using the highest priority one or more network addresses.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09094483&OS=09094483&RS=09094483
owner: APPLE INC.
number: 09094483
owner_city: Cupertino
owner_country: US
publication_date: 20110114
---
This invention relates generally to the field of data networks. More particularly the invention relates to an improved system and method for collecting and evaluating statistics to establish network connections.

Gateway devices and are used to allow the computing device to communicate with remote hosts over a larger network e.g. the Internet using a networking protocol such as TCP IP. As illustrated each of the remote hosts may be associated with one or more subnets coupled to the Internet through gateways . All computers that belong to a particular subnet are addressed with a common identical most significant bit group in their IP address which is used to route packets across the network to the gateway for that subnet. For example if the gateway of subnet is identified by the IP address 10.0.1 then hosts and may be assigned IP addresses such as 10.0.1.26 and 10.0.1.5.

Certain hosts such as host may be identified by multiple IP addresses and or subnets. For example host may represent a large Internet site with multiple IP addresses associated therewith e.g. such as Google.com or Yahoo.com . In operation the computing device may receive a list of the multiple IP addresses from a domain name service DNS server in response to a DNS query. The computing device will then typically attempt to connect to the first IP address on this list.

As illustrated in the computing device includes a networking engine for implementing a network protocol stack. In order for the computing device to communicate over the Internet the network protocol stack must include support for the TCP IP protocol. An application wishing to communicate over the network must do so by making calls to the networking engine .

On some computing devices the networking engine uses a routing table for quickly determining an appropriate route to access a host at a particular IP address. As illustrated in an exemplary routing table may include a plurality of entries for each host address and or subnet address . Associated with each host subnet address is routing data which specifies how to connect to a host with a particular IP address. For example the routing data may identify the networking device e.g. such as a gateway to which TCP IP packets should be transmitted to communicate with a particular host. By way of example if host has the IP address 167.78.89.12 then the networking engine will identify this entry in the database and attempt to connect to host using Host Routing Data E. In addition as illustrated in each entry in the routing table may be associated with one of the computing device s interfaces en  and or en  .

If a specific IP address does not exist in the routing table for a host then the networking engine will determine if routing data is available for the subnet of that host. Returning to the previous example if host has the IP address 167.78.89.17 then the networking engine will clone Subnet Routing Data C for the 167.78.89 subnet and create a new entry in the routing table for host with the cloned routing data.

If a routing table entry does not exist for the IP address or subnet address of a particular host then the networking engine will utilize a default entry for one of the communication interfaces en  or en  in the routing table illustrated in the final two rows in . For example if the computing device is currently connected to the Internet via interface en  then it may use Default Routing Data A to connect to the host. Similarly if the computing device is currently connected to the Internet via interface en  then it may use Default Routing Data A to connect to the host. Once the route to the host has been determined the networking engine may then update the routing table to include a new routing entry for the host.

One limitation of current systems however is that when there are multiple possible routes to a particular host no mechanism exists for choosing a route based on networking performance. For example if host is associated with multiple IP addresses which are returned to the computing device via a DNS query the networking engine will typically just attempt to connect to the first IP address in the list returned by the DNS server assuming that there are entries in the routing table for both addresses . Under these circumstances it would be beneficial if the networking engine had the ability to monitor networking performance for the different IP addresses and or subnets and choose an IP address accordingly. Thus what is needed is an improved technique for choosing the best route to a particular host.

An apparatus and method are described for collecting and evaluating statistics for different network addresses and or subnets when establishing network connections. For example a method according to one embodiment comprises receiving a set of potential network addresses for establishing a connection to a remote host evaluating routing statistics associated with each of the potential network addresses prioritizing the set of potential network addresses based on the evaluation and initially attempting to connect to the remote host using the highest priority one or more network addresses.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the invention described below. It will be apparent however to one skilled in the art that the embodiments of the invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the embodiments of the invention.

One embodiment of the invention utilizes a networking engine which monitors statistics associated with its network connections to each host and subnet and subsequently utilizes the network statistics when establishing subsequent connections. For example when the networking engine opens a TCP socket connection to a remote host it may track networking statistics including but not limited to number of packets in out number of bytes in out number of duplicate bytes received number of out of order bytes received number of retransmitted bytes number of connection attempts number of successful connections established minimum round trip time average round trip time and average bandwidth. It should be noted however that the underlying principles of the invention are not limited to any particular set of networking statistics. These values can subsequently be evaluated either alone or in combination to determine a quality level associated with the TCP socket. Once the quality has been determined for a set of potential host addresses e.g. provided via a DNS query a prioritized list may be generated and routing entries having relatively higher priorities may be used to establish the connection. For example in one embodiment an attempt is made to connect to one or more of the highest priority of the set of host addresses first. If a connection is unsuccessful within a designated time period then the networking engine may attempt the next set of one or more highest priority host address on the list.

In addition to maintaining statistics for each individual host address one embodiment of the invention accumulates the statistics for hosts on the same subnet and generates cumulative statistics for the subnet addresses. The accumulated statistics may then be used to select a particular subnet e.g. when cloning the routing data from a particular subnet . In one embodiment the statistics are stored within the routing table used by the networking engine. Moreover in one embodiment the techniques described herein are employed with both IP version 4 IPV4 network addresses and IP version 6 IPV6 network addresses. Consequently if a computing device receives both IPV4 and IPV6 addresses in response to a DNS query it may choose the one which provides the best connectivity to the host i.e. the route with the highest quality level .

Specifically in the embodiment shown in a statistics collection module monitors the statistics for each open TCP socket used for connecting to each host e.g. such as host shown in . As is understood by those of skill in the art a TCP socket also referred to as an Internet socket constitutes a networking module for delivering incoming data packets to the appropriate local application process or thread and transmitting outgoing data packets to the appropriate remote host based on a combination of local and remote IP addresses and port numbers. Each TCP socket is mapped by the networking engine of the computing device to a communicating application process or thread . Thus in one embodiment an application opens a socket connection and implements the other networking techniques described herein by making an appropriate set of calls to an application programming interface API exposed by the networking engine which may form a portion of the operating system executed on the computing device . Exemplary API architectures are described below with respect to . It should be noted however that the underlying principles of the invention are not limited to such a configuration.

In one embodiment the statistics collection module stores the collected routing statistics for the TCP socket within the networking engine s routing table . Thus as shown in connection statistics A B C and D are maintained for IPV4 host addresses 10.0.1.26 10.0.1.5 192.168.0.12 and 192.168.0.132 respectively and connection statistics E and F are maintained for IPV6 addresses fe80 0 0 0 202 b3ff fe1e 8329 and fe80 0 0 0 202 b3ff fe1e 998 respectively. In addition the combined network statistics of the hosts are calculated and stored for each subnet. For example in Connection Statistics A and B are combined likely with other connection statistics from other hosts in the subnet and stored as Accumulated Statistics A for subnet address 10.0.1. Similarly Connection Statistics C and D are combined and stored as Accumulated Statistics B for subnet address 192.168.0 and Connection Statistics E and F are combined and stored as Accumulated Statistics C for IPV6 subnet address fe80 0 0 0 202 b3ff fe1e.

As shown in one embodiment of the invention includes a connection management module for evaluating the routing statistics when making routing decisions. In operation the networking engine may receive multiple potential IPV4 and IPV6 addresses for establishing a new connection returned in response to a DNS query e.g. www.google.com . The connection management module may then evaluate the statistics associated with each of the host IP addresses and or associated subnet addresses in the routing table to prioritize the list of IP addresses returned by the DNS query.

Various different statistics may be evaluated by the connection management module alone or in combination to determine the relative quality of the routes for each IP address and or subnet. In one particular embodiment for example the connection management module chooses the routing data for the IPV4 or IPV6 address which has the smallest average round trip time between the computing device and remote host also sometimes referred to as latency . The average round trip time is often a good indicator of the quality of the route between the computing device and the various hosts.

The connection management module may evaluate various other routing statistics when making routing decisions either alone or in combination with the round trip time including for example the number of connection attempts and the number of connections established or conversely the number of failed connection attempts. For example if a route to a host over a particular networking interface e.g. en  has a relatively small number of connections established or a high number of failed connection attempts relative to the number of connection attempts then this may indicate an unreliable connection. By contrast if a route to the same host over an alternative interface e.g. en  has a large number of connections established or a relatively low number of failed connection attempts relative to connection attempts then this may indicate a reliable connection. Consequently the connection management module may give a higher priority to the interface with the highest ratio of connections established to connection attempts for that host address or the lowest ratio of failed connection attempts to connection attempts . A variety of additional heuristics may be employed to arrive at a prioritized list of host IP address routes based on an evaluation of routing statistics.

In one embodiment if there are no entries for a particular set of IP addresses for a particular host within the routing table then the connection management module will determine if statics are available for the subnet associated with one or more of the IP addresses. As previously mentioned in one embodiment the statistics for all IP addresses associated with a particular subnet may be combined to arrive at a quality level for that subnet. For example the round trip times for all of the IP addresses associated with that subnet may be averaged to arrive at an average round trip time. Similarly the total number of connections established and connection attempts may be added together for that subnet to evaluate the subnet connection quality. The connection management module may then choose an IP address associated with a subnet providing the best overall connection quality. In such a case the networking engine will then clone the subnet routing data and create a new entry for the specific host IP address within the routing table. Once a TCP socket connection is established using that specific IP address the statistics collection module will track the routing statistics for the route associated with that specific IP address and update the routing table accordingly.

In one embodiment the routing table may have entries for some of the IP addresses returned by the DNS query but may only have subnet entries for some of the other IP addresses. In one embodiment under these conditions the accumulated statistics associated with the subnet may be compared to the statistics associated with each specific IP address. If the statistics associated with a particular subnet indicate a relatively higher quality level than the statistics associated with a specific IP address then the subnet routing data may be cloned. Cloning is a well known technique in which a subnet entry in the routing table is copied to create an entry for a specific host. Alternatively the specific IP addresses for which entries already exist in the routing table may be prioritized above the cloned subnet addresses notwithstanding the higher quality statistics associated with the subnet addresses .

Using the techniques described above if a particular host has both IPV6 and IPV4 addresses associated therewith the connection management module will select the addressing scheme which provides a relatively higher level of connection quality.

In one embodiment after prioritizing the list of IP addresses returned in response to the DNS query the connection management module may attempt to connect to more than one of the IP addresses at a time and will establish a new TCP socket using the first IP address from which a response is received. In addition in one embodiment if a TCP socket is not established with one of the initial IP addresses after a specified period of time e.g. after 150 of the estimated round trip time associated with that IP address the connection management module may attempt to establish a connection to one or more of the next IP addresses within the prioritized list while maintaining the open connection attempts to the first set of IP addresses .

As is known by those of skill in the art IPV4 and IPV6 employ different forms of DNS queries. Specifically an IPV4 DNS query is referred to as an a record query and an IPV6 DNS query is referred to as a quad a record query. As mentioned above if a particular host uses both IPV4 and IPV6 addresses then it may compare the quality of the IPV4 and IPV6 routes and choose the one that provides a relatively higher quality. In addition in one embodiment if the connection management module receives a response from one type of query but does not receive a response from the other after a designated period of time then it will proceed with the IP addresses that it has received. For example if it receives IPV4 addresses in response to the a record query but does not receive IPV6 addresses in response to the quad a record query after a specified duration or number of retries then it will proceed to prioritize the IPV4 IP addresses and establish a connection as described above.

In addition in one embodiment the connection management module will factor in the quality level of the received IP addresses when deciding whether to wait or to proceed. For example in the above example if the IPV4 addresses provide a quality level below a specified threshold then the connection management module may wait a relatively longer period of time to receive the IPV6 addresses and or may submit one or more additional quad a queries. By contrast if the IPV4 addresses provide a reasonable quality level i.e. above a specified threshold then the connection management module may proceed to prioritize the IPV4 addresses and establish a TCP connection within a relatively shorter time period.

In one embodiment all of the techniques described herein are implemented by the networking engine transparently to the application making the connection request. The application of this embodiment may simply make a call to the API exposed by the networking engine using a hostname and port e.g. www.apple.com port and the networking engine will use the above techniques to establish a TCP socket and hand the socket off to the application when the connection is complete. The networking engine may be provided with the operating system of the computing device e.g. a version of the Mac OSX or iOS operating systems . Thus application programmers do not need to understand the intricate details related to how the networking engine establishes connections to take advantage of the techniques described herein.

As shown in the routing table may include certain routes which are interface specific i.e. specific to en or en as indicated in interface column . Said another way certain routes may be scoped to a particular interface. In other instances entries for the same host subnet address may exist for multiple interfaces. In such a case the statistics collection module may store two different sets of statistics one for each interface notwithstanding the fact that the host IP address may be the same . The connection management module may then select the interface which provides the best level of quality using the techniques described herein. In one embodiment the routing table is implemented as described in the following co pending patent applications which are assigned to the assignee of the present application and which are incorporated herein by reference 

U.S. Patent Application No. 2009 0304006 filed Sep. 30 2008 entitled ROUTING TABLE BUILD ALGORITHM FOR A ROUTING TABLE THAT USES A SEARCH KEY CONSTRUCTED FROM PACKET DESTINATION ADDRESS AND OUTBOUND INTERFACE 

It should be noted however that the underlying principles of the invention are not limited to the specific implementations described in these co pending patent applications.

In one embodiment the routing table described herein is implemented in the form of a radix tree e.g. the PATRICIA trie used in BSD Unix which requires a unique key for accessing a particular entry. Thus as described in the co pending applications above in this embodiment a key may be formed using a combination of both the interface ID and the host or subnet IP address. Once again however the underlying principles of the invention are not limited to this specific implementation.

One embodiment of a method for tracking statistics for network routes to hosts is illustrated in . This embodiment may be implemented on the architecture shown in but is not limited to such an architecture. At a new TCP socket connection is opened with a host. At a specified set of statistics are tracked for the opened TCP socket. As previously mentioned this may include the round trip times and or failed successful connection attempts relative to total connection attempts. Other connection variables which may be considered include by way of example and not limitation number of packets in out number of bytes in out number of duplicate bytes received number of out of order bytes received number of retransmitted bytes and average bandwidth.

At the statistics for the IP address used for the current TCP socket are updated. This may occur continuously during the time the TCP socket remains open and or when the TCP socket is closed. At if the TCP socket is closed then at the accumulated statistics for the subnet associated with the IP address is updated. For example the round trip times for the current TCP socket may be combined with the average round trip times currently associated with the subnet to arrive at a new average. Similarly the number of successful failed connection attempts and total connection attempts may be added to those currently stored for the subnet address.

At if all responses have been received within a specified time period or if at a decision is made to proceed with the existing IP addresses then at the statistics associated with the routes for each IP address are evaluated e.g. using round trip times number of connection failures etc . As previously described if no statistics are available for a particular IP address then the statistics associated with the subnet of that IP address may be evaluated. At the potential set of network routes associated with the different IP addresses are prioritized based on the analysis of the statistics. If the subnet statistics are also not available then these IP address may be prioritized relatively lower than those IP addresses for which information is available assuming that the information indicates a potential connection of reasonable quality . At the top one or more entries from the prioritized list are selected and a connection is attempted to these IP addresses. If a connection is successful determined at then a TCP socket is opened and the process returns to where statistics are collected for the open socket . If not then if additional prioritized entries exist determined at then at connections are attempted using the next one or more entries from the list are selected. If additional entries do not exist then connections continue to be attempted using the existing entries until a timeout and or success. In the latter case the process proceeds back to as described.

Throughout the foregoing description for the purposes of explanation numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without some of these specific details. For example while the embodiments of the invention described above are implemented with program code e.g. software the underlying principles of the invention may be implemented using any combination of hardware software and or firmware. Accordingly the scope and spirit of the invention should be judged in terms of the claims below.

Some embodiments include one or more application programming interfaces APIs in an environment with calling program code interacting with other program code being called through the one or more interfaces. Various function calls messages or other types of invocations which further may include various kinds of parameters can be transferred via the APIs between the calling program and the code being called. In addition an API may provide the calling program code the ability to use data types or classes defined in the API and implemented in the called program code.

At least certain embodiments include an environment with a calling software component interacting with a called software component through an API. A method for operating through an API in this environment includes transferring one or more function calls messages other types of invocations or parameters via the API.

One or more Application Programming Interfaces APIs may be used in some embodiments. An API is an interface implemented by a program code component or hardware component hereinafter API implementing component that allows a different program code component or hardware component hereinafter API calling component to access and use one or more functions methods procedures data structures classes and or other services provided by the API implementing component. An API can define one or more parameters that are passed between the API calling component and the API implementing component.

An API allows a developer of an API calling component which may be a third party developer to leverage specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from an application. An operating system OS can have multiple APIs to allow applications running on the OS to call one or more of those APIs and a service such as a program library can have multiple APIs to allow an application that uses the service to call one or more of those APIs. An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.

In some embodiments the API implementing component may provide more than one API each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component. For example one API of an API implementing component can provide a first set of functions and can be exposed to third party developers and another API of the API implementing component can be hidden not exposed and provide a subset of the first set of functions and also provide another set of functions such as testing or debugging functions which are not in the first set of functions. In other embodiments the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.

An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations embodied for example by function or method calls exposed by the API and passes data and control information using parameters via the API calls or invocations. The API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API may not reveal how the API call accomplishes the function specified by the API call. Various API calls are transferred via the one or more application programming interfaces between the calling API calling component and an API implementing component. Transferring the API calls may include issuing initiating invoking calling receiving returning or responding to the function calls or messages in other words transferring can describe actions by either of the API calling component or the API implementing component. The function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure. A parameter can be a constant key data structure object object class variable data type pointer array list or a pointer to a function or method or another way to reference a data or other item to be passed via the API.

Furthermore data types or classes may be provided by the API and implemented by the API implementing component. Thus the API calling component may declare variables use pointers to use or instantiate constant values of such types or classes by using definitions provided in the API.

Generally an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component. By way of example the API implementing component and the API calling component may each be any one of an operating system a library a device driver an API an application program or other module it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other . API implementing components may in some cases be embodied at least in part in firmware microcode or other hardware logic. In some embodiments an API may allow a client program to use the services provided by a Software Development Kit SDK library. In other embodiments an application or other client program may use an API provided by an Application Framework. In these embodiments the application or client program may incorporate calls to functions or methods provided by the SDK and provided by the API or use data types or objects defined in the SDK and provided by the API. An Application Framework may in these embodiments provide a main event loop for a program that responds to various events defined by the Framework. The API allows the application to specify the events and the responses to the events using the Application Framework. In some implementations an API call can report to an application the capabilities or state of a hardware device including those related to aspects such as input capabilities and state output capabilities and state processing capability power state storage capacity and state communications capability etc. and the API may be implemented in part by firmware microcode or other low level logic that executes in part on the hardware component.

The API calling component may be a local component i.e. on the same data processing system as the API implementing component or a remote component i.e. on a different data processing system from the API implementing component that communicates with the API implementing component through the API over a network. It should be understood that an API implementing component may also act as an API calling component i.e. it may make API calls to an API exposed by a different API implementing component and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.

The API may allow multiple API calling components written in different programming languages to communicate with the API implementing component thus the API may include features for translating calls and returns between the API implementing component and the API calling component however the API may be implemented in terms of a specific programming language. An API calling component can in one embodiment call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug in provider and another set of APIs from another provider e.g. the provider of a software library or creator of the another set of APIs.

It will be appreciated that the API implementing component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling component . It should be understood that the API calling component may be on the same system as the API implementing component or may be located remotely and accesses the API implementing component using the API over a network. While illustrates a single API calling component interacting with the API it should be understood that other API calling components which may be written in different languages or the same language than the API calling component may use the API .

The API implementing component the API and the API calling component may be stored in a tangible machine readable storage medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a tangible machine readable storage medium includes magnetic disks optical disks random access memory e.g. DRAM read only memory flash memory devices etc.

In Software Stack an exemplary embodiment applications can make calls to Services A or B using several Service APIs and to Operating System OS using several OS APIs. Services A and B can make calls to OS using several OS APIs.

Note that the Service has two APIs one of which Service API receives calls from and returns values to Application and the other Service API receives calls from and returns values to Application . Service which can be for example a software library makes calls to and receives returned values from OS API and Service which can be for example a software library makes calls to and receives returned values from both OS API and OS API . Application makes calls to and receives returned values from OS API .

Any one of the methods described herein can be implemented on a variety of different data processing devices including general purpose computer systems special purpose computer systems etc. For example the data processing systems which may use any one of the methods described herein may include a desktop computer or a laptop computer or a tablet computer or a smart phone or a cellular telephone or a personal digital assistant PDA an embedded electronic device or a consumer electronic device. shows one example of a typical data processing system which may be used with the present invention. Note that while illustrates the various components of a data processing system such as a computer system it is not intended to represent any particular architecture or manner of interconnecting the components as such details are not germane to the present invention. It will also be appreciated that other types of data processing systems which have fewer components than shown or more components than shown in may also be used with the present invention. The data processing system of may be a Macintosh computer from Apple Inc. of Cupertino Calif. e.g. a Mac or a Macbook Pro . As shown in the data processing system includes one or more buses which serve to interconnect the various components of the system. One or more processors are coupled to the one or more buses as is known in the art. Memory may be DRAM or non volatile RAM or may be flash memory or other types of memory. This memory is coupled to the one or more buses using techniques known in the art. The data processing system can also include non volatile memory which may be a hard disk drive or a flash memory or a magnetic optical drive or magnetic memory or an optical drive or other types of memory systems which maintain data even after power is removed from the system. The non volatile memory and the memory are both coupled to the one or more buses using known interfaces and connection techniques. A display controller is coupled to the one or more buses in order to receive display data to be displayed on a display device which can display any one of the user interface features or embodiments described herein. The display device can include an integrated touch input to provide a touch screen. The data processing system can also include one or more input output I O controllers which provide interfaces for one or more I O devices such as one or more mice touch screens touch pads joysticks and other input devices including those known in the art and output devices e.g. speakers . The input output devices are coupled through one or more I O controllers as is known in the art. While shows that the non volatile memory and the memory are coupled to the one or more buses directly rather than through a network interface it will be appreciated that the data processing system may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface or wireless interface such as a wireless WiFi transceiver or a wireless cellular telephone transceiver or a combination of such transceivers. As is known in the art the one or more buses may include one or more bridges or controllers or adapters to interconnect between various buses. In one embodiment the I O controller includes a USB adapter for controlling USB peripherals and can control an Ethernet port or a wireless transceiver or combination of wireless transceivers. It will be apparent from this description that aspects of the present invention may be embodied at least in part in software. That is the techniques and methods described herein may be carried out in a data processing system in response to its processor executing a sequence of instructions contained in a tangible non transitory memory such as the memory or the non volatile memory or a combination of such memories and each of these memories is a form of a machine readable tangible storage medium. In various embodiments hardwired circuitry may be used in combination with software instructions to implement the present invention. Thus the techniques are not limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system.

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

