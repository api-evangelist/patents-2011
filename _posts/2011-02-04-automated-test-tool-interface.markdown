---

title: Automated test tool interface
abstract: An automated test tool interface is described. A developer of a reusable web component provides an interface for obtaining an accurate identification of a root element of a component and any sub elements within the root element on a web page. An automated test framework uses this interface when recording automated tests to obtain a stable identification of the element that is independent of the rendering of the component on the web page. When the automated test is played back, the test framework again uses the interface to convert the stable identification of the element to a form that is dependent on the rendering of the component on the web page. Thus, changes in the rendering of a component will no longer cause an automated test tool to fail, as element identification in the testing framework is no longer tied to the specific rendering of the web page.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924934&OS=08924934&RS=08924934
owner: Oracle International Corporation
number: 08924934
owner_city: Redwood Shores
owner_country: US
publication_date: 20110204
---
Embodiments of the present invention relate to web applications and more specifically to an automated test tool interface.

The World Wide Web the Web has undergone an extraordinary degree of evolution. What began as a simple format for exchanging documents in a platform independent manner has morphed into technology that enables access to a seemingly unlimited amount of information at any time and any place. Web pages today include active content as provided by browser side scripting languages such as JavaScript. Web pages can be updated in real time using technologies such as AJAX. Static web pages being served to users via relatively unintelligent web servers have been replaced by dynamically generated web pages that are created on the fly by the web server and which are responsive to input provided by the users.

In a modern web application development environment a developer may use one or more application development frameworks in order create a web application. A web application may consist of one or more individual web pages and the control logic that determines the flow of those web pages. The web applications developer will design an application both the visual appearance and the control logic that governs the behavior of the web application using the application development framework. The application development framework allows the developer to work at a level of abstraction that is higher than the raw HTML code. The web application may then be deployed to a web server.

Once a web application is deployed a user may access the web application using a web browser. The web application may determine which web page should be displayed to the user. In response the web server may programmatically generate the determined web page and send the page to the user s browser. The user may then interact with the web application through the displayed web pages.

Users are becoming more and more reliant on web applications in their day to day life. Because of this reliance users are becoming less and less tolerant of web applications that do not perform properly. One of the best ways to ensure that a web application performs properly is through rigorous testing of the application prior to release to the end user. A testing regime may be developed wherein testers develop a test plan which tests all of the functionality of the web application. If any errors i.e. bugs in the operation of the web application are discovered during testing those errors can be resolved prior to release to the end user.

Although the need for thorough testing of web applications is clear the testing phase can be extremely costly. A human tester may need to execute the test plan against a web application many times as new errors are discovered and resolved. Each of these iterations requires the time of the tester and can delay deployment of a new web application or of new features in an existing application. In order to alleviate the costs of testing automated test frameworks have been created. Selenium provided by SeleniumHQ.org is an open source example of one such testing framework.

Using a testing framework a tester may record the execution of the test plan. If the test plan needs to be executed again the testing framework can replay the previously recorded execution of the test plan. As a result of such automation the amount of human effort and thus cost in testing can be reduced. Unfortunately currently available automated test frameworks are quite brittle in that minor changes made to a web page as a result of bug fixes can cause the recorded test plan to become invalid and the execution of the test plan to fail.

An automated test tool interface is described. A developer of a reusable web component provides an interface for obtaining an accurate identification of a root element of a component and any sub elements within the root element on a web page. An automated test framework uses this interface when recording automated tests to obtain a stable identification of the element that is independent of the rendering of the component on the web page. When the automated test is played back the test framework again uses the interface to convert the stable identification of the element to a form that is dependent on the rendering of the component on the web page. Thus changes in the rendering of a component will no longer cause an automated test tool to fail as element identification in the testing framework is no longer tied to the specific rendering of the web page.

In one embodiment a non transitory computer readable storage medium storing a plurality of instructions for controlling a processor is provided. The plurality of instructions comprise instructions that cause the processor to provide a Document Object Model independent representation of an element of a component. The plurality of instructions may further comprise instructions that cause the processor to provide a Document Object Model dependent representation of the element of the component. In one aspect the instructions that cause the processor to provide the Document Object Model independent representation of the element of the component further comprise instructions that cause the processor to receive from a testing system a first identifier that identifies the element of the component that is being tested instructions that cause the processor to determine based on the first identifier a second identifier associated with the element and instructions that cause the processor to send the second identifier to the test system. In a further aspect the instructions that cause the processor to provide the Document Object Model dependent representation of the element of the component further comprise instructions that cause the processor to receive from the testing system the second identifier instructions that cause the processor to determine based on the second identifier a third identifier associated with the element and instructions that cause the processor to send the third identifier to the testing system.

In another embodiment a method is provided. The method may comprise providing with a computer a Document Object Model independent representation of an element of a component and providing with the computer a Document Object Model dependent representation of the element of the component. In one aspect providing the Document Object Model independent representation of the element of the component further comprises receiving from a testing system a first identifier that identifies the element of the component that is being tested determining based on the first identifier a second identifier associated with the element and sending the second identifier to the test system. In a further aspect providing the Document Object Model dependent representation of the element of the component further comprises receiving from the testing system the second identifier determining based on the second identifier a third identifier associated with the element and sending the third identifier to the testing system.

In yet another embodiment a system is provided. The system may comprise a processor and a memory coupled to the processor. The memory contains a set of instructions which when executed by the processor cause the processor to provide a Document Object Model independent representation of an element of a component and provide a Document Object Model dependent representation of the element of the component. In one aspect the set of instructions that cause the processor to provide the Document Object Model independent representation of the element of the component further comprises instructions that cause the processor to receive from a testing system a first identifier that identifies the element of the component that is being tested determine based on the first identifier a second identifier associated with the element and send the second identifier to the test system. In a further aspect the set of instructions that cause the processor to provide the Document Object Model dependent representation of the element of the component further comprises instructions that cause the processor to receive from the testing system the second identifier determine based on the second identifier a third identifier associated with the element and send the third identifier to the testing system.

A further understanding of the nature and advantages of the embodiments disclosed herein can be realized by reference to the remaining portions of the specification and the attached drawings.

In the following description for the purposes of explanation specific details are set forth in order to provide a thorough understanding of the embodiments of the invention. However it will be apparent that the invention may be practiced without these specific details.

Embodiments of the present invention provide an automated test tool interface. The automated test tool interface may be used by an automated test framework when recording tests executed on a web application. The recorded tests are not dependent on a specific rendering of a web page within the web application. In one embodiment techniques are provided that allow an automated testing framework to utilize the automated test tool interface to record tests that continue to work even if the rendering of the web page changes from when the test is recorded to when the test is played back.

The system as depicted in can conceptually be divided into a design environment a deployment environment and a user environment . Each of these environments may comprise one or more computing systems that are used in implementations of embodiments of the invention. A more detailed description of computing systems is discussed with reference to . The design environment may be used to design and develop web components and package the web components into a library of components. Web pages that use the library of web components may be assembled and grouped into applications. The deployment environment may be used to make the web applications available to users. The user environment may allow users to access web applications from the deployment environment . The web pages displayed to the user are rendered by the deployment environment at run time using the library of components and are displayed to the user within the user environment when the user requests a web page.

A web component also referred to as a component may provide some defined functionality that is independent of any application that uses the component. For example a simple date entry component may include functionality to ensure that only valid dates may be entered. The component can then be used by any application that requires a date to be entered and the application is ensured that only valid dates will be accepted. A component may also include functionality that allows the component to communicate with other components or web servers.

The design environment may comprise a component development system . The component development system may include a processor in communication with a non transitory computer readable medium CRM . The CRM may store computer instructions that when executed by the processor provide a component developer with a computer environment for developing components .

A component may be a building block that is used alone or with other components to create one or more web applications. For example a component could be as simple as a text entry box or could be more complex such as a component for producing maps and driving directions. The component development system provides the component developer with an environment to design the visual appearance of a component as well as develop the underlying computer code that provides the functionality of the component . Once the component developer has completed the design and development of a component the component may be stored in a component database . The component development system also provides the ability for the component developer to retrieve previously stored components and modify the components as desired.

The component database may store information for multiple components and be referred to as a component library. The component database may contain any number of components that can be used by any number of web applications. There are numerous application development frameworks that provide component libraries for use in developing web applications. Once such component library is the Application Developer Framework ADF Faces component library provided by Oracle Corporation of Redwood Shores Calif.

In one embodiment the functionality of a component is extended by providing an automated test tool interface . Systems such as testing systems may provide testing frameworks that include automated test tools . Automated test tools may provide the ability to create robust and reusable automated tests of web applications. The automated test tools may use the automated test tool interface to ensure the tests function correctly even if the component or a web application that uses the component changes. The automated test tool interface is included within the functionality of each of the components stored in the component database . The automated test tool interface will be discussed in further detail below.

A web application also referred to as an application provides some desired functionality to a user and interacts with the user through one or more web pages. The application developer may specify the visual appearance of the web pages that make up an application as well as the control logic that determines when each of those web pages is sent to the user. The application developer may use components from a component library when designing the web application.

The system may also include an application development system . The application development system may include a processor in communication with a non transitory computer readable medium CRM . The CRM may store computer instructions that when executed by the processor provide an application developer with a computer environment for developing web applications.

For example the CRM of the application development system may contain instructions that provide an application developer with a development environment that may be used to design and develop a web application. An application may be designed and developed using one or more components. The application developer may select components from the component database to use in the application. In some cases the application developer may be able to customize or configure the components as per an application s requirement. The application development environment is described in further detail with respect to .

Embodiments of the present invention provide an automated test tool interface that is transparent to the application developer. Because the automated test tool interface is transparent to the application developer the application developer is relieved of any concerns related to the details of automated tests that may be performed on the application. The application developer s efforts can be focused on the application as opposed to testing of the application.

The deployment environment is the environment in which an application developer makes an application available for use. The deployment environment may comprise one or more web servers which send the web pages of an application to an end user. The web servers in the deployment environment may generate the needed web pages as defined by the application and send those pages to the end user.

The deployment environment may comprise multiple deployment systems. For example a test web server and a production web server . In general the functionality of each of these systems is very similar with the main difference being the intended end user. The test web server may comprise a processor and a CRM . Likewise the production web server may comprise a processor and a CRM . The CRMs may contain computer instructions that when executed by the processor of the respective deployment system causes the processor to make applications available to end users.

The test web server and production web server may also include databases that generally mirror the components stored in the component database . Thus the components used by application developers are also available within the deployment environment. An application developer may deploy an application to one of the deployment systems. The typical end user of an application deployed to a test web server will be an application tester who is tasked with ensuring the functionality of the application is adequate. The typical end user of an application deployed to a production web server will be a user who desires to use the functionality of the application whatever that functionality might be.

The user environment is the environment in which users interact with the deployment environment in order to access an application. The servers in the deployment environment will typically receive a request from the user environment indicating that the user wishes to utilize a web application. The servers in the deployment environment will provide web pages that are generated as specified by the developer of the application. The deployment environment may receive input from the user environment through the application and generate appropriate web page output as specified by the application developer. The web pages generated in the deployment environment are typically generated using the components that are stored in the respective databases .

The user environment may comprise testing systems and end user systems . Both of these systems may contain a processor and CRM . The respective CRMs may contain instructions that when executed by the processor cause the processor to allow the end user or test system user to access web applications in the deployment environment. Typically the CRMs will contain instructions that implement a web browser also know more simply as a browser to interact with the web pages produced by the application through the deployment environment.

An end user is typically a user that desires to utilize the functionality of an application. The end user is typically not involved in the design development or testing of components or applications. An end user may use an end user system to access an application that has been deployed to production web server . There are various different ways in which the end user can access the application. In one embodiment the end user may use a browser executing on end user system to connect to the production server that hosts the application to be accessed. The production server generates web pages and provides them to the end user in accordance with the design specified by the application developer.

A tester may use a test system to test web applications. Test system may include testing frameworks such as Selenium that provide automated test tools . As mentioned above the automated test tools can include the tools that allow for recording and playback of tests of web applications. In one embodiment an automated test tool interface is provided by a component and is used by the automated test tools to provide improved functionality to the testers for recording user actions commonly performed in the web application by an end user. The user actions may be recorded once and then played back as many times as desired. As mentioned above a tester is responsible for developing a test plan s to check the functionality of a web application. As errors often referred to as bugs are found those errors are reported to the component developer or the application developer depending on where the error is found.

The application or component developer then locates the error often referred to as debugging and corrects the error. Once the error is corrected the application may be deployed again and the tester repeats the test plan to ensure that all bugs have been resolved and no new bugs have been introduced. The cycle continues until the web application is sufficiently bug free for deployment to a production web server such that the application may be utilized by end users.

As described above the deploy test debug cycle may repeat numerous times. The test user is generally repeating the exact same test plan in each test phase and as such the repetitive nature of the test cycle calls out for an automated solution. Testing system may embody a test framework that includes automated test tools that allow a test user to record the particular inputs provided to the application for later playback. For example a test plan may state that a particular element of a component on a web page of an application should be clicked and particular data should be input to the element. The result of the input whether it be the input is rejected or a different page is displayed is verified as matching the expected result. If the result does not match the expected result it may indicate the presence of a bug.

The next time the test plan described above needs to be run the testing framework may allow the previously recorded test to be played back. The testing framework may programmatically recreate the input that was provided by the user when the test was recorded and compare the results with what is expected. Again if the results do not match what is expected there may be bug.

Although existing testing frameworks may provide the ability to record and playback tests the capabilities are somewhat limited. Typically testing frameworks record tests that are highly dependent on how the web pages of an application are rendered within a browser that is being used to record the test. For example the testing framework may rely on the DOM representation of the web page when recording tests on that web page. Unfortunately as part of the deploy test debug cycle the DOM representation of a web page may change as bugs are found and corrected. The DOM also may change as changes are made to the components that make up an application and the application itself even if those changes are not directly related to bug correction. If the recorded tests are dependent on the DOM representation of the specific web page under test a test that has been recorded for a particular DOM representation may no longer work if the specific DOM of the web page has changed.

Embodiments of the invention advantageously provide an automated test tool interface that allows for a testing framework to record tests that continue to work even if the DOM of the web page of an application that was used to record the test changes when the test is being played back. The automated test tool interface allows the test framework to provide to the automated test tool interface a DOM dependent identifier associated with a particular test action being recorded. The automated test tool interface than returns an identifier referred to as a stable locator that is associated with the DOM dependent identifier but that is not dependent on the DOM. The testing framework through the automated test tools then records the DOM independent identifier.

When the time to play back the test arrives the test framework again interacts with the automated test tool interface and provides the DOM independent identifier. The automated test tool interface then returns an identifier that is once again DOM dependent. The test framework through the automated test tools can then use this DOM dependent identifier to run the recorded test. The automated test tool interface masks any changes to the DOM that were caused by bug fixes or other changes to components or applications. The operation of the automated test tool interface is described in further detail below.

Although the system described in depicts individual computers for component development and application development it should be understood that both of these functions may be executed on a single computer. Likewise deployment environment depicts a separate test web server and production web server . Again these two functions may actually reside on a single computer. The same applies to the user environment . It should be understood that is merely exemplary. Embodiments of the invention contemplate any number of computers that execute any number of the functions described above.

A high level description of an embodiment of the invention may begin with a component developer using a component development system to develop a web component . The component developer may provide an automated test tool interface in the form of an application programming interface API to the component . The automated test tool interface also referred to as the API when given an identifier that represents an element of the component as rendered by a web browser may return another identifier that is not dependent on how the component is rendered. The API may be published such that it is accessible for external systems.

An application developer may use the component when creating a web application. A test engineer may use a testing framework that includes automated test tools that provides the ability to record the testers input to test the application. The test engineer may execute and record a test plan on the web application to ensure the web application functions correctly. The recorded tests in the testing framework may be dependent on the specific rendering of a web page in a browser. The testing framework may use the published API to convert the recorded test into a format that is not dependent on the specific rendering of the web page in a browser. The tester may possibly at a later time rerun the tests by playing back the previously recorded tests. While playing back the tests the test framework through the automated test tools may again access the published API of the web component to convert the recorded tests back to a form that is again dependent on the specific rendering of the web page in a browser.

In so doing the testing framework is no longer dependent on a specific rendering of a web page in order to record or playback tests. Testing frameworks are made more robust because tests can be recorded in a format that is independent of how the web page is rendered. Even if the rendering of a web page changes from when the test is initially recorded to when it is played back embodiments of the invention allow for the recorded test to continue working without modification.

The exemplary component development environment depicted in may be broken down into several areas of function. Component design window may provide the component developer with a window or windows wherein the component developer may design the visual representation of a component. Associated with component design window may be a component visualization window . Component visualization window may be used to display to the component developer what a component will look like when it is actually rendered by a web browser. Along with component visualization window the component development environment may also provide a Document Object Model DOM representation window . DOM representation window may display the Document Object Model representation of the component being designed as it would exist in a browser that is displaying the component.

A component behavior window may also be provided. In component behavior window the component developer may specify the functionality of the component being designed and provide computer code that when executed provides that functionality. Finally the component development environment may provide a test automation support window that allows the component developer to define the automated test tool interface as used in embodiments of the invention.

As shown in a component developer may be developing a simple web component that takes in two inputs a birth date and a name and provides a submit button such that the inputs received using the component i.e. birth date and name are provided to the web server upon selecting the submit button. The component described in will for purposes of this description be referred to as the name date component. The component developer may use the component design window to specify the elements of the component. The elements of a component may include standard HTML elements such as input forms image tags and the like. Furthermore the elements of a component can also be other components such that more complex components can be created from more basic components. In the example of the component developer may specify that the name date component contains a form element with an id set to a default value and no action specified. It may not be necessary for the component developer to specify the id of the form component or the actions performed when the form is submitted as this functionality will be added by the application developer which will be discussed with reference to .

The component developer may continue to specify all of the elements of the component such as the text strings Your Birth date Your Name . The component developer may also specify input elements for receiving input. Here two input elements are defined with a type of text. The component developer may also include a submit element which allows input gathered in the form to be sent to a web server. Although component design window is depicted as a text environment this is simply for purposes of explanation and is not intended to be limiting. Some component development environments may be graphical in which a component developer drags and drops individual elements or other components into the component design window .

The component visualization window may display the name date component as it would appear when rendered in a web browser. Here the text strings and are displayed as text and respectively. The input elements and are displayed as input boxes and . Finally the submit element is displayed as a submit button . The purpose of the input visualization window is to allow the developer to see what the component being designed will look like when it is actually used in a web application.

The component developer may also provide behavior for the component in a component behavior window . The component behavior window is where the code that provides the functionality of the component may be provided. As shown in the example of the component developer has specified two pieces of functionality for the general behavior of the component. A VerifyValidDate function has been specified to ensure that only valid dates are entered in the birth date input element of the component and a verifyNameContainsLetters function has been specified to ensure that only letters are included in the name input element. Any other functionality provided by the component may also be specified in the component behavior window .

DOM representation window may display a DOM representation of the name date component as it would be rendered by a web browser. Each element as described in component design window and component visualization window will have an equivalent representation in the DOM representation. For simplicity of explanation only the input and submit elements will be described but it should be understood that every element of a component has an equivalent DOM representation. Here input elements visualized as input boxes are represented in the DOM as INPUT . Likewise the submit element visualized as a submit button is represented in the DOM as another INPUT . The DOM representation window may be provided as a convenience to the component developer to visualize how the component will be rendered in the DOM of a browser. However this convenience is not required especially for a sophisticated developer who fully understands the DOM representation of the component.

Test automation support window is where the bulk of the functionality of embodiments of the invention may be defined. Test automation support window is where the automated test tool interface i.e. the API is defined. As mentioned above existing test frameworks generally record tests based on the DOM representation of component of web page of an application that is being tested. However the DOM representation is not necessarily static and can change as changes are made to the underlying components and application.

Embodiments of the present invention overcome the problem of an non static DOM through the automated test tool interface. The use of the automated test tool interface will become more clear below but for purposes of the component development environment it should be understood that each component may provide two pieces of functionality. These two pieces of functionality may be published as an API that is accessible by the testing framework.

First each component should provide an interface that given a DOM representation of an element of the component will return an identifier that is not dependent on the DOM representation. This identifier may be referred to as a stable locator or a stable locator string. Essentially a stable locator is an identifier that can be used to identify a particular element of a component and does not change even if the DOM representation changes.

As shown in the component developer may provide one or more functions to convert a DOM representation of an element of the component into a stable locator. For example the second element of the DOM representation of the name date component described in is associated with the birth date input element . Because the component developer designed the component the component developer is in the best position to map DOM representations to the element of the component. Here the component developer provides an interface function that given the second DOM element will return the stable locator date. Similarly the API will return the stable locator name for the fourth element and submit for the sixth element . Although the DOM representation is being described in terms of an integer number this is for purposes of simplicity of explanation. In operation the DOM representation of an element may be more complex such as a representation based on an XPATH locator.

Secondly each component should provide an interface that given a stable locator will return the DOM representation of that element. As shown in the name date component developer may provide one or more functions to convert a stable locator representation of an element of the component into the DOM representation of that component. The use of these two pieces of functionality will become more clear as the example continues.

The automated test tool interface will typically only be used when an application or the components that make up the application are deployed to a test web server. Thus the code corresponding to the automated test tool interface may only be included in the application when the application is deployed to a test web server. This allows for a smaller amount of code to be deployed to production web servers as the automated test tool interface need not be included. However some embodiments of the invention will always include the automated test tool interface in all deployments.

Application development environment may include a application design window . The application developer may drag and drop components from a component library into the application design window . The application developer may customize the selected components in component customization window . Application visualization window may allow the application developer to visualize the web pages that will be produced by the application. In addition the application development environment will also allow the application developer to specify the logic that will control the application. The application logic may define the flow of web pages and any business logic that controls the functions of the application.

In the example of the application developer is creating an application that utilizes two components the name date component and an address component . The name date component may have been created as was described with reference to . The application developer may have selected these two components from a component library . As shown component library may contain any number of additional components. For example component library may allow the application developer to select any of the components that exist in component database .

The application developer may also customize and configure the components in a component customization window . In this window the application developer may customize the component to the extent allowed for by the component developer. For example the component developer may allow the application developer to specify certain characteristics of the component such as color . In addition the application developer may specify the actions that are to be performed when a component is utilized. The application development environment may also allow the application developer to specify certain identifying characteristics of a component such as a component ID .

As described above while developing a component the component developer need not be aware of how the component will be used in an application. Accordingly some of the component definition tasks may be delegated to the application developer. Likewise the application developer may wish to delegate some of the component definition tasks to the deployment environment. As shown in the application developer has specified the ID attribute of the name date component to be an auto select field thus delegating the section of a component ID to the deployment environment.

Application development environment may also include application visualization window which allows the application developer to view what the web pages of the application will look like when viewed within a browser. As shown the name date component will appear in a browser just as it appeared during the design of the component with reference to . Similarly the address component will also be displayed according to that component s definition.

Although not shown the application developer may also specify the control logic behind the operation of the application. The application developer may specify page flows and business logic that controls those page flows. What should be understood here is that the application developer does not need to have any knowledge of the automated test tool interface. Embodiments of the invention hide the details of the automated test tool interface from the application developer.

The application tester may create a test plan in order to test the functionality of the web application. The test plan may include tests for checking the functionality of individual pages of the web application. For example a portion of a test plan for the web page depicted in may be 

In order to execute this portion of the test plan the application tester may use a testing framework. One such exemplary framework is Selenium. The testing framework may provide functionality that aids in developing and executing test plans. For example the testing framework may provide the tester with the ability to record the testers mouse clicks and keystrokes when executing the test plan. The framework may also allow the tester to playback previously recorded test plans thus relieving the tester from having to manually execute the test plan again.

Turning to the exemplary application web page of the tester may start the recording process. The tester may then click input box as specified in the test plan. The tester may then enter an invalid date as specified in the test plan and verify that the invalid date is rejected. For purposes of the description of it will be assumed that the test plan is successful and that an invalid date is actually rejected.

When recording the execution of the test plan the testing framework will record the tester s mouse clicks and input text. Typically the test framework will record the test plan using element locators that are dependent on the DOM of the rendered web page. For purposes of explanation an exemplary visualization of the DOM of the web page in is shown. It should be understood that that the exemplary DOM visualization is not actually displayed to the tester but rather exists in the internals of the web browser.

The testing framework will typically record the tester s actions using a locator such as an XPATH locator that is dependent on the DOM and therein lies one of the deficiencies of existing testing frameworks. For example in the test plan described above the tester first clicks on the input box associated with the birth date element. As was described in the previous figures the name date component is defined as a form . The first input element of the form is the input box for entering the birth date. Thus existing testing framework may record the test using an XPATH locator that is similar to html body form 0 element 1 . This locator can be described as in the html document in the body section in the first form section the second input element Note in the description element numbering starts at 0 . The testing framework may also record that the element was clicked and the keystrokes that make up the invalid date that was entered by the tester. The testing framework may also record the results of the test.

As should be clear the recorded test absent embodiments of the present invention is highly dependent on how the web page is rendered in the DOM . For example if the name date component is altered such that the birth date input element is no longer the second element in the DOM the recorded test may break. If there is any change to the DOM the recorded test may break. A change to the DOM will be described further with respect to .

Embodiments of the present invention do not use element locators that are dependent on the DOM representation of a web page. Rather than using a locator such as an XPATH locator embodiments of the invention use the API that was published by the component developer to retrieve a locator that is independent of the DOM representation. For example in an embodiment of the invention the testing framework will utilize the API described in and send to that API the DOM dependent representation of the element that was clicked. The API will then return a stable locator to the testing framework where the stable locator is independent of the DOM. As described above the stable locator associated with the second element of the name date component is identified as date. The testing framework may then record this stable locator as opposed to a DOM dependent locator. It should be noted that the format of the stable locator described above is merely exemplary and is intended for ease of explanation. The stable locator can be in any suitable format. What should be understood is that the stable locator regardless of the format identifies an element of a component independent of the DOM representation. The use of the stable locator will be described in further detail with respect to .

As described above the component developer is in the best position to know how the component will be represented in the DOM because the component developer has full control over the component. When the component developer changes the order of the input elements the automated test tool interface can be changed as well. For example given the changes to the component described above the component developer will use the test automation support window to alter the published API. In this case the first input box is the second element in the DOM representation and is now associated with the name stable locator. Likewise the birth date input box is now the fourth element in the DOM and the API is altered to reflect that the stable locator associated with the fourth element is the date locator .

The API is also modified such that when the stable locator is input the proper DOM element is returned. As shown in the example the date stable locator is modified to return the fourth DOM element while the name stable locator is modified to return the second DOM element. As mentioned above although DOM representations are being described as simple integers this is for purposes of simplicity of explanation and is not intended to be limiting. The utilization of these changes will become more clear with respect to .

As should be clear the movement of the input elements within the DOM would cause prior recorded tests to break absent embodiments of the present invention. The previously described XPATH locator html body form 0 element 1 still refers to the second input element of the form however the second input element is no longer the birth date element. Thus when the testing framework replays the recorded test the element referred to will be incorrect. The testing framework will attempt to input keystrokes representing an invalid date into a filed that is now the name. At minimum this is a problem because it bears no relationship to the original test plan. Also the expected results no longer make sense as the input is no longer related to the originally recorded test plan.

Embodiments of the present invention advantageously avoid this problem through the use of the stable locators. As mentioned above rather than recording the DOM dependent representation of an element embodiments of the invention utilize an API of the component to retrieve a stable locator. When playing back previously recorded tests the testing framework again makes use of the API to retrieve the DOM representation of the element referred to by the stable locator. In this case when playing back the recorded test the testing framework will access the component API and pass the stable locator date. The component through the API that was modified as described in receives the stable locator date. As specified by the component developer the date element is now the fourth element as represented by the DOM thus an identifier indicating the fourth element is returned.

The testing framework then utilizes the returned DOM dependent identifier to playback the previously recorded test. Thus the testing framework plays back the recorded keystrokes and directs the keystrokes to the fourth input element which is now the birth date element. Tests recorded using the original DOM representation no longer break when the DOM changes. Rather an identifier that remains stable regardless of DOM representation is recorded. Thus changes to the DOM are transparent to the testing framework and the identifiers that are used in recording test more directly relate to the functionality being tested rather than the particular DOM representation of a component.

The process then may continue to step wherein based on the first identifier a second identifier that is associated with the element is determined. As described the testing framework may utilize an API published by the component to determine a stable locator that is not dependent on the DOM representation of the component. The process may then continue on to step wherein the second identifier is returned to the testing system. As described the second identifier may be the stable locator.

The process may then continue on to step . In step the second identifier may be received from a testing system. As described above the second identifier may be the stable locator. Although step occurs after step this does not imply that step occurs immediately after step . Rather there can be a delay between step and step in which changes to the component may occur. For example step may occur during the test recording phase of the test plan while step occurs during recorded test playback.

From the second identifier a third identifier associated with the element is determined in step . As described above this third identifier may be determined based on the API published by the component. The third identifier may again be a representation of the element that is DOM dependent. At step the third identifier which is DOM dependent may be sent to the testing system.

At step a published interface of the component may be accessed to receive based on the first identifier a second identifier that is independent of the rendering of the component. For example the second identifier may be a stable locator that is associated with the component and is independent of the DOM representation of the component. At step the second identifier may be stored by the testing framework. At step actions performed on the element may be stored. For example this may include mouse clicks and keystrokes that are directed to the element. At step the expected behavior of the element that are in response to the actions performed on the element are recorded. For example this may be the response of the application to the input provided in step .

At step the stored actions performed on the element that is the test input may be retrieved. At step the expected behavior of the element that is in response to the actions performed on the element are retrieved. Again this may be the response of the element to the previously recorded test input. At step the published interface of the component is accessed and a third identifier that is dependent on the rendering of the component is retrieved. The third identifier is retrieved based on the second identifier. As described the second identifier may be the stable locator and an API of the component may be accessed to retrieve a third identifier which is a DOM dependent representation of the element identified by the stable locator.

At step the previously retrieved stored actions may be applied to the element as identified by the third identifier. For example the element that is identified by the third identifier is located in the DOM. The actions are then applied to the located DOM element. At step the element behavior is compared with the previously recorded expected behavior. If the behavior matches the process moves on to step wherein the test is considered to have passed. If the behavior does not match the process moves on to step wherein the test fails.

As shown in computer system comprises hardware elements that may be electrically coupled via a bus . The hardware elements may include one or more central processing units CPUs one or more input devices e.g. a mouse a keyboard etc. and one or more output devices e.g. a display device a printer etc. . Computer system may also include one or more storage devices . By way of example storage device s may include devices such as disk drives optical storage devices and solid state storage devices such as a random access memory RAM and or a read only memory ROM which can be programmable flash updateable and or the like. Storage devices may include non transitory computer readable storage medium.

Computer system may additionally include a non transitory computer readable storage media reader a communications subsystem e.g. a modem a network card wireless or wired an infra red communication device etc. and working memory which may include RAM and ROM devices as described above. In some embodiments computer system may also include a processing acceleration unit which can include a digital signal processor DSP a special purpose processor and or the like.

Computer readable storage media reader can further be connected to a non transitory computer readable storage medium together and optionally in combination with storage device s comprehensively representing remote local fixed and or removable storage devices plus storage media for temporarily and or more permanently containing computer readable information.

Communications system may permit data to be exchanged with a network or other computer systems. The network may be any type of network that can support data communications using any of a variety of commercially available protocols including without limitation TCP IP SNA IPX AppleTalk and the like. Merely by way of example network may be a local area network LAN such as an Ethernet network a Token Ring network and or the like a wide area network a virtual network including without limitation a virtual private network VPN the Internet an intranet an extranet a public switched telephone network PSTN an infra red network a wireless network e.g. a network operating under any of the IEEE 802.11 suite of protocols the Bluetooth protocol known in the art and or any other wireless protocol and or any combination of these and or other networks. Various different communication protocols may be used.

Computer system may also comprise software elements shown as being currently located within working memory including an operating system and or other code such as an application program which may be a client application Web browser Web server mid tier application RDBMS testing framework etc. . It should be appreciated that alternative embodiments of computer system may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

In one set of embodiments the techniques described herein may be implemented as program code or instructions executable by a computer system such as a computer system and may be stored on a non transitory computer or machine readable storage media. Machine readable storage media may include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as machine readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store or transmit the desired information and which can be accessed by a computer.

Although specific embodiments of the invention have been described various modifications alterations alternative constructions and equivalents are also encompassed within the scope of the invention. Embodiments of the present invention are not restricted to operation within certain specific data processing environments but are free to operate within a plurality of data processing environments. Additionally although embodiments of the present invention have been described using a particular series of transactions and steps it should be apparent to those skilled in the art that the scope of the present invention is not limited to the described series of transactions and steps.

Further while embodiments of the present invention have been described using a particular combination of hardware and software it should be recognized that other combinations of hardware and software are also within the scope of the present invention. Embodiments of the present invention may be implemented only in hardware or only in software or using combinations thereof.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that additions subtractions deletions and other modifications and changes may be made thereunto without departing from the broader spirit and scope as set forth in the claims.

