---

title: Memory management for object oriented applications during runtime
abstract: Memory management for object oriented applications during run time includes loading an object oriented application into a computer memory. The object oriented application includes a plurality of nodes in a classification tree, the nodes including key value pairs. The nodes are aggregated in the classification tree by a computer. The aggregating includes eliminating redundant keys and creating a composite node. The composite node is loaded into the computer memory. The plurality of nodes in the classification tree are removed from the computer memory in response to loading the composite node into the computer memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08453130&OS=08453130&RS=08453130
owner: International Business Machines Corporation
number: 08453130
owner_city: Armonk
owner_country: US
publication_date: 20110209
---
The present invention relates to object oriented computer applications and more specifically to reducing the amount of memory required by object oriented computer applications during runtime.

Java an objected oriented programming language is a robust language that provides mechanisms by which complex applications can easily be translated into different languages e.g. French English Java and all Java based trademarks and logos are trademarks or registered trademarks of Oracle and or its affiliates . Language translation is achieved in Java through a type of Java resource called a resource bundle which is sometimes backed by class definitions or by Java property files. Class definitions and Java property files contain lists of key value pairs where the values are translated into different languages.

While the implementation of the resource bundle has allowed complex applications to be readily translated into many languages this ease of translation has come with a significant cost to the application and its runtime characteristics. Namely the amount of memory used by a translated application is far more than is actually needed in order to operate. As such any large translated Java application requires considerable amounts of computer memory just to load all of the translated strings. Considerable amounts of memory are used because the Java framework handles translations by loading multiple sets of files for each resource bundle with each file containing a different level of translation specificity e.g. resource English England resource English resource default . In this example where the values in the key value pairs are phrases for any given translated phrase there are three instances of the keys and the translated phrases are loaded and live in memory for effectively the life of the application once the bundle has been accessed. As the translation is multiplied across a number of bundles in a complex application a very large amount of Java live heap bytes or permanent memory for class definitions if the resource bundles were compiled to class files is allocated just to hold the strings e.g. the key value pairs .

In addition in most cases up to ninety percent of the strings are never used so the memory is effectively wasted storing unused strings. This retention of strings is inefficient and bloats the memory requirements of Java applications. When products are stacked i.e. products are built on top of other products the problem multiplies. A typical stacked application may waste hundreds of megabytes of memory storing strings that are never accessed.

Embodiments of this memory management are methods systems and computer program products that include loading an object oriented application into a computer memory. The object oriented application includes a plurality of nodes in a classification tree the nodes including key value pairs. The nodes are aggregated in the classification tree by a computer. The aggregating includes eliminating redundant keys and creating a composite node. The composite node is loaded into the computer memory. The plurality of nodes in the classification tree are removed from the computer memory in response to loading the composite node into the computer memory.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with the advantages and the features refer to the description and to the drawings.

Embodiments described herein reduce the amount of computer memory required during runtime by object oriented applications that have been coded to support language translation. An example of an application that supports language translation is one that outputs messages in different languages e.g. French English etc. based on user and or installation settings. Different languages are supported by the same source code by using a list of key value pairs that vary depending on the target language. Embodiments described herein use Java resource bundles to store hierarchies of key value pairs for different target languages. The hierarchies are aggregated to eliminate duplicate keys and thus fewer key value pairs are stored in computer memory also referred to herein as memory . Further embodiments described herein store only the key value pairs that have been accessed within a programmable time period and or with a programmable frequency e.g. as specified by a programmable threshold . This also leads to a reduced storage requirement during application runtime.

Referring to a relationship between resource bundles and flattened resource bundles in accordance with an embodiment is generally shown. The resource bundles and flattened resource bundles are used to translate keys that are specified by an application program into Japanese Japan or English United States US phrases. Thus the key value pairs in the resource bundles include a key as specified by an application program and a value a phrase in the target language . In an embodiment the target language is specified by a programmable system and or user parameter. The resource bundles are used to generate the flattened resource bundles . A resource bundle is a class that together with any parent class es forms a classification tree made up of nodes in a hierarchical relationship that contain in this example key value pairs. Nodes in the resource bundle and any parent classes are aggregated and redundancies between the nodes are eliminated e.g. by following an inheritance chain to create a flattened resource bundle that has a single entry for each key. The flattened resource bundle is an example of a composite node. In one embodiment only those key value pairs also referred to herein as strings that have been recently accessed are stored in cache memory . In another embodiment all of the key value pairs in a flattened resource bundle such as flattened resource bundle are stored in the cache memory .

The resource bundles shown in include an English US resource bundle a Japanese Japan resource bundle an English resource bundle and a default language resource bundle . A flattening process also referred to herein more generally as aggregating is implemented to flatten the resource bundles into an English US flattened resource bundle and a Japanese Japan flattened resource bundle . The common key values for the resource bundles are included in the flattened resource bundles thus reducing the amount of memory required by eliminating the storing of repetitive key values in memory. As such the English US flattened resource bundle includes the most specific key values Key  value en US Key  value en US and Key  value en US from the English US resource bundle thereby eliminating the less specific keys from the English resource bundle and the default language resource bundle . The English US flattened resource bundle also includes the less specific key values Key  value en from the English resource bundle and Key  value from the default language resource bundle .

Similarly the Japanese Japan flattened resource bundle includes the most specific key values Key  value ja JP and Key  value ja JP and thus eliminates the less specific keys from the default language resource bundle . In addition the Japanese Japan flattened resource bundle also includes the less specific keys from the resource bundle . However the flattened resource bundle includes the less specific key values Key  value Key  value and Key  value from default language resource bundle . In this manner the flattening process reduces repetitive key value pairs from being stored in memory.

In addition a flattened resource bundle cache memory may be utilized to further reduce the amount of space required for storage of key value pairs in memory. In the example shown in the flattened resource bundle cache memory includes Key  value en US which was last used at a specified time e.g. lastUsed 16 Oct. 2010 08 14 34 and Key  value en which was last used at another specified time e.g. lastUsed 12 Oct. 2010 18 27 16 . In an embodiment the flattened resource bundle cache memory retains the keys most frequently accessed and or most recently accessed to further reduce the number of keys retained in memory.

The present exemplary embodiment is specific to a Java application runtime environment however it will be appreciated that embodiments are not limited to Java applications and that they may be implemented in any object oriented application environment. In addition the present exemplary embodiment is specific to language translation however it will be appreciated that embodiments are not limited to language translation and that embodiments may be utilized by any object oriented application that uses keys as placeholders for values to be inserted during application runtime.

Referring to a memory management process is generally shown. The memory management process is performed on a Java virtual machine in a Java runtime environment. A request to load a key located in a resource bundle is received at block . A determination about whether a flattened resource bundle exists is made at block . If the flattened resource bundle does not exist then block is performed and a flattened resource bundle is generated and processing continues at block . If the flattened resource bundle does exist as determined at block then processing continues at block . The key and associated value is read from the flattened resource bundle at block . The key value pair is stored in a cache memory at block . The key value pair is kept in the cache memory until the application has completed execution. In another embodiment the key value pair is kept in the cache memory until a programmable time window has elapsed so that only key value pairs that have been accessed within the time window are stored in cache memory.

For each language translation of a Java application or Java product a new version of an initial resource bundle is created. For example if MyResource is created to store all English text a similarly named file is created to store all French text. Resource bundles use a naming convention that distinguishes the potentially numerous versions of essentially the same bundle. Each bundle name includes a base name and an optional locale identifier. Together these two pieces uniquely identify a bundle in a package. As such in the above example the French version of the resources is named MyResource fr FR and the Canadian French version is named MyResource fr CA. In addition appending the locale name to the base name of the bundle effectively links the bundle s usage to a specific locale. When a bundle is requested using ResourceBundle.getBundle MyResource a getBundle method appends the default locale identifier to the base name and loads the appropriate bundle. If the locale is fr CA then a call to ResourceBundle.getBundle MyResource will load the MyResource fr CA bundle. A user can also pass a specific locale. For example if a user wants to explicitly load a Japanese bundle the user can call ResourceBundle.getBundle MyResource new Locale ja JP . As such when Java has translated text Java looks up a resource bundle for language and locale. If a specific language and locale is unavailable Java falls back to a default e.g. English and United States . As Java is looking through the resource bundles each of the resource bundles are loaded and retained in memory even if Java determines that the language and locales are not needed.

The exemplary embodiments described herein do not load all language sets for a given resource bundle. For example if a key has a value in the top most translated language set then the lesser and default translated values of the key are not used and therefore are not loaded into memory. When a load request is made for a bundle the ResourceBundle loader flattens the resource bundles in the manner described herein.

The memory management described herein may be utilized as a drop in replacement for the ResourceBundle implementation used by Java applications. The drop in replacement is an application programming interface API compatible implementation that does not retain the complete set of language keys and values in memory at the same time thereby reducing the load of resource bundles in memory. As such all the bundles are flattened down into one bundle at load time thereby leaving only one unique key value pair in memory which reduces the footprint of a translated bundle in memory. For example for each translated bundle there is the language and locale which may be French and Canada as described herein. In an embodiment the default language can be English. As such the Java resource bundle loads the complete set of the French bundle the complete set of Canadian bundle and the complete set of the English bundle into memory. The drop in replacement flattens the three bundles into one bundle leaving only one unique key value pairs in memory. In this example the exemplary drop in replacement at minimum reduces the footprint of a translated bundle by two thirds. When this example is scaled that across a large application with many bundles the live bytes savings becomes significant. Automatic bundle flattening can therefore reduce the live memory usage without user intervention.

Exemplary embodiments of this memory management do not retain keys in memory that are not being used. The Java resource bundle only retains a loaded X number of keys that have actually been accessed at least once. Conventionally the Java resource bundle just loads all strings and keeps them in memory which is wasteful especially when up to ninety percent of the keys are never used or displayed. It has been estimated that on average less than ten percent of the keys most resource bundles typically implement are accessed in an application. As such large amounts of memory are used for keys and values that are never accessed. As described herein caching is implemented with the resource bundle to only keep in memory the keys that are currently being actively used. As such keys that are infrequently or never accessed are removed from memory. Small performance penalties can occur when a new key or one that had been discarded is requested again but the memory savings for removing infrequently accessed keys dominate the performance penalty to reload the key and its value.

Known bad keys are cached and marked so that repeated requests for a key that is not in the cache does not trigger a search. In addition duplicate values across resource bundles in memory can be removed from memory. The values of keys being loaded are analyzed for situations where values are identical for keys in multiple bundles. When located only one instance of that string value is retained in memory and the other instances are removed from memory for yet more memory savings.

The embodiments described herein can also negate performance penalties from on demand loading through startup and runtime profiling. Java runtime can determine what keys are accessed early and often then the bundle loader can be instructed to pre populate its initial caches with those values on startup negating the need to do one by one searching. As such not only are benefits of reduced memory footprint realized but also benefits of having needed preloaded values being already available negating search times.

Referring to a system for memory management of a translated Java application is generally shown. The methods performed by this system can be implemented in software e.g. firmware hardware or a combination thereof. In exemplary embodiments the methods described herein are implemented in software as an executable program that is executed by a special or general purpose digital computer such as a personal computer workstation minicomputer or mainframe computer. The system therefore includes general purpose computer .

In terms of hardware architecture as shown in the computer includes a processor memory coupled to a memory controller and one or more input and or output I O devices or peripherals that are communicatively coupled via a local input output controller . The input output controller is implemented by one or more buses or other wired or wireless connections as is known in the art. The input output controller may have additional elements which are omitted for simplicity such as controllers buffers caches drivers repeaters and receivers to enable communications. Further the local interface may include address control and or data connections to enable appropriate communications among the aforementioned components.

The processor is a hardware device for executing software particularly the software stored in memory . The processor is implemented by any custom made or commercially available processor a central processing unit CPU an auxiliary processor among several processors associated with the computer a semiconductor based microprocessor in the form of a microchip or chip set a macroprocessor or generally any device for executing software instructions.

The memory is implemented by any one or a combination of volatile memory elements e.g. random access memory RAM such as DRAM SRAM SDRAM etc. and nonvolatile memory elements e.g. ROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM programmable read only memory PROM tape compact disc read only memory CD ROM disk diskette cartridge cassette or the like etc. . Moreover the memory may incorporate electronic magnetic optical and or other types of storage media. Note that the memory can have a distributed architecture where various components are situated remote from one another but can be accessed by the processor . In an embodiment the memory includes a cache memory.

The software in memory includes one or more separate programs each of which comprises an ordered listing of executable instructions for implementing logical functions. The software stored in the memory includes the Java application memory management methods described herein in accordance with exemplary embodiments and a suitable operating system OS . The operating system essentially controls the execution of other computer programs such as the Java application memory management systems and methods as described herein and provides scheduling input output control file and data management memory management and communication control and related services.

The Java application memory management methods described herein are in the form of a source program executable program object code script or any other entity comprising a set of instructions to be performed. When a source program then the program needs to be translated via a compiler assembler interpreter or the like which may or may not be included within the memory so as to operate properly in connection with the OS . Furthermore the Java application memory management methods can be written as an object oriented programming language which has classes of data and methods or a procedure programming language which has routines subroutines and or functions. When written in an object oriented programming language the resulting object oriented application when loaded into the memory includes a plurality of nodes in a classification tree.

A conventional keyboard and mouse can be coupled to the input output controller . Other output devices such as the I O devices may include input devices for example but not limited to a printer a scanner microphone and the like. Finally the I O devices may further include devices that communicate both inputs and outputs for instance but not limited to a network interface card NIC or modulator demodulator for accessing other files devices systems or a network a radio frequency RF or other transceiver a telephonic interface a bridge a router and the like. The system can further include a display controller coupled to a display . The system can further include a network interface for coupling to a network . The network can be an IP based network for communication between the computer and any external server client and the like via a broadband connection. The network transmits and receives data between the computer and external systems. In exemplary embodiments network is a managed IP network administered by a service provider. The network may be implemented in a wireless fashion e.g. using wireless protocols and technologies such as WiFi WiMax etc. The network can also be a packet switched network such as a local area network LAN wide area network WAN metropolitan area network Internet network or other similar type of network environment. The network may also be a fixed wireless network a personal area network PAN a virtual private network VPN intranet or other suitable network system and includes equipment for receiving and transmitting signals. In an embodiment the network is implemented by a combination of two or more different networks.

If the computer is a PC workstation intelligent device or the like the software in the memory may further include a basic input output system BIOS omitted for simplicity . The BIOS is a set of essential software routines that initialize and test hardware at startup start the OS and support the transfer of data among the hardware devices. The BIOS is stored in ROM so that the BIOS can be executed when the computer is activated.

When the computer is in operation the processor is configured to execute software stored within the memory to communicate data to and from the memory and to generally control operations of the computer pursuant to the software. The Java application memory management methods described herein and the OS in whole or in part but typically the latter are read by the processor perhaps buffered within the processor and then executed.

When the embodiments described herein are implemented in software the program instructions are stored on any computer readable medium such as storage for use by or in connection with any computer related system or method.

Technical effects and benefits include the ability to implement an application having base source code that can be adapted to different languages without requiring a rewrite or a high overhead in terms of memory usage during runtime. Embodiments described herein provide further benefits by providing memory management that reduces the live heap bytes and class bytes of translated Java applications. Memory footprints are reduced by flattening resource bundles at load time and by reducing multiple keys and value pairs to a single key value pair in memory. In addition infrequently accessed keys are removed from memory and memory is pre populated with known frequently used keys to further reduce memory footprint and search times for keys.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

In exemplary embodiments where the Java application memory management methods are implemented in hardware the Java application memory management methods described herein can implemented with any or a combination of the following technologies which are each well known in the art a discrete logic circuit s having logic gates for implementing logic functions upon data signals an application specific integrated circuit ASIC having appropriate combinational logic gates a programmable gate array s PGA a field programmable gate array FPGA etc.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one ore more other features integers steps operations element components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated

The flow diagrams depicted herein are just one example. There may be many variations to this diagram or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the preferred embodiment to the invention had been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

