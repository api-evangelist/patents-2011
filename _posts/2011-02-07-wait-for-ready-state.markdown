---

title: Wait for ready state
abstract: Automation of actions on a server system (e.g., web server, FTP server) is facilitated by a server system that is ready for actions to be performed upon it. Because there are scenarios when a server system is not in a state to be acted upon (e.g., web page changed due to navigation, script execution, asynchronous request through dynamic web extensions), an automated action needs to be synchronized to when then server system is in a ready state for that action to occur. A wait-for-ready state can be initiated that detects when a server system is ready for a next action.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08489714&OS=08489714&RS=08489714
owner: Microsoft Corporation
number: 08489714
owner_city: Redmond
owner_country: US
publication_date: 20110207
---
This application is a continuation of U.S. patent application Ser. No. 12 055 325 filed on Mar. 26 2008 entitled WAIT FOR READY STATE incorporated by reference herein.

In computing environments one may wish to automate actions on a server system e.g. a web server or FTP server for a variety of reasons e.g. for testing debugging efficient use of resources . In a web page environment for example a user may wish to record their actions for later automated playback e.g. for use as a single button control . In this example it would be desirable that playback account for all actions and system states that occurred while the user was recording. However some actions and system states that occur behind the scenes may not be properly recorded therefore the automation playback may fail or produce improper results.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key factors or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In a computing environment if one wishes to create an automation of actions and system states on a server system it must account for all actions and system states otherwise the automation may fail or produce erroneous results. Often there are actions e.g. loading a web page and system states e.g. state of a client side web browser occurring behind the scenes when an overt action is initiated on a server system. For example when one selects e.g. an action that clicks on a hyperlink on a first webpage a server system must retrieve and then load a corresponding web page. However if a user then selects a hyperlink on a newly loaded second web page which navigates to another web page an automation process would need to know that the first web page had loaded e.g. a system state before selecting the hyperlink on the second webpage. If the automation attempted to select the hyperlink on the second web page before it had completely loaded the automation may fail or if another incorrect hyperlink was present that was within the selection criteria of the automation the incorrect hyperlink may be selected. Additionally for example there are web applications that utilize update panels on web pages which can be updated without updating the entire page. Therefore if a recorded action included updating one of these update panels and selecting an item in a newly updated panel an automation process may not wait for the update e.g. a system state and may thus undesirably select an item in the panel before it had been updated.

As provided herein one or more techniques and or systems for performing automated recorded actions on a server system using request monitoring are designed to monitor requests that are generated when an action is initiated on a server system and maintain a wait for ready state until all request have been completed thereby synchronizing a next recorded action with a server system state that is ready to perform that action. For example this technique may monitor request objects generated by a dynamic web application e.g. AJAX objects and determine when they are complete so that when a next action is performed the system is ready. It is to be appreciated that the terms record or recorded as used herein are not meant to be narrowly construed. That is the actions need not be strictly limited to recorded actions per se. For example such actions may also generally comprise user interface actions that may not necessarily be recorded.

To facilitate at least some of the same a recorded action is initiated and a status of generated requests is monitored. Monitoring comprises applying a monitoring interface to generated request objects such that a state change of the request objects can be tracked. Monitoring further comprises determining when the request objects state is completed which indicates that a request from the action has been completed. Monitoring the status of requests continues until all of the requests are determined to be in a completed state which indicates that an action on a server system has been completed. Therefore once the action is determined to be complete a next recorded action can be initiated with little concern that a system is not ready to be acted upon.

To the accomplishment of the foregoing and related ends the following description and annexed drawings set forth certain illustrative aspects and implementations. These are indicative of but a few of the various ways in which one or more aspects may be employed. Other aspects advantages and novel features of the disclosure will become apparent from the following detailed description when considered in conjunction with the annexed drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

In a computing environment automation of recorded actions on server system e.g. webpage server or file transfer server necessitates that an automation process account for states in which the server system may not be ready for a particular automated action. For example there are times when a system may not be in a state to be queried upon. When a sequence of actions to be automated includes selecting e.g. clicking on hyperlinks on two separate web pages after a first hyperlink is selected for example if the automation process attempts to select the next hyperlink before the first webpage is loaded the automation process may fail or an incorrect hyperlink may be selected.

Further there are times when server system based applications may not be in a state to be queried upon. For example web pages running web based applications can be changed when navigating to a new page if there is a script execution that modifies content for example or if an asynchronous request occurs from an interactive web function e.g. AJAX . As an example automated actions may include after navigating to a webpage clicking on a table s sorting criteria in an ASP.Net AJAX update panel on the webpage clicking on new sorting criteria after initial sort results are returned and clicking on a result from newly returned results. Automation of the recorded actions may need to account for time it may take to load the table in the ASP.Net AJAX update panel and time to return sorting results from each of the two sort selections. In this example if the automation process attempted to select a sorting criteria before the webpage had loaded the table or the ASP.Net AJAX update panel the attempted sort selection may fail. Further if the automation process attempts to select a sort criteria before results from the first sort selection are returned the process may yield incorrect results and the last part of the automation process the selecting of a result would likely return incorrect information.

Failures of an automation process of recorded actions on a system may be characterized as synchronization problems. For example a failure may result from a server or client state not being synchronized to timing an occurrence of a recorded action. One technique for automating actions on a system for example may include determining whether the system being automated is in an appropriate state to be acted upon by the recorded action. This may include implementing a wait for ready state for each recorded action which waits until the system is in an appropriate state to be acted upon before proceeding with the recorded action. For example the wait for ready state may determine that no web page navigations are occurring or that no downloads are in progress from a server system by tracking web browser events. Further the wait for ready state may determine that an HTML document is in a completed state by tracking web browser events and DOM document events. However while a web browser or DOM document control may raise an event that can be tracked there are times when no such events are raised for actions upon a server system for example when web applications allow for panels on a webpage to be dynamically updated without having to update the entire web page.

An alternate technique as provided herein for automatically performing recorded actions on a server system using request monitoring e.g. wait for ready is illustrated in exemplary method of . The exemplary method starts at and involves initiating a recorded action at . Once an action is initiated a status of request s e.g. one or more generated by the action is monitored at . Monitoring request s involves applying a monitoring interface to a request object at tracking state changes of the request object at and determining when the request object is at a completed state at . A monitoring cycle of at is undertaken for each request object generated by each request e.g. one or more . Once the request object s have been determined to be in a completed state for all request s e.g. one or more at the exemplary method performs a next recorded action at . After performing a next recorded action the exemplary method ends at .

As an example of one embodiment of the technique described herein if a user wished to determine whether a newly created email account is working they may create an email message in that account send the message to themselves then select and delete the message once it arrives. This process may be recorded and automated for a web based email system that uses AJAX based web applications on a webpage for its email system for example. AJAX based web applications allow for panels on a webpage to be dynamically updated without having to update the entire web page. AJAX requests e.g. made through an XMLHttpRequest object do not raise web browser control events so the AJAX requests cannot be tracked using those events. Therefore a custom monitoring interface is used to detect state changes in the AJAX request objects. As request calls and response sendbacks are monitored the state of the AJAX request can be determined by the monitoring interface. Once the state of the request object reaches completed e.g. loaded and the state of all the requests for an action are completed a next recorded action may safely occur.

In this example if a send action is initiated by the email system in order to process the select mail action e.g. a next recorded action the sent message needs to arrive in the inbox. Therefore all requests associated with the send action e.g. sending the message receiving the message displaying the message in the inbox need to be completed before the select message action is initiated. Further each AJAX request object e.g. XMLHttpRequest object needs to be completed for each request from the send message action. Additionally in this example if a request object times out e.g. if a response is not received from a server system within a specified amount of time the state of the AJAX request is set to completed e.g. loaded . Also if the send message action times out e.g. all action requests not completed within a specified amount of time the select message action e.g. a next recorded action is performed on the webpage.

An example of one configuration of exemplary method in is illustrated in by exemplary method . Exemplary method begins at and involves one or more requests being generated by a recorded action at . An application programming interface sends request objects from the one or more requests through a monitoring interface at . The monitoring interface detects whether a state change has occurred for a request object at . If the request object s state has changed the state of the request object is tracked at . At the method determines whether the state of the request object is completed. If the state of the request object is completed the exemplary method determines whether the state of all e.g. one or more request objects is completed at . If the state of all the request objects is completed the exemplary method performs a next recorded action on a server at . However if the state of the request object is not completed at the method determines whether the request object has timed out e.g. not completed within a specified amount of time at . If the request object has not timed out the exemplary method continues to track the state of the request object at . On the other hand if the request object has timed out at the method sets the state of the request object to completed at . If the state of all request objects is not completed at the exemplary method determines whether the action has timed out at . If the action has not timed out the exemplary method continues to track the state of the request object s at . However if the action has timed out at the exemplary method performs a next recorded action on the server at . Having performed the next recorded action at the exemplary method ends at .

In one aspect one can monitor requests of an action by monitoring when application programming interface API request objects e.g. AJAX request objects are generated and when they are completed . In this aspect a custom object adapter pattern e.g. object wrapper can be generated and applied when an API request object is generated. By applying a custom object adapter pattern to the request object all calls on the request object e.g. open and send calls will run through and be detected by the custom object adapter pattern. Further state changes can be detected because the request object s properties e.g. when onreadystatechange specifies a reference to an event handler at a state change will also run through the custom object adapter pattern. Also the request object s state e.g. loaded can be detected when a response is returned from a server system through the custom object adapter pattern to the request object. In this aspect when an open and send call is detected for a request object a monitoring counter may increment by one. Therefore for each request object that is generated and sent the monitoring counter may increment by one. As responses are received from the server system and the request object s state is set to completed e.g. loaded the monitoring counter may decrement by one. Therefore for each request object whose state is set to completed the monitoring counter may be decremented by one. As such the monitoring counter may increase for each request and may decrease when each request is finished. Therefore when the monitoring counter reaches zero all requests for an action may have been completed and the server system may be ready for a next recorded action.

An example of one configuration for automatically performing recorded actions by monitoring requests using an incremental monitoring counter is illustrated in . The exemplary method illustrated in starts at and an API request is made at . The API request involves creating a request object at creating a custom object adapter pattern e.g. object wrapper at and an open and send being called on the request object at . Once an open and send is called on the request object as detected by the custom object adapter pattern the exemplary method begins monitoring the request object at . To monitor a request object a monitoring counter is incremented at . At the method detects state changes in the request object. If the state of the request object has not changed to completed at the method continues to monitor state changes at . However if the request object s state is completed at the monitoring counter is decremented at . The monitoring counter is tracked at and if the counter has not reached zero at the method returns to to continue monitoring the counter. Otherwise if the counter has reached zero at a next recorded action is performed at . Having performed the next recorded action the method ends at .

Another embodiment which may include one or more of the variations described above involves a computer readable medium comprising processor executable instructions configured to apply one or more of the techniques presented herein. An exemplary computer readable medium that may be devised in these ways is illustrated in wherein the implementation comprises a computer readable medium e.g. a CD R DVD R or a platter of a hard disk drive on which is encoded computer readable data . This computer readable data in turn comprises a set of computer instructions configured to operate according to the principles set forth herein. In one such embodiment the processor executable instructions may be configured to perform a method for automatically performing recorded actions on a server system using request monitoring e.g. wait for ready such as the method of for example. The order in which some or all of the operations are described should not be construed as to imply that these operations are necessarily order dependent. Alternative ordering will be appreciated by one skilled in the art having the benefit of this description. Further it will be understood that not all operations are necessarily present in each embodiment provided herein. Many such computer readable media may be devised by those of ordinary skill in the art that are configured to operate in accordance with the techniques presented herein.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

As used in this application the terms component module system interface and the like are generally intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a controller and the controller can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

Furthermore the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although not required embodiments are described in the general context of computer readable instructions being executed by one or more computing devices. Computer readable instructions may be distributed via computer readable media discussed below . Computer readable instructions may be implemented as program modules such as functions objects Application Programming Interfaces APIs data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the computer readable instructions may be combined or distributed as desired in various environments.

In other embodiments device may include additional features and or functionality. For example device may also include additional storage e.g. removable and or non removable including but not limited to magnetic storage optical storage and the like. Such additional storage is illustrated in by storage . In one embodiment computer readable instructions to implement one or more embodiments provided herein may be in storage . Storage may also store other computer readable instructions to implement an operating system an application program and the like. Computer readable instructions may be loaded in memory for execution by processing unit for example.

The term computer readable media as used herein includes computer storage media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions or other data. Memory and storage are examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM Digital Versatile Disks DVDs or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by device . Any such computer storage media may be part of device .

Device may also include communication connection s that allows device to communicate with other devices. Communication connection s may include but is not limited to a modem a Network Interface Card NIC an integrated network interface a radio frequency transmitter receiver an infrared port a USB connection or other interfaces for connecting computing device to other computing devices. Communication connection s may include a wired connection or a wireless connection. Communication connection s may transmit and or receive communication media.

The term computer readable media may include communication media. Communication media typically embodies computer readable instructions or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal may include a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal.

Device may include input device s such as keyboard mouse pen voice input device touch input device infrared cameras video input devices and or any other input device. Output device s such as one or more displays speakers printers and or any other output device may also be included in device . Input device s and output device s may be connected to device via a wired connection wireless connection or any combination thereof. In one embodiment an input device or an output device from another computing device may be used as input device s or output device s for computing device .

Components of computing device may be connected by various interconnects such as a bus. Such interconnects may include a Peripheral Component Interconnect PCI such as PCI Express a Universal Serial Bus USB firewire IEEE 8394 an optical bus structure and the like. In another embodiment components of computing device may be interconnected by a network. For example memory may be comprised of multiple physical memory units located in different physical locations interconnected by a network.

Those skilled in the art will realize that storage devices utilized to store computer readable instructions may be distributed across a network. For example a computing device accessible via network may store computer readable instructions to implement one or more embodiments provided herein. Computing device may access computing device and download a part or all of the computer readable instructions for execution. Alternatively computing device may download pieces of the computer readable instructions as needed or some instructions may be executed at computing device and some at computing device .

Moreover the word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as advantageous over other aspects or designs. Rather use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application the term or is intended to mean an inclusive or rather than an exclusive or . That is unless specified otherwise or clear from context X employs A or B is intended to mean any of the natural inclusive permutations. That is if X employs A X employs B or X employs both A and B then X employs A or B is satisfied under any of the foregoing instances. In addition the articles a and an as used in this application and the appended claims may generally be construed to mean one or more unless specified otherwise or clear from context to be directed to a singular form.

Also although the disclosure has been shown and described with respect to one or more implementations equivalent alterations and modifications will occur to others skilled in the art based upon a reading and understanding of this specification and the annexed drawings. The disclosure includes all such modifications and alterations and is limited only by the scope of the following claims. In particular regard to the various functions performed by the above described components e.g. elements resources etc. the terms used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the disclosure. In addition while a particular feature of the disclosure may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes having has with or variants thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising. 

