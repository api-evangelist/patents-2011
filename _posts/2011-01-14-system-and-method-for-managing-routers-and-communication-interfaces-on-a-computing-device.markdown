---

title: System and method for managing routers and communication interfaces on a computing device
abstract: An apparatus and method are described for managing router and communication interfaces. For example, one embodiment of a method implemented on a computing device having a plurality of communication interfaces comprises: receiving a plurality of router advertisement packets indicating a preference level of each of a plurality of routers, each of the plurality of routers reachable through one of the communication interfaces on the computing device; designating one of the communication interfaces as a primary interface and the remainder of the communication interfaces as scoped interfaces; specifying a primary router for the primary interface based on a preference level associated with the primary router, the primary router selected from a group of all of the routers reachable through the primary interface; and specifying a default router for each of the scoped interfaces based on a preference level of each default router, each default router selected from a group of all of the routers reachable through its scoped interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08873527&OS=08873527&RS=08873527
owner: Apple Inc.
number: 08873527
owner_city: Cupertino
owner_country: US
publication_date: 20110114
---
This invention relates generally to the field of data networks. More particularly the invention relates to an improved system and method for managing routers and communication interfaces on a computing device.

As illustrated the routers may connect the computing device to local hosts on private local area networks LANs . In addition the routers may route packets between the computing device and remote hosts through gateway devices coupled wide area networks such as the public Internet. Communication over the various networks requires the computing device and routers to implement a common network protocol such as the TCP IP protocol. Consequently as illustrated in the computing device includes a networking engine for implementing a network protocol stack . To communicate over the network an application typically makes calls to the networking engine and in response the networking stack selects an appropriate interface and router through which to establish network connections.

There are currently two different forms of the TCP IP networking protocol referred to as Internet Protocol Version 4 IPV4 and Internet Protocol Version 6 IPV6 . IPV6 is a version of the Internet Protocol IP suite that is designed to succeed Internet Protocol version 4 IPV4 which is currently in widespread use across the Internet. IPV6 is largely incompatible with IPV4 utilizing a different addressing space and connection protocol. One difference between IPV6 and IPV4 which is particularly relevant to the present application is that routers on an IPV6 network designate a router preference which must be obeyed by the IPV6 networking stack . Specifically each IPV6 router transmits a router advertisement packet to the IPV6 networking stack which contains network layer configuration parameters including a router preference level of high medium or low. To be compatible with the IPV6 protocol the IPV6 networking stack must make a default IPV6 router selection based on the preference levels specified by each of the routers . Thus if one particular router species a high preference level while all of the other routers specify medium or low preference levels the default router selection must be set to router .

One problem with this configuration is that in many cases the user of the computing device may want to communicate over an interface which is not associated with the selected default router . For example if the user has access to both a Wifi network through interface and a cellular network through interface the user may want to connect over the WiFi network given the cost and speed of the cellular network. However if the default router is associated with the cellular interface then the networking engine will automatically connect using the cellular interface . In addition certain applications require access to particular private networks. For example host on private network may represent a data service such as visual voicemail offered by the user s cellular service provider. Consequently all applications which rely on this data service must have access to private network which may not be the case in current implementations. As such what is needed is a more flexible and intelligent manner to select interfaces and routers on an IPV6 network.

An apparatus and method are described for managing router and communication interfaces. For example one embodiment of a method implemented on a computing device having a plurality of communication interfaces comprises receiving a plurality of router advertisement packets indicating a preference level of each of a plurality of routers each of the plurality of routers reachable through one of the communication interfaces on the computing device designating one of the communication interfaces as a primary interface and the remainder of the communication interfaces as scoped interfaces specifying a primary router for the primary interface based on a preference level associated with the primary router the primary router selected from a group of all of the routers reachable through the primary interface and specifying a default router for each of the scoped interfaces based on a preference level of each default router each default router selected from a group of all of the routers reachable through its scoped interface.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the invention described below. It will be apparent however to one skilled in the art that the embodiments of the invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the embodiments of the invention.

One embodiment of the invention associates a desired primary router with a primary non scoped communication interface notwithstanding the IPV6 preference levels specified by the IPV6 protocol. As described in detail below in one embodiment a linked list of router IDs e.g. comprising router IP addresses and associated preference levels is maintained by an IPV6 networking engine. When a primary non scoped interface is specified e.g. by networking program code such as a networking application the desired primary non scoped default router is set to the reachable router on that interface link with the highest router preference. Other routers having the highest preference levels for their respective default interfaces are also selected. When there is more than one router on a particular interface link the one with the highest router preference will be installed either as scoped or primary non scoped route entry depending on whether the interface is scoped or primary non scoped. If all of the routers share the same preference value the one installed will be the static if one exists or the first encountered reachable router i.e. static is prioritized above dynamic for routers with the same preference level on the same communication link . If the Default Router List is empty it is assumed that all destinations are on the active communication link.

As illustrated in a computing device in accordance with one embodiment of the invention comprises a networking engine which may include both an IPV4 networking stack and an IPV6 networking stack . The networking engine may be accessible by applications through a networking application programming interface API . For example in one embodiment an application establishes network connections by making an appropriate set of calls to the API . In response the networking engine performs the operations necessary for opening a TCP socket connection with a remote host via one of the interfaces . In one embodiment the networking API and networking engine form a portion of the operating system executed on the computing device e.g. such as a version of the Mac OSX operating system . Exemplary API architectures are described below with respect to . It should be noted however that the underlying principles of the invention are not limited to any particular API architecture.

In one embodiment the IPV4 networking stack maintains an IPV4 routing table for quickly determining an appropriate route to access a host at a particular IPV4 address. In one embodiment the IPV4 networking stack manages the routing table as described in the following co pending patent applications which are assigned to the assignee of the present application and which are incorporated herein by reference 

While the focus of the present application is the IPV6 networking stack an exemplary IPV4 routing table is shown in to illustrate some of the techniques described in the above co pending applications which may be used in combination with the IPV6 techniques described herein. Specifically unlike prior routing systems the routing table described in the co pending applications allows multiple default interface entries some of which are scoped to particular routing destinations and one of which is unscoped also referred to as the primary interface . For example in interfaces en0 en2 and en3 are scoped and interface en1 is unscoped. In operation the lookup key used to access the routing table for scoped entries is performed using both the destination IP address and the interface index. Consequently using scoped routing each entry in the routing table may be instantiated on a per interface basis. For example in routing entries 10.0.1.26 and 10.0.1.5 are scoped to both the en1 and en0 interfaces. Thus a lookup in the table using 10.0.1.26 and 10.0.1.5 with the interface index for en1 will identify host routing data A and B respectively a lookup in the table using 10.0.1.26 and 10.0.1.5 with the interface index for en0 will identify host routing data C and D respectively. The unscoped interface en1 will be used when a particular interface index is not specified i.e. only a host address is specified . These and other features of the IPV4 stack and the IPV4 routing table are described in detail in the co pending applications.

Embodiments of the IPV6 stack will now be described. As an initial matter however it should be noted that the underlying principles of the invention do not require any implementation of the IPV4 stack. Thus while the IPV4 stack is described above because it may be implemented on the computing device concurrently with the IPV6 stack the IPV4 implementation is not required for complying with the underlying principles of the invention. In addition the IPV4 stack may in some cases utilize a different default interface than the IPV6 stack.

Returning to in one embodiment the IPV6 stack includes a default router management module for managing the routing entries within an IPV6 routing table using the techniques described herein. Specifically in one embodiment the default router management module identifies the primary interface within the IPV6 routing table and associates the primary interface with a default router which is the router reachable through that interface with the highest preference level. In one embodiment if a first router with a relatively high preference level is not reachable but a second router with a relatively lower preference level is reachable then the router with the relatively lower preference level will be selected as the default i.e. the highest reachable router is selected . If none of the routers are currently reachable the one with the highest preference is installed anyway and used as the default router for that interface.

In the particular example illustrated in routers and associated with scoped interface en0 have preference levels of medium and high respectively e.g. as determined by a router advertisement packet transmitted by each router over interface en0 . Routers and associated with primary interface en1 have a preference level of low and router has a preference of medium. Router associated with scoped interface en2 has a preference level of medium and router associated with scoped interface en3 has a preference level of low. Thus in this example once the primary interface of en1 is identified router is selected as the default router because it is has the highest preference level of all routers associated with primary interface en1 i.e. routers and .

Consequently as illustrated in in the IPV6 routing table flags may be set to identify en1 as the primary unscoped interface and to identify en0 en2 and en3 as scoped interfaces. Routing data identifies router as the default router for the primary interface en1 router as the default router for scoped interface en0 i.e. because it has a higher preference level than router router as the default router for interface en2 and router as the default router for interface en3.

As illustrated in in one embodiment the default router management module arranges all routers from which it receives RA packets into a linked list in order from high to low based on preference level. In one embodiment each router is identified in the list by its IP address and preference value. Thus router is at the top of the list because it has a preference value of high routers and are next on the list because they have preference values of medium and routers and are last on the list with preference values of low. In operation to identify the default router to be associated with the primary interface the default router management module searches through the list starting at the top until it identifies the highest preference router associated with the primary interface. It also searches through the list starting at the top to identify the default routers for each scoped interface. It then updates the IPV6 routing table accordingly.

In one embodiment if two or more routers with the same preference level are all associated with the same interface then the default router management module may choose the one which is statically configured if one exists and or the first encountered reachable router. Dynamic configuration involves processing RA packets from the routers as described herein. However the interface may also be statically configured such that its address prefix and default router entries are derived from a static configuration. For example on a Mac OSX platform this may happens when a user chooses a Manual method of configuration and enters the addresses themselves.

One embodiment of a method for updating the linked list and potentially identifying a new default router for an interface is illustrated in . At a new router advertisement packet is received and in response the default router management module searches the linked list . If an entry does not exist in the list determined at then at a new entry is created and inserted into the list in sorted order. For example if the preference level of the new router is medium then it will be inserted in the medium preference band e.g. adjacent to router in . At the current default router s are selected for their respective interfaces based on the current list. In one embodiment if the new router does not have a higher preference level than any existing routers associated with the same interface as the new router then no changes are made to the routing table. If however the new router has a higher preference level than the other routers associated with the interface then the new router will be assigned as the default router for that interface which may be the primary interface or one of the scoped interfaces .

If an entry for the router already exists in the list then at a determination is made as to whether the preference level for the router has changed. If so then the existing entry is removed at and the process returns to i.e. where the router is reinserted using the new preference level . If the preference is the same and the router is scoped i.e. associated with a scoped interface determined at then the process ends. If the preference is the same and the router is unscoped i.e. associated with the primary interface then at the entry is removed and the process returns to wherein the router is reinserted .

Using the techniques described above an application may issue a bind command to bind a socket to any scoped or unscoped interface e.g. via the networking API . Thus in contrast to prior IPV6 implementations in which the application must follow the routing table which is under the complete control of the IPV6 router preference levels the embodiments of the invention allow certain applications to designate certain interfaces and routers. This is beneficial for example if an application requires access to a particular private network which is only accessible via a specific set of routers. For example in if en2 is a wireless cellular interface and application is a visual voicemail application which requires access to a particular visual voicemail service which is only accessible via the cellular router then the application may bind the TCP socket to this particular interface. A routing table entry will be entered ensure scoped routing with respect to this interface socket combination. The outgoing IPV6 packets will then be transmitted out of the correct interface. In addition using the present techniques a particular router may be associated with a primary interface which will take priority over other interfaces and routers when a particular interface is not specified in the routing table. These and other benefits of the embodiments of the invention described herein will be readily apparent to those of ordinary skill in the art.

In one embodiment a single integrated routing table may be used in place of the separate routing tables shown in . In this embodiment the routing table may be accessed and managed by both the IPV6 stack and the IPV4 stack . Each routing table described herein may be implemented in the form of a radix tree e.g. the PATRICIA trie used in BSD Unix which requires a unique key for accessing a particular entry. Thus as described in the co pending applications above the key used for accessing the routing tables may be formed using a combination of both the interface ID and the host or subnet IP address. Once again however the underlying principles of the invention are not limited to these specific implementations.

Throughout the foregoing description for the purposes of explanation numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without some of these specific details. For example while the embodiments of the invention described above are implemented with program code e.g. software the underlying principles of the invention may be implemented using any combination of hardware software and or firmware. Accordingly the scope and spirit of the invention should be judged in terms of the claims below.

Some embodiments include one or more application programming interfaces APIs in an environment with calling program code interacting with other program code being called through the one or more interfaces. Various function calls messages or other types of invocations which further may include various kinds of parameters can be transferred via the APIs between the calling program and the code being called. In addition an API may provide the calling program code the ability to use data types or classes defined in the API and implemented in the called program code.

At least certain embodiments include an environment with a calling software component interacting with a called software component through an API. A method for operating through an API in this environment includes transferring one or more function calls messages other types of invocations or parameters via the API.

One or more Application Programming Interfaces APIs may be used in some embodiments. An API is an interface implemented by a program code component or hardware component hereinafter API implementing component that allows a different program code component or hardware component hereinafter API calling component to access and use one or more functions methods procedures data structures classes and or other services provided by the API implementing component. An API can define one or more parameters that are passed between the API calling component and the API implementing component.

An API allows a developer of an API calling component which may be a third party developer to leverage specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from an application. An operating system OS can have multiple APIs to allow applications running on the OS to call one or more of those APIs and a service such as a program library can have multiple APIs to allow an application that uses the service to call one or more of those APIs. An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.

In some embodiments the API implementing component may provide more than one API each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component. For example one API of an API implementing component can provide a first set of functions and can be exposed to third party developers and another API of the API implementing component can be hidden not exposed and provide a subset of the first set of functions and also provide another set of functions such as testing or debugging functions which are not in the first set of functions. In other embodiments the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.

An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations embodied for example by function or method calls exposed by the API and passes data and control information using parameters via the API calls or invocations. The API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API may not reveal how the API call accomplishes the function specified by the API call. Various API calls are transferred via the one or more application programming interfaces between the calling API calling component and an API implementing component. Transferring the API calls may include issuing initiating invoking calling receiving returning or responding to the function calls or messages in other words transferring can describe actions by either of the API calling component or the API implementing component. The function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure. A parameter can be a constant key data structure object object class variable data type pointer array list or a pointer to a function or method or another way to reference a data or other item to be passed via the API.

Furthermore data types or classes may be provided by the API and implemented by the API implementing component. Thus the API calling component may declare variables use pointers to use or instantiate constant values of such types or classes by using definitions provided in the API.

Generally an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component. By way of example the API implementing component and the API calling component may each be any one of an operating system a library a device driver an API an application program or other module it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other . API implementing components may in some cases be embodied at least in part in firmware microcode or other hardware logic. In some embodiments an API may allow a client program to use the services provided by a Software Development Kit SDK library. In other embodiments an application or other client program may use an API provided by an Application Framework. In these embodiments the application or client program may incorporate calls to functions or methods provided by the SDK and provided by the API or use data types or objects defined in the SDK and provided by the API. An Application Framework may in these embodiments provide a main event loop for a program that responds to various events defined by the Framework. The API allows the application to specify the events and the responses to the events using the Application Framework. In some implementations an API call can report to an application the capabilities or state of a hardware device including those related to aspects such as input capabilities and state output capabilities and state processing capability power state storage capacity and state communications capability etc. and the API may be implemented in part by firmware microcode or other low level logic that executes in part on the hardware component.

The API calling component may be a local component i.e. on the same data processing system as the API implementing component or a remote component i.e. on a different data processing system from the API implementing component that communicates with the API implementing component through the API over a network. It should be understood that an API implementing component may also act as an API calling component i.e. it may make API calls to an API exposed by a different API implementing component and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.

The API may allow multiple API calling components written in different programming languages to communicate with the API implementing component thus the API may include features for translating calls and returns between the API implementing component and the API calling component however the API may be implemented in terms of a specific programming language. An API calling component can in one embedment call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug in provider and another set of APIs from another provider e.g. the provider of a software library or creator of the another set of APIs.

It will be appreciated that the API implementing component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling component . It should be understood that the API calling component may be on the same system as the API implementing component or may be located remotely and accesses the API implementing component using the API over a network. While illustrates a single API calling component interacting with the API it should be understood that other API calling components which may be written in different languages or the same language than the API calling component may use the API .

The API implementing component the API and the API calling component may be stored in a tangible machine readable storage medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a tangible machine readable storage medium includes magnetic disks optical disks random access memory e.g. DRAM read only memory flash memory devices etc.

In Software Stack an exemplary embodiment applications can make calls to Services A or B using several Service APIs and to Operating System OS using several OS APIs. Services A and B can make calls to OS using several OS APIs.

Note that the Service has two APIs one of which Service API receives calls from and returns values to Application and the other Service API receives calls from and returns values to Application . Service which can be for example a software library makes calls to and receives returned values from OS API and Service which can be for example a software library makes calls to and receives returned values from both OS API and OS API . Application makes calls to and receives returned values from OS API .

Any one of the methods described herein can be implemented on a variety of different data processing devices including general purpose computer systems special purpose computer systems etc. For example the data processing systems which may use any one of the methods described herein may include a desktop computer or a laptop computer or a tablet computer or a smart phone or a cellular telephone or a personal digital assistant PDA an embedded electronic device or a consumer electronic device. shows one example of a typical data processing system which may be used with the present invention. Note that while illustrates the various components of a data processing system such as a computer system it is not intended to represent any particular architecture or manner of interconnecting the components as such details are not germane to the present invention. It will also be appreciated that other types of data processing systems which have fewer components than shown or more components than shown in may also be used with the present invention. The data processing system of may be a Macintosh computer from Apple Inc. of Cupertino Calif. e.g. a Mac or a Macbook Pro . As shown in the data processing system includes one or more buses which serve to interconnect the various components of the system. One or more processors are coupled to the one or more buses as is known in the art. Memory may be DRAM or non volatile RAM or may be flash memory or other types of memory. This memory is coupled to the one or more buses using techniques known in the art. The data processing system can also include non volatile memory which may be a hard disk drive or a flash memory or a magnetic optical drive or magnetic memory or an optical drive or other types of memory systems which maintain data even after power is removed from the system. The non volatile memory and the memory are both coupled to the one or more buses using known interfaces and connection techniques. A display controller is coupled to the one or more buses in order to receive display data to be displayed on a display device which can display any one of the user interface features or embodiments described herein. The display device can include an integrated touch input to provide a touch screen. The data processing system can also include one or more input output I O controllers which provide interfaces for one or more I O devices such as one or more mice touch screens touch pads joysticks and other input devices including those known in the art and output devices e.g. speakers . The input output devices are coupled through one or more I O controllers as is known in the art. While shows that the non volatile memory and the memory are coupled to the one or more buses directly rather than through a network interface it will be appreciated that the data processing system may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface or wireless interface such as a wireless WiFi transceiver or a wireless cellular telephone transceiver or a combination of such transceivers. As is known in the art the one or more buses may include one or more bridges or controllers or adapters to interconnect between various buses. In one embodiment the I O controller includes a USB adapter for controlling USB peripherals and can control an Ethernet port or a wireless transceiver or combination of wireless transceivers. It will be apparent from this description that aspects of the present invention may be embodied at least in part in software. That is the techniques and methods described herein may be carried out in a data processing system in response to its processor executing a sequence of instructions contained in a tangible non transitory memory such as the memory or the non volatile memory or a combination of such memories and each of these memories is a form of a machine readable tangible storage medium. In various embodiments hardwired circuitry may be used in combination with software instructions to implement the present invention. Thus the techniques are not limited to any specific combination of hardware circuitry and software nor to any particular source for the instructions executed by the data processing system.

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

