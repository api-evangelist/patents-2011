---

title: System and method for network security including detection of man-in-the-browser attacks
abstract: A method is performed in a network security system implemented in a computer or electronic device that is coupled to secured online resources for detecting unauthorized accesses of those secured online resources. The method includes monitoring a user activity session. It is determined whether the user activity session is indicative of a hidden session by an attacker, where the determination includes comparing the user activity session to an average user activity session.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09021583&OS=09021583&RS=09021583
owner: EMC Corporation
number: 09021583
owner_city: Hopkinton
owner_country: US
publication_date: 20110126
---
This application claims priority to U.S. Provisional Patent Application Ser. No. 61 298 300 filed Jan. 26 2010 entitled System and Method for Network Security Including Detection of Man In The Browser Attacks .

The present invention relates generally to networks and security boundaries and in particular to defenses against breaches activated in client browser systems.

There are many different entities financial business government charity educational individual etc. that may choose to have online presences implemented by computer systems coupled to a network or computer program code running on systems of others that are connected to the network. Since these online systems can be used to provide information accept and forward information facilitate transactions and or allow access to online resources those entities have an interest in securing those systems so that authorized activities are allowed while unauthorized activities are prevented. Internet and other online facilities are commonly used for financial business private and other transactions preferably kept secure.

In a simple example a bank may choose to provide its customers with online access to banking details and a facility to initiate transactions such as funds transfers. Some illegitimate actions that unauthorized individuals or computer systems may wish to perform might be expected such as improperly accessing the banking details initiating unauthorized transactions or modifying online resources for their own goals rather than those of the operator of the resources such as defacing an online presence stealing money goods or information sabotage or performing other illegitimate actions. Other illegitimate actions might be unexpected.

As explained herein a common approach to providing this online presence is via a website . While users may consider a website a place it is often a logical place only in that it is referenced by a URI while its actual location is not important and may indeed be distributed over multiple data centers or even virtual data centers in computing clouds. More precisely a website is typically the user interface aspects of an entity s network presence.

For example a retailer might set up a server that has thereon software that can receive requests from a network and respond to those requests by returning content accepting inputs and or performing some actions in response to requests. Some of that content returned can be in the form of web pages viewable by client devices in response to requests for those web pages from those client devices. Client devices might include computers telephones smart handheld devices other computing devices etc. These client devices might be used by the retailer s customers potential customers visitors suppliers or partners.

Some web pages are static and pre generated in advance of a request such as a page explaining a company s history while others are dynamic and generated on the fly such as a web page showing a user s current shopping cart contents or a page generated for a product that a user just requested. Thus the server might have access to data systems usable for generating web pages and other content video music etc. . The server might comprise multiple machines at different locations on the network perhaps serving different sets of pages or not. Thus the term website can refer to the client side view of a collection of servers content operations and the like while end users might view a website as a collection of pages operated by an entity with a consistent approach that can be viewed in various aspects. As used herein website might refer to the content the servers the operators of the servers and or the interaction with client devices etc. depending on context.

As website developers have devised defensive methods to detect and thwart attacks the attackers have in turn devised ways around those defenses in a co evolving cycle of increasing sophistication.

Many methods have been devised to steal legitimate users identities for website abuses. A common method is called phishing wherein an email sent under the guise of a trustworthy entity elicits personal information from unwitting recipients typically by luring potential victims to a fraudulent website that requests identifying personal information such as usernames passwords account numbers ATM PINs etc. This stolen information is then used by impostors either manually or robotically to log in to the victims accounts on the genuine websites in order to steal money send forged emails or perpetrate other illicit activity.

To combat such impostors many website operators have developed more sophisticated access control methods that require secondary authentication information that simple phishing schemes cannot easily obtain. For example when a website suspects that an account is being used by a third party the website may verify that the user is indeed the owner of the account by demanding randomly chosen additional access credentials such as place of birth mother s maiden name or the answer to one of a set of questions preselected by the legitimate account owner.

In response to the deployment of secondary authentication techniques fraudsters have developed what is called a man in the middle attack in which a phisher lures a victim to a counterfeit website mimicking the appearance and behavior of the target site on the one hand intercepting the victim s input and relaying it to the real website while on the other hand intercepting the real website s output and relaying it back to the user through the bogus site. Thus man in the middle attacks permit fraudsters to gain entry into privileged sites by duping authorized users of the site into responding to all authorization challenges posed by the privileged sites thus evading all direct authorization protocols. Despite the name man in the middle the entire process including any illicit activity perpetrated from within the burgled account may be performed fully automatically without the need for human intervention.

To combat man in the middle attacks many websites are programmed to look at structural identifying information such as the users Internet Protocol addresses and inferred geographic locations cookies site generated tokens passed back and forth between site and client user agent identifiers and request timestamps information over which the fraudster ordinarily has no direct control. This ancillary information allows a website to detect suspicious users who despite meeting all explicit authorization challenges are evidently not using the same browsers on the same computers in the same locations as they usually do indicating that they may be victims of man in the middle attacks.

Now that websites are examining structural session information to distinguish impostors from legitimate users fraudsters have developed an even more sophisticated method of assault called a man in the browser attack using malicious software surreptitiously installed on potential victims own computers. Many mechanisms have been devised for getting the malware installed including attachments to phishing emails downloads from phishing sites and self propagating viruses and worms any of which may be disguised within Trojan horses that apparently or actually perform desirable functions or may be downloaded afterwards through a back door via a bootstrapping mechanism.

This malware typically in the form of a browser plug in hence the name lurks in the background until it recognizes that the potential victim has successfully signed in to a targeted website thus eluding all direct authorization protocols. It then uses the victim s own browser on the victim s own computer in accordance with the user s own schedule to perpetrate fraud while the victim is also interacting with the website thereby also eluding all structural authentication clues. Again although some implementations provide for real time human intervention nevertheless the entire process including any illicit activity perpetrated from within the hijacked account may be performed fully automatically despite the name man in the browser. The malware can elude detection by the user by performing its transactions invisibly for example in an off screen window or as in a man in the middle attack by intercepting the communications between the real user and the website and spoofing the view presented to the user.

Since man in the browser attacks like man in the middle attacks and other phishing attacks cause substantial harm to websites and to the websites legitimate users through direct financial and material theft as well as through sabotage defamation and other forms of damage it is crucial for websites to have an effective means for detecting such attacks in order to take remedial actions against them.

In embodiments of a network security system according to aspects of the present invention user sessions with a website are analyzed to determine whether the user activity patterns suggest a fraudulent agent is operating in part as the user and to take appropriate remedial actions. It may be that a plurality of sessions appear to be concurrently accessing the same user account on the website even if those sessions share the same structural identifying parameters such as IP address computer system and browser or other Internet application and such will be detected. Even if structural parameters are characteristic of a legitimate user of the account the fraudulent agent might be detected. Even if sessions co occur within a single sign in session at a time and of a duration characteristic of that user the fraudulent agent might be detected. Thus impostors can be detected by their concurrent attacks operating elsewhere in the world for detecting intercessory attacks by impostors hijacking legitimate users sessions from counterfeit man in the middle websites as well as detecting man in the browser attacks by impostors hijacking legitimate users sessions from within their own browsers or other Internet applications on their own computers.

The following detailed description together with the accompanying drawings will provide a better understanding of the nature and advantages of the present invention.

This description presents a system and method for determining when there is a man in the browser attack on a website among other things. In an exemplary embodiment of the invention man in the browser attacks on a website are detected by comparing the current user s session with the average user session.

The inventive system operates upon an incoming stream of input data generated by actions on a website. Example actions on a website generally correspond to hyperlink clicks by the user of the website. These clicks can be performed by a human or by an automated computer program. Automated computer programs can work by simulating website clicks or by working through the application programming interface of the website.

Examples of actions taken on websites include entering data into forms on the website and clicks to go to other pages of the websites. Examples of entering data into forms on websites include entering a user name and password on a website to sign in to the website filling out an email form to send email to another user of the website and entering personal information to register for an account on the website.

As described in further detail below each website action can comprise multiple parameters as defined by information corresponding to the action on the website that can be seen by the processors and computers related to a webserver a firewall or other device that processes website traffic and additional information provided by the website or third parties. Examples of parameters associated with website actions include IP addresses including those of proxies used in the process of sending traffic to the website browser header information operating system information information about other programs installed on the user s machine information about the clock and other settings on the user s machine cookies referring URLs usernames parameters associated with a post to the website and other information associated with the user s action on the website.

Several aspects of the current user session are compared with the average user session to detect man in the browser attacks using a pre stored data set representing the average parameter values across all user sessions during the data collection period. This is compared to the average time between clicks for an average session. Next the order in which website pages are viewed in the current session is compared with the order in which website pages are viewed in an average session for each page that is accessed. Finally the time between clicks for each individual page in the user s session is compared to the average time between clicks for the average user session for that page. Additional tests might be used instead of or as well as those cited above.

The above comparisons are combined to generate a score that indicates the likelihood that the current session is a man in the browser attack. The score is used to determine whether or not an alert should be generated to notify the appropriate parties including the website administrator the website alert processing system and other associated website parties.

Top level information flow diagram illustrates one way that the invention disclosed herein may be integrated with the data center or data centers employed by a service as a rearguard threat detection system .

A service data center the system which operates a website or other network service may be configured in a number of different ways depending largely on the size of the business for example as a single virtual server shared with other services a dedicated physical server all or part of a server farm or a virtual server farm in a computing cloud. A service data center receives client actions from clients of the service who in turn receive service actions such as webpages webpage updates email messages text messages telephone calls or other information back from the service data centers. Typical client actions correspond to hyperlink clicks or other interactions with a website such as entering form data or uploading images or other resources by clients of the website who can be human or computer automata. Automated computer programs can work by simulating website clicks by using the service s application programming interface if any or by using some other protocol.

For each client action and service action the responding service data center relays a raw transaction record to threat detector . A transaction record describes the parameters of the transaction between the client and the server containing parameters of corresponding client action and server response needed for threat detection. In their rawest form these transaction records can be simply copies of the low level packets or datagrams for all network traffic between the exposed data centers and the websites clients which the network service threat detector independently reassembles into complete transaction records.

The network service threat detector and other components may likewise be located onsite offsite or in a cloud computing center. In the preferred embodiment the entire network service threat detection system is collocated with service data center to facilitate security and real time response. Very large Internet businesses employ multiple geographically dispersed data centers in which case a single threat detection system may serve one or multiple data centers.

Network service threat detector analyzes logged transactions for suspicious behavior characteristic of man in the browser MiB attacks and other types of attacks and issues threat notifications accordingly to service threat processors including the service administrator the service s alert processing system and other associated service parties as appropriate. If the service is not configured to provide all the transaction information needed by the detector in the stream of raw transaction records pushed to the detector then the detector may issue requests to pull additional information as needed from the client facing data centers or from internal service data centers which are installed at some services where they are shielded from the Internet for reasons of security or efficiency. Additionally for services that can make other use of information produced by the detector the detector may send information to the service data centers or either unsolicited or in response to requests from the detector . Network service threat detector is described in more detail under .

Threat processors review threat notifications possibly in conjunction with additional information provided by other tools not shown and issue corresponding remedial actions to client facing data centers .

Remedial actions may also be fed back to the MiB detector permitting the detector to respond on its own to subsequent matching threats without incurring the delay entailed by encumbering the threat processors. Threat remediations include immediately thwarting hijacked clients from accessing the service as a whole or sensitive portions thereof by blocking them delaying them diverting them to harmless webpages or spoofing sensitive information warning the victims that their systems have been infected either through independent channels such as telephone or paper mail or through changes to account information that would go unrecognized by the hijackers but compel the victims to contact the business through other channels such as by telephone reversing or blocking the fraudulent transactions monitoring and tracking the compromised accounts and forwarding incriminating evidence to the appropriate authorities for further investigation and prosecution or other actions.

In the preferred embodiment rearguard network service threat detection system is capable of detecting and remedying attacks on a service in substantially real time.

Top level information flow diagram illustrates an alternate way to integrate with a service s data center s as a vanguard network service threat detection system .

In this configuration service traffic processor is introduced as a proxy to intercept client actions in order to output transaction records to threat detector and to intercept normal website actions output by website data centers in order to substitute remedial actions provided by the MiB detector or website threat processors as appropriate. As with the other components website traffic processor may be onsite offsite or in a cloud computing center. For generating transaction records website traffic processor has direct access to all the information in the HTTP request headers from client actions and in the HTTP response headers from the website actions or . It also has access through its own clock to the exact times that the client actions were received and the website actions were transmitted which it inserts in the transaction records thus obviating the need for server synchronization during session reconstruction See other than for conciliation with information exchanged internally with website data centers and through service responses to detector requests and detector responses to service requests .

In the preferred embodiment of the vanguard MIB detection system to avoid superfluous generation of normal website actions replaced by remedial actions exposed data centers receive client actions only as filtered client actions from website traffic processor which either withholds remediated client actions from the website data centers or flags them as remediated before passing them on to the data centers to log without responding.

In an alternative embodiment for example if the website needs to log all client actions accurately but is not set up to refrain from responding to remediated client actions client actions are either passed through website traffic processor unfiltered or copied directly dashed arrow to the website data centers to be filtered by the website traffic processor only on output .

In another alternative embodiment if it is more convenient for certain actions or other information to be communicated internally particularly if the vanguard MiB detector is collocated with the data centers MiB detector may issue a detector request and receive a service response directly from isolated service data center or exposed website data centers or provide a service request directly to the data centers.

A vanguard MiB detection configuration is preferable for websites that are not designed to produce the real time transaction parameter records needed by the MiB detector that are not designed to implement the remedial actions desired to deal with MiB attacks in real time or that prefer to have the MiB detection and remediation handled offsite before offensive client actions have a chance to reach the website. Vanguard MiB detection also offers the advantages of more accurate and more precise timestamps and tighter bounds on client response time estimates as explained in connection with .

In the preferred embodiment MiB detection system is capable of detecting and remedying MiB attacks on a website in substantially real time.

As depicted in high level information flow diagram man in the browser detector inputs raw transaction parameter records streaming in from the website data center s applies a number of processing steps and outputs threat notification alerts to website threat processors.

In the first detection step if the input transaction records do not contain all the transaction information needed by the threat detector as is often the case for rearguard detection systems See then record augmenter obtains as much of the missing information as possible through service responses by querying the data center s with detector requests . As a result record augmenter produces augmented transaction records .

Next the augmented transaction records are analyzed by session reconstructor to separate them into individual client sessions as further described under . The session reconstructor may be assisted in its analysis by use of a website map generated and maintained by website analyzer as further described under .

Session analyzer then analyzes the client sessions for features characteristic of MiB attacks or similar website attacks and for each input session can output a record of session threat parameters as further described under . The session analyzer may also make use of information from the website map.

Next session comparator compares current session parameters against a set of session models derived by session modeler from aggregate current and prior session parameters records and for each current client session outputs a threat score record . The session modeler may use the website map in its analysis. The session comparator is described further in connection with and the session modeler in connection with .

Finally for each client session threat remediator analyzes the threat score record and as warranted outputs threat notification for further analysis and remediation by website threat processors See . If directed to do so the threat remediator may also output remedial action to client facing website data center See or to website traffic processor See .

As depicted in information flow diagram website analyzer for use in network service threat detector See analyzes the logical structure of the website and outputs a website map detailing the intrinsic linkages among the webpages as well as the intrinsic access level intrinsic privilege level and intrinsic security level of each region of the website. Website spider assembles a complete list of all pages and other services provided by the website and of all internal hyperlinks among the pages and other media of the website by examining intrinsic hyperlinks on various pages and following each link that leads to a new target thus building up the lists of services and links as it goes.

Like ordinary website spiders of the prior art website spider is launched at the website root and traverses the website by issuing client actions via simulated website clicks or if available the website s application programming interface to the client facing website and analyzing website action responses for all traceable links. In case the website contains disjoint regions or regions not directly reachable by external spidering the spider is also launched at unlisted services appearing in the Request URLs and Referrer URLs in client sessions . In addition links untraceable by external spidering such as deliberately disguised CGI POST methods website spider traces in parallel internally via transaction records . Where possible website spider also traverses the website by accessing the services and links directly through database queries to website data center or .

To distinguish the uniform resource locators URLs of genuinely new services from merely synonymous URLs of known services the URL resolver not shown employed by website spider and change detector is augmented to resolve not only the URLs supplied and received by external spidering from client actions and website actions respectively but also the URLs and equivalent identifiers provided by the website data centers in the responses to database queries and in the transaction records in the client session records . To resolve URL aliases spider not only compares service contents as in prior art spiders but first correlates URLs presented externally in website actions with internal URIs given in transaction records synchronizing the two by for example including a sequence number in the User Agent field of its requests.

Change detector monitors client sessions for the appearance of new services not in the list of website services as well as periodically checking for changes to already listed services and issues update orders to the website spider accordingly.

Security classifier examines each web service and outputs security level classifying the service according to whether its contents are ever transmitted as plaintext or always transmitted in encrypted form via a secure protocol such as TLS or SSL as recognizable by the https secure protocol name in the services URLs as opposed to http or by the HTTP Upgrade header.

Linkage mapper compiles the lists of services and links into a coherent map of the website s intrinsic linkage structure.

Privilege classifier examines website links for checkpoints requiring passwords or higher levels of authentication and uses this information to partition linkage map into regions according to the echelon of privilege required to access the services within each region.

Access classifier examines each web service and assigns it an access level ranging from an innocuous static wall providing no access to personal or proprietary information through an unsafe window permitting inherently risky transactions that a malicious agent could exploit to indirectly damage the interests of the client or the site s owner such as viewing personal or proprietary information and using it at other times or in other places to a dangerous door permitting inherently dangerous transactions that a malicious agent could exploit to directly damage the interests of the client or the site s owner such as removing or transferring goods or money creating deleting or changing information such as account ownership or shipping addresses and in general effecting changes on the webserver or elsewhere outside the client s browser. Windows are typically indicated by HTTP GET and HEAD methods while doors are typically indicated by HTTP POST PUT and DELETE methods.

Website mapper compiles website linkage map access level data privilege level data and security level data into a single integrated website directed graph map for use by session reconstructor and session modeler See to determine whether an observed transition coincides with an intrinsic website link by session comparator to weight session threat scores according to intrinsic threat values of the services and transitions involved and by website threat processors and other website personnel to visualize and explore the threat terrain of their website and by the website developers to improve the intrinsic security of their website.

The website map includes a service index and a link index for quick random access by service and link.

Website map is also intended for use by other operations personnel for example to determine whether all current regions of the website are properly connected and whether abandoned or experimental regions are properly disconnected for development research for example to determine whether certain common pathways should be replaced with more efficient ones and whether certain uncommon ones should be removed and for marketing research for example to explore how various services can be accessed or promoted.

Conflict analyzer uses website map to analyze the structural integrity of the website and outputs conflict warnings for any structural security flaws in the website ranked by priority in order to thwart certain types of threats of which the website security personnel are presumably not yet aware and which fraudsters may already be exploiting. In particular private information should never be sent in the clear and risky actions should never be accessible to clients without the requisite clearance so services containing windows and especially doors should be both privileged and secure. The conflict analyzer can also issue warnings for broken links as well as for orphaned regions of the website whose unmaintained status may pose security risks.

As depicted in information flow diagram session reconstructor for use in network service threat detector See compiles the augmented transaction records from the website data center s into synchronized individual client sessions by synchronizing and sorting the records and segregating them into sessions.

The transaction synchronization phases comprising service timing and server timing modeling server synchronization agent timing modeling client timing modeling and client synchronization serve to bound as accurately and tightly as possibly the client response delay the interval from the instant the client received and was able to respond to website action See to the instant the client responded by issuing client action . Only by knowing the precise client response delay can anomalous client response delays be accurately detected.

Transaction records typically provide two sets of timestamps server timestamps and client timestamps which for HTTP services are respectively supplied in the HTTP Response Date headers of the website actions and in the HTTP Request Date headers of the client actions . These timestamps by themselves even if both the request timestamps and the response timestamps were reliably present and accurate are fundamentally inadequate for fixing the client response interval because neither the response nor the request is instantaneous in its production transmission reception and interpretation. Although websites concerned about security can be presumed to provide some sort of response timestamps the client request timestamps are only optionally present. Moreover many websites do not properly synchronize the clocks among their servers the phase of the response marked by the server s response timestamp is undefined and some provide a timestamp indicating when the transaction was logged in place of the server response time.

Clients clocks are likewise often inaccurate and are in fact intentionally misadjusted by users to help disguise their locations including by some benign users for privacy and request timestamps when present may be deliberately forged by MiB malware and other attackers to help evade detection. Thus it is useful to have an accurate estimation of the client response interval from statistical information and models about the timing characteristics of the servers services clients and agents.

In vanguard deployment the service traffic processor See records the times when it begins and finishes relaying each service request from each client to the website servers and the times when it begins and finishes relaying each corresponding response from the server back to the client and can thus accurately estimate the client response interval for each transaction from transaction specific timing information. In a rearguard deployment however the session reconstructor estimates the client response interval from more general statistics.

For website operators willing to modify their websites or have their websites modified a client side timing mechanism can be embedded in the website s services which explicitly measures the time interval between service receipt and user response and reports that time interval back directly to the website. For HTML pages for example the timer can be implemented as a Javascript Date object created on load and set to the load date and then when a hyperlink on the page is clicked either the load time or the elapsed time since loading is appended to the target URL or to the payload of the HTTP request.

In a vanguard deployment with permission the service traffic processor embeds this mechanism in the website services on the fly. Otherwise having the website developers add this mechanism in a normal development cycle may take many months. In any case since client side timing information can be spoofed by an MiB attacker and other attackers the session reconstructor still should corroborate it with independently derived server side information.

In the first session reconstruction step server synchronizer corrects for discrepant clock settings among active servers at the website during the data collection period and compensates for the indeterminacy of the phase of service represented by the servers date timestamps recorded in input transaction records in order to accurately estimate the server s receive date send date and sent date for each input transaction record augmenting the transaction record with these dates to output corresponding server synchronized output transaction record . The server synchronizer bases the server clock correction and phase compensation on service specific timing models and server specific service timing models generated and maintained by service timing and server timing modeler for each service and each server respectively appearing in the input transaction records. The server modeler is described in greater detail under and the server synchronizer under .

Next transaction sorter sorts all the synchronized transaction records from the data collection period in chronological order either by synchronized receive date send date or sent date outputting sorted transaction records . In the preferred embodiment the transaction records are sorted by the synchronized receive date which tends to have the least variance of these three date estimates.

Session segregator teases apart the sorted transaction records into records belonging to individual clients on the basis of such identifying characteristics as the account number cookie authentication URL session ID email address and IP address outputting each individual client s set of sorted transaction records as an individual client session . The session segregator is discussed at length under .

Finally client synchronizer corrects for errant clock settings among all active clients using the website during the data collection period compensates for the indeterminacy of the phase of request represented by the user agents date timestamps recorded in the input transaction records adjusts for transmission time between each client and server in each direction and adjusts for the user agents service load time in order to accurately estimate the client s load date and click date augmenting the transaction records in client sessions with these dates to output corresponding client synchronized output transaction records in synchronized client sessions . The client synchronizer bases the client clock correction phase compensation transmission delays and load time on client specific client timing models generated and maintained by client timing modeler by agent specific agent timing models generated and maintained by agent timing modeler as well as on server models and service models . The agent modeler is described further under . The client modeler is detailed under .

At many websites the accuracy of the timestamps is untrustworthy because each transaction may be received and transmitted by a different server and the servers may not be properly synchronized so that their clocks and hence their timestamps disagree significantly and gradually drift apart. This problem may be especially pronounced when different transactions within the same client session may even be served by data centers geographically distant from one another.

A further error typically constant across all servers particular to a website is due to the indeterminacy of the server phase denoted by a server timestamp Many web services take a substantial interval of time to assemble and transmit and the timestamp could refer to any instant during that interval. In fact the precise meaning of the Date header in the server response is even officially undefined although the HTTP specification recommends that the date represent the moment just before the entity is generated it allows for the date to be generated at any time during the message origination.

Therefore depending on the website the timestamp may denote when the server received and enqueued the HTTP request when it dequeued the request and began serving the service when it finished serving the service when it recorded the received or fulfilled request in a database or anything in between.

As depicted in information flow diagram service timing and server timing modeler for use in session reconstructor See estimates and tracks the service timing characteristics for each service provided by the website during the data collection period and the server timing characteristics for each client facing server in use at the website during the data collection period by using service and server delay modeler to measure and model the server s service delay statistics and server delay statistics for each service provided by that server during the data collection period using echo modeler to measure and model the server s echo delay statics using service delay comparator to compare the service delay and echo delay models and using the server delay comparator to compare the server delay and echo delay models.

Service and server modeler inputs transaction records during the data collection period and extracts the server identifier to obtain a list of all exposed servers active during the data collection period which it provides to service and server modeler and echo modeler and extracts the service identifier to obtain a list of all services provided by each server during the data collection period which it provides to the service and server modeler. For the current Internet addressing schemes the server identifier consists of the server s IPv6 or IPv4 address and port number in the TCP or UDP packet header the port number being necessary for website servers in a private network behind a proxy and the service identifier consists of the service s URL.

During the data collection period service and server timing modeler uses service and server timer to measure the timing characteristics of each active server identified by server identifier for each of that server s active services and uses service and server date comparator to model the statistical distribution of the server s service timing characteristics.

Specifically in a rearguard deployment for each active server and each of that server s active services the service and server timer sends a statistically significant number of requests for that service to that server and outputs the date timestamp specified by the server in the service response in the server s Response Date header in the case of HTTP transactions. The moment the service timer sends a service request it outputs service request send date timestamp the moment it begins to receive corresponding service response it outputs service response receive date timestamp and the moment it has finished receiving the service response it outputs service response date timestamp each of these times being given by master clock as respective current time . In a vanguard deployment instead of issuing a statistically significant number of instances of each service request the server timer can simply pass the filtered client actions to the servers and receive the corresponding normal service actions thus providing an accurate fix for each actual client transaction without the need for additional samples.

Service and server date comparator models the distribution of the difference between service receipt date and service send date for each service outputting the models as service delay models . The service date comparator also models the distribution of the difference between nominal response date and each of service send date service receive date and service receipt date for each server as a function of the service outputting the models as server delay models . The service date comparator is detailed under .

Also during the data collection period echo timing modeler uses echo timer to measure the null service timing characteristics of each active server and uses echo date comparator to model the statistical distribution of the null service timing characteristics. Specifically echo timer issues a statistically significant number of echo requests also known as ping requests to each active website server outputting echo send date timestamp the moment it sends the echo request and outputting echo receipt date timestamp the moment it has received the echo response back from the server each timestamp being given by the respective current time as specified by master clock .

For each timed echo echo date comparator calculates the difference between echo receipt time and corresponding echo send time and outputs a model of the distribution of the result as echo delay model . In the simplest embodiment the server specific echo delay model for each direction comprises half the mean roundtrip echo time. The preferred embodiment also takes into account any known speed and bandwidth asymmetries in the transmission rate of the Internet connection on either end by partitioning the roundtrip echo time into two portions inversely proportional to the throughput in that direction.

Finally for each active service delay comparator compares the service roundtrip delay with the echo roundtrip delay outputting the difference between the models as intrinsic service duration in service model .

In an alternative embodiment the server timing is modeled in terms of service length in bytes rather than in terms of intrinsic service duration.

For each active exposed website server server delay comparator also compares the server s service delay distribution with the server s echo delay distribution outputting the difference between the models as server timing model . In the simplest embodiment the server timing model comprises three affine functions of the intrinsic service duration each with an additive bias parameter and a multiplicative rate parameter. Specifically the server receive function used by server synchronizer to estimate when the server received a service request is calculated as the difference between the service request delay function and the echo request delay function the server send function used to estimate when the server started to send a response is calculated as the difference between the service send function and the echo send function and the server sent function used to estimate when the server finished sending a response is calculated as the difference between the service sent function and the echo send function.

In an alternative embodiment instead of creating server independent service delay models separate from server delay models server service date comparator generates a separate server delay model for each active service for each active server providing that service. The simplest combined service and server delay model then gives the service request service respond and service response delays as constant functions specific to both the service and the server computed as the observed mean of each respective difference. In this case service delay comparator and server delay comparator are likewise combined into a single service and server delay comparator that correspondingly outputs a separate timing model for each active service for each active server providing that service.

If either the service timer or the echo timer finds that a server fails to respond or finish responding to a request within a reasonable amount of time typically within a few seconds or a small multiple of the average response time for that server or that service request then it excludes that measurement from the statistics and issues a warning to website administrators that the server is not responding as quickly as expected.

Service timing models and server timing models are updated by service delay comparator and server delay comparator periodically frequently enough to track the drift among server clocks as well as after power outages daylight savings time clock shifts and other exceptional events that might affect the server clock settings or alter the proxy s port numbers for individual servers. In the preferred embodiment the server timer updates the server timing models frequently enough to accurately track server congestion. In an alternative embodiment the service delay models and the echo delay models and thereby the server models explicitly take website congestion into account as thresholded affine functions of the server load.

In one embodiment the service models and server models and the underlying service delay models server delay models and echo delay models are computed in independent batches for example for successive data collection intervals such as once per hour for the preceding hour. In the preferred embodiment these models are continually updated with a sliding window in shorter overlapping increments even in the limit as each new transaction record is collected and as each old transaction ages beyond the time window.

In addition to their use for website threat detection the service timing models can be analyzed by service analyzer and presented as service summaries for operations research for example to determine whether the resources devoted to particular services or types of services should be adjusted for development research for example to determine whether certain services should be replaced with more efficient ones and for marketing research for example to determine how various services are being used.

Similarly in addition to their use for website threat detection the server timing models are analyzed by server analyzer and presented as server summaries for operations research for example for load balancing or to determine whether certain servers or types of servers are performing up to expectations.

As depicted in information flow diagram the server service date comparator used by service and server modeler See models the service delay using service delay modeler and models the server delay using server delay modeler .

For each timed service transaction the server service delay modeler calculates the difference between the service receipt date and the corresponding service send date outputting the result as service round trip delay . Roundtrip delay modeler computes a server independent model of the distribution of this difference for each service outputting the result as service delay model . In the simplest embodiment the service delay model comprises a service specific constant function computed as the mean round trip time across all active servers which is the least squares best fit value. In the preferred embodiment the model for each service takes caching into account by decomposing the round trip data into cached versus uncached distributions where caching is determined by re requesting the same service from the same server in quick succession.

Similarly for each timed service transaction the server delay modeler uses differencer to calculate the service request delay as the difference between nominal response date and corresponding service request send date uses differencer to calculate the service respond delay as the difference between each service receive date and the corresponding nominal response date and uses differencer to calculate the service response delay as the difference between each service receipt date and the corresponding nominal response date. Service model fetcher then fetches service duration parameters for the service identified by service identifier from service models .

In the simplest embodiment the service duration parameters used by the server delay modeler comprise the mean duration of the service. Finally request delay modeler models the request delay for each server as a function of the service duration which it outputs as request delay model respond delay modeler likewise models the respond delay for each server as a function of the service duration which it outputs as respond delay model and response delay modeler likewise models the response delay for each server as a function of the service duration which it outputs as response delay model these three models comprising the server delay model . In the simplest embodiment the server delay modeler models the service request service respond and service response delays as server specific affine functions of the intrinsic service duration computed by the least squares best fit each function specified by an additive bias parameter and a multiplicative rate parameter. In the preferred embodiment the model for each of the three service delay components also takes caching into account by decomposing the observed data for each into two separate affine functions one for when the service is cached the other for when it is uncached.

In the preferred embodiment the server delay modeler and service delay modeler account for the effect of encryption such as TLS or SSL on service timing implicitly by considering the encrypted versus unencrypted versions as distinct services modeled separately. Ordinarily this happens automatically as a result of the convention of giving securely encrypted services distinct URLs such as https . . . versus http . . . .

Note that since the bandwidth of the connection between the server timing modeler and the servers for a website is typically at least as great as that of any client its effect on the serving duration is relatively insignificant.

As depicted in server synchronizer for use in session reconstructor See adjusts the response date timestamp in each input website transaction record for inaccuracies in the clock settings of the server and for the indeterminacy of the phase of service using receive date estimator send date estimator and sent date estimator to accurately estimate the server s receive date send date and sent date respectively for that transaction and outputting those estimates in corresponding augmented server synchronized output transaction record . The server synchronizer bases these adjustments on the timing model for the service and the server timing model for the server.

For detecting man in the browser attacks man in the middle attacks repetitive robotic attacks and similar types of website attacks which are characterized by anomalously ordered transactions and anomalously quick transactions accurate server timestamps are critical. By giving transaction sorter See accurate and precise dates by which to sort the transaction records it can be determined whether the order of transactions in a session appear anomalous. By giving event comparator See accurate and precise event duration estimates it can be determined whether an event is anomalously quick.

Although for non streaming data websites usually communicate with clients via TCP IP which guarantees packet order nevertheless a separate TCP socket session is created for each webpage so if a client opens a plurality of pages concurrently those requests may travel along different routes and be received by the website out of order and they may be processed by servers of differing speeds and responded to out of order and the responses may likewise travel along different paths and reach the client out of order. Note however that within a single processing thread for example within a single browser window or tab the client actions and website actions are necessarily strictly ordered in the sense that the client has to receive each website action before being able to respond to it while the website likewise has to receive each client action before being able to respond to it.

For each input transaction record service and server modeler extracts the service identifier and passes it to service model fetcher extracts server identifier and passes it to server model fetcher and extracts server response date timestamp which it passes directly to each of the server date estimators receive date estimator send date estimator and sent date estimator .

Service model fetcher uses service identifier to look up the appropriate service timing model which it outputs to receive date estimator send date estimator and sent date estimator . In the simplest embodiment shown here the service timing model comprises a mean service duration .

Server model fetcher uses server identifier to fetch the appropriate server timing model which it likewise outputs to the server date estimators. In the simplest embodiment shown here for each of the three server date estimators receive date estimator send date estimator and sent date estimator the server timing model comprises an affine function of the service duration each affine function being specified by a multiplicative rate parameter receive rate send rate and sent rate and an additive bias parameter receive bias send bias and sent bias respectively.

Receive date estimator estimates the server receive date the instant when the server received the service request by adjusting the server s response date timestamp by the server receive bias and the product of the server receive rate and the service duration .

In detail multiplier multiplies the service duration estimate by the server receive rate estimate outputting the result as receive duration estimate . Adder then adds the receive duration estimate to the receive bias estimate outputting the sum as total receive delay estimate . Finally subtractor subtracts the receive delay estimate from the recorded response date outputting the difference as adjusted receive date estimate .

Similarly send date estimator estimates the server send date the instant when the server began sending the service response by adjusting the server s response date timestamp by the server send bias and the product of the server send rate and the service duration . In detail multiplier multiplies the service duration estimate by the server send rate estimate outputting the result as send duration estimate . Adder then adds the send lag estimate to the send bias estimate outputting the sum as total send delay estimate . Finally subtractor subtracts the recorded response date from the receive delay estimate outputting the difference as adjusted send date estimate .

Similarly sent date estimator estimates the server sent date the instant when the server finished sending the service response by adjusting the server s response date timestamp by the server sent bias and the product of the server sent rate and the service duration . In detail multiplier multiplies the service duration estimate by the server sent rate estimate outputting the result as sent duration estimate . Adder then adds the sent duration estimate to the sent bias estimate outputting the sum as total sent delay estimate . Finally subtractor subtracts the recorded response date from the receive delay estimate outputting the difference as adjusted receive date estimate .

Finally transaction record editor augments the input transaction record to include server receive date estimate server send date estimate and server sent date estimate outputting the augmented transaction record as synchronized transaction record .

Often the response to a service request is assembled from a number of service components that may differ in service timing characteristics provided by a number of servers that may differ in server timing characteristics. For example a web page may include static text dynamic client specific text images and other materials and may even include other web services for example in separate HTML frames. In these cases in the preferred embodiment the receive date estimator send date estimator and sent date estimator accumulate the receive delays send delays and sent delay respectively before subtracting the response date outputting a single receive date estimate single send date estimate and single sent date estimate respectively for the entire transaction.

It should be noted that relative and possibly absolute timing of events can be done as described herein or using conventional methods if available.

The source IP address and destination IP address are required in all HTTP requests and responses as part of the IP packet header making the IP address alone among the five specific types of identifying information reliably present in all transaction records. Nevertheless the value of the IP address is an inadequate discriminant of client sessions because in legitimate use the relation between IP addresses and clients is both ambiguous one to many and degenerate many to one . On one hand a single IP address is commonly shared by multiple clients for example when clients share a router in a local area network or when they share a proxy or a firewall. Although in such cases the clients are distinguished by the port number in the extended IP address the mapping between client and port is ephemeral. In such cases the clients may also be distinguished by HTTP Forwarded for field in the request header but that field is optional. On the other hand a single client may use multiple IP addresses within a single session for example when a mobile client is automatically switched between cell towers while travelling when a client is automatically switched or intentionally switched between wireless routers due to interference in a congested wireless environment or when using a multihoming system with multiple public IP addresses. Furthermore the IP address and Forwarded for field in a client s request header are untrustworthy in that they may be spoofed by an attacker for example in order to camouflage the client s response times and order of transactions.

In order to receive the website s responses an attacker must of course have control of the bogus IP addresses for example through legitimate ownership hijacking the IP address through malware installed on the client s system at that IP address or stealing the IP address by poisoning the network address translator in any router along the route to redirect traffic to the attacker s system or poisoning the address resolution caches within a local area network to direct traffic to the attacker s system. For certain types of attacks however such as denial of service attacks on websites by flooding the websites with requests denial of service attacks on clients by flooding the clients with responses or attacks defaming or blacklisting clients by attributing unsavory or hostile actions to them the attackers have no need to receive the website s responses. In man in the browser attacks the attacker automatically shares the client s the IP address.

The login ID specified in the HTTP Authorization request header field unlike the IP address is unreliably present because many websites make no use of it instead communicating authorization information in the Cookie field or in a query string in the URL and because most websites permit clients to visit certain areas and perform certain types of actions without logging in. Many visitors to a website do not even have an account at the website to sign in to and those clients with valid accounts at a website often avoid signing in due to laziness or privacy concerns. Nevertheless for websites that use HTTP Authorization to restrict access to privileged regions the login ID is when properly implemented by the website reliably present in HTTP requests for services within those regions. Like IP addresses login IDs are legitimately both ambiguous and degenerate client identifiers. On one hand multiple clients commonly share the same login ID for example in situations where one or more users are helping others with their accounts one or more users are supervising others or when multiple people in a firm or a family use the same login ID. On the other hand a single client may use multiple login IDs for example when a client has multiple independent accounts or is serving a number of customers with independent accounts at the website. Login IDs are also untrustworthy since they are often spoofed by attackers for example in brute force password guessing attacks in man in the middle attacks and for stolen accounts. In man in the browser attacks the attacker automatically shares the login ID.

The email address specified in the HTTP From request header field is highly unreliable because to protect users privacy and to avoid spam it is not implemented by most modern browsers and is typically only supplied by scrupulous spiders and robots. The From email address is also legitimately both ambiguous and degenerate since on the one hand multiple users often share an email account for example in a family or small business where one person is Internet savvy or imperious while on the other hand a single user may often have multiple email accounts for example for home versus office. If the email address were available it would be roughly as untrustworthy as the IP address in that it is easily spoofed but in order to receive any responses sent to that email address an attacker would need to have access to the email account.

The cookie specified in the HTTP Cookie request header field is unreliably present because clients can refuse to accept cookies from the website and thus not return the cookies to the website and modern browsers make it easy for users to refuse cookies. On the other hand websites can refuse to serve users who refuse cookies and many security conscious websites do so. Moreover when present and properly implemented by the website to include a unique session ID a cookie is the most specific client identifier that HTTP provides for because the relation between clients and session cookies may be one to many but not legitimately many to one A single client may have multiple concurrent cookie sessions with a website by using multiple applications to access the website for example when using more than one browser to connect to the website because of website browser incompatibilities or when using automating applications to perform routine functions on the website. In contrast a cookie can only be shared if it is deliberately stolen for example by copying the cookie using malware installed on the intended recipient s system by intercepting it through a counterfeit website by side jacking the cookie with a packet sniffer or by forwarding the cookie by cross site scripting or if the cookie is deliberately planted or fixed for example by getting the victim s browser to store the cookie via cross site cooking or cross subdomain scripting.

Query string session IDs are susceptible to harvesting in a referred website from the URL query string in the HTTP Referrer field and to session fixation by emailing the victim a hyperlink specifying a session ID in a URL query string where the session ID may be generated by the attacker or by the target website.

Referring URLs specified in the HTTP Referrer field are unreliably present because to help protect users privacy some services browsers and browser extensions permit referrers to be disabled.

The timestamps in addition to being used to sort the transactions in chronological order are also used to help segregate sessions on the basis of overlapping transactions. Note however that a single client may legitimately have overlapping transactions for example by concurrently opening or operating multiple browser windows opened to the same website.

Besides timestamps and these five specific types of information the session segregator can also use generic types of information specified in HTTP Request headers including Accept acceptable content types Accept Charset acceptable character sets Accept Encoding acceptable encodings Accept Language acceptable languages Accept Ranges acceptable size ranges User Agent name and details of web application and Via proxies through which the request was sent . All of these HTTP Request headers are optional and therefore unreliable. Moreover they are all untrustworthy being easily spoofed. Some browsers and freeware browser plug ins even exist to let ordinary users conveniently alter some of these headers during a session. However spoofing such non specific information during a session does not affect any of the specific session identifiers. Changes in any of these generic information types during a session can be flagged as potentially indicating that the session has been hijacked.

The session thus segregates the sorted transaction records according to cooke ID if available as the primary key into primarys strands and segregates the primary strands according to account ID login ID query session ID or email address as available as secondary keys into secondary strands and segregates the secondary strands by IP address as the tertiary key into client sessions .

As depicted in information flow diagram agent modeler for use in session reconstructor See analyzes the timing characteristics of individual user agents by using agent request timing modeler and load modeler and outputs agent timing models . Agent modeling is done off line in a laboratory testing environment by running precisely timed scripts on the combinations of hardware operating system and application employed by clients to use the website s services as recorded in the case of HTML webpages by the user agent field in the HTTP request headers of the transaction records received by the website. Assume the bandwidth from the website data center to the agent test systems is arranged to be at least as great as that from the website data center to any actual client.

Agent modeler inputs transaction records and extracts the agent identifier to obtain a list of user agents used to visit the website and extracts the service identifier to obtain a list of services provided by the website and provides both these identifiers to agent request timing modeler .

For each available active user agent agent modeler uses agent request timing modeler to model the agent request delay and uses agent load modeler to model the agent load delay .

Agent request timing modeler uses request timer to measure the timing characteristics of each available agent identified by agent identifier for each service used by that agent as identified by service identifier or for a statistically significant number and variety of those services and uses agent request date comparator to model the statistical distribution of the agent s request timing characteristics.

Specifically for each available active user agent and each service requested by that agent and to be tested with that agent the agent request timer runs a script on that agent to issue a statistically significant number of requests for that service from the website . The script reports back to the request timer the time at the instant it simulated a click on a hyperlink requesting the service through the agent or otherwise naturalistically caused the agent to issue a request for the service which date the request timer records as click date . The script then monitors the agent s system and reports back to the request timer the time at the instant the agent began to transmit the request which the request timer records as request send date and the time at the instant the agent finished transmitting the request which the timer records as request sent date . The request timer also records the request size . The click date request send date and request sent date are each given by the current time according to master clock to which all agents being timed are synchronized. The script also reports back the nominal request date recorded in the service request by the agent in the Date field of the HTTP request header in the case of HTML pages which the agent request timer records as service request date .

The service request date is not always available for service requests for HTTP requests for example the Date field in the HTTP Request header is optional and some browsers and other web applications provide a user interface control for blocking output of the request date.

For clients supplying a service request date through their agent agent request date comparator models the distribution of the difference between the click date and the nominal request date between the request send date and the nominal request date and between the request sent date and the nominal request date. For clients blocking the service request date the request date comparator also models the distribution of the difference between the request send date and the click date and between the request sent date and the click date. The agent request date comparator models each of these five models as a function of the request and outputs the functions as request delay model as part of agent timing model for the agent identified by agent identifier . In the simplest embodiment the agent request date comparator models each of these delays as an agent specific affine function of the request size computed by the least squares best fit each function specified by an additive bias parameter and a multiplicative rate parameter.

Agent request timing modeler uses agent load timer to measure the timing characteristics of each available agent identified by agent identifier for each service tested by agent request timing modeler and uses load date comparator to model the statistical distribution of the agent s load timing characteristics.

Specifically for each service request issued by agent request timing modeler agent timing script monitors the agent s system and reports back to agent load timer the time at the instant the agent s system begins to receive the service which the load timer records as response receipt date and reports back to the load timer the instant the agent has finished loading the service or more precisely the instant the client can respond to the service for example by clicking on hyperlinks in the case of an HTML webpage which the load timer records as service loaded date . The load timer also records the size of the service .

In the preferred embodiment if a single service request receives multiple service responses the load script and load timer track each such service separately for greater accuracy. The response receive dates and service loaded dates are given by the respective current times specified by master clock .

Load date comparator models the distribution of the difference between service loaded date and response receive date as a function of the service and outputs the function as load delay model as part of agent model .

In the simplest embodiment the load date comparator models the distribution as an agent specific affine function of the size of the service computed by the least squares best fit specified by an additive bias parameter and a multiplicative rate parameter. In the preferred embodiment the load delay model specifies separate affine parameters for plaintext versus encrypted services and for service elements of differing load speeds such as HTML images using different compression formats and timed messages that the client must attend before proceeding. In the preferred embodiment the load delay model also involves separate load delay models for cached versus uncached services.

If either the request timer or load timer fails to receive a response from the script within a reasonable amount of time typically a few seconds then it outputs a notification to the test administrators warning that the agent is taking longer than expected and specifying the agent and the service that elicited the problem.

In addition to outputting agent timing models for use by client modeler and client synchronizer See agent modeler also uses agent analyzer to output agent summary summarizing the agents used to visit the website along with their frequency of use. For those agents available for testing the agent summary also summarizes their load times for different types of services while those unavailable are marked for possible requisition for future testing. The agent summary is also useful for website development research for example to determine which agents the website should optimize for because of their popularity or to determine whether alternate forms of certain services should be provided for agents that take too long and for marketing research for example to determine customer preferences.

For efficiency agent timing modeling may be integrated with normal quality control testing of the website.

As depicted in information flow diagram client timing modeler for use in session reconstructor See estimates and tracks the timing characteristics See for each website client accessing the website during the data collection period by using client service delay modeler to measure and model the client s service delay statistics using echo timing modeler to measure and model the client s echo delay statistics or if the echo fails using trace timing modeler to measure and model the client s trace delay statistics or if the trace also fails applying the echo delay modeler or trace delay modeler to the closest responding proxy to the client located by close proxy finder and comparing the service delay estimate with the null service echo delay or trace delay.

Many Internet service providers block ping and traceroute requests to prevent their network from being mapped out by malicious clients and some individual clients also block ping requests to reduce the visibility of their systems and thus reduce the number of network attacks on their systems.

Client timing modeler inputs client transaction records and extracts the client identifier to obtain a list of all clients active during the data collection period which it provides to client service timing modeler client echo timing modeler client trace timing modeler and close proxy finder . For each client transaction the client timing modeler uses the service timing modeler to estimate the service delay based on service request date if available user agent identifier request size and service identifier which are obtained from the transaction record. The client identifier consists of the IPv6 or IPv4 address and port number in the TCP or UDP packet header the port number being necessary for clients in a private network behind a router firewall or other proxy. In the case of HTML webpages the service request date is originally from the Date field in the HTTP Request header and the user agent is from the User Agent field. The request size is obtained either from the sum of the HTTP header lengths and the value of the Content Length field or from the TCP or UDP length fields.

During the data collection period client service timing modeler uses client service timer to measure the timing characteristics of each active client identified by client identifier and uses client service date comparator to model the statistical distribution of the client s service delay characteristics . Specifically at the moment each client action See is received by website traffic processor See client service timer outputs service receipt date timestamp from the current time given by master clock .

For each service transaction client service date comparator calculates the client s service request delay from the service request date timestamp if available the user agent identifier the request size the server traffic processor s service receipt date timestamp and the user agent model identified by the client identifier and outputs a model of the distribution as client service delay model . The client service date comparator is detailed under .

During the same measurement period client echo timing modeler uses echo timer to measure the null agent timing characteristics of each active client and uses echo date comparator to model the statistical distribution of the null agent timing characteristics. Specifically for an active client the echo timer issues a statistically significant number of echo requests of various sizes to the client or a close proxy outputting echo send date timestamp the moment it sends the echo request and outputting echo receipt date timestamp the moment it has received the echo response back from the client each timestamp being given by the respective current time given by master clock . The echo timer also records the echo request size .

When echo response is delayed by more than a reasonable threshold typically no more than a few seconds dependent on the distance to the client and on current network conditions then echo timing modeler aborts the ping attempt under the assumption that the client is blocking ping requests and the client timing modeler attempts trace timing instead.

For each active client echo date comparator calculates the difference between each echo receipt time and corresponding echo send time for a statistically significant sample of echo requests of various sizes and outputs a model of the distribution of the result as echo delay .

In the simplest embodiment the client specific echo delay model comprises half the mean echo time for each direction and half the echo time variance for each direction each as an affine function of the size of the echo request computed by the least squares best fit where the function is specified by an additive bias parameter and a multiplicative rate parameter.

The preferred embodiment also takes into account any known speed and bandwidth asymmetries in the transmission rate of the Internet connection on either end as determined for some clients from the client s IP address by partitioning the roundtrip echo time into two portions inversely proportional to the throughput in that direction and likewise proportionately scaling the variance for each direction.

Trace timing modeler has traceroute timer issue traceroute requests to the same client or close proxy with stepwise increasing time to live values until either the target node is reached or trace route response is delayed by more than a reasonable threshold again typically no more than a few seconds dependent on the distance to the client and on current network conditions. If the last response occurs within a plausible delay considering the distance and network conditions then the trace timer outputs echo send date timestamp corresponding to the moment it sent the last successful traceroute request and outputs trace receipt date timestamp corresponding to the moment it received the last successful traceroute response back from the client each timestamp being given by the respective current time according to master clock . The trace timer also records the trace request size .

Analogously to echo date comparator trace date comparator calculates the difference between each final trace receipt time and corresponding trace send time for a statistically significant sample of trace requests of various sizes and outputs a model of the distribution of the result as trace delay .

In the simplest embodiment the client specific trace delay model comprises half the mean trace time for each direction and half the trace time variance for each direction each as an affine function of the size of the trace request computed by the least squares best fit where the function is specified by an additive bias parameter and a multiplicative rate parameter. Again the preferred embodiment also takes into account any known speed and bandwidth asymmetries in the transmission rate of the Internet connection on either end as determined for some clients from the client s IP address .

If neither the echo timing modeler nor the trace timing modeler succeeds in fixing the roundtrip delay to the actual client then the client timing modeler uses close proxy finder to find the IP address of a nearby ping proxy. The close proxy finder first uses address locator to look up the node location of the actual client from the client s IP address . Then proxy finder finds the ping proxy closest to that node location outputting its IP address as target address . The client timing modeler then substitutes the ping proxy s IP address for use by echo timing modeler and trace timing modeler . In case the selected ping proxy also fails the client timing modeler uses the close proxy finder iteratively to find another ping proxy until one succeeds.

Finally for each active client or at least some clients client delay comparator compares the distribution of the client s service request delay with the distribution of the client s echo delay or traceroute delay outputting a model of the distribution of the result as client timing model . In the simplest embodiment the client timing model comprises the echo request delay or trace request delay as a pair of affine functions of request size one for the transmit direction and one for the receive direction each function specifying the mean behavior with an additive bias parameter and a multiplicative rate parameter as well as the variance in the transmit direction and if the request dates are supplied by the client the difference between the client s service request delay and the echo request delay or trace request delay giving the mean client clock bias and its variance. For websites with more than one data center the client timer generates a separate model for each geographically separate data center.

In addition to outputting client timing models for use by client synchronizer See client timing modeler also uses client analyzer to output client summary summarizing the clients visiting the website along with their IP addresses geographic locations and timing characteristics including whether they supply request dates and respond to ping requests. The client summary is also useful for website development research for example to determine whether to provide more lavish services for clients with large connection bandwidths and short connection lags or more meager services for clients with small connection bandwidths and long connection lags and for marketing research to determine where customers are located and what kind of connections they have.

Information flow diagram depicts client service date comparator See which uses agent delay estimator to estimate the agent delay differencer to measure the raw service delay differencer to compare these two estimates and service delay modeler to model the service delay .

For each service transaction agent delay estimator uses agent model fetcher to fetch the agent model identified by agent identifier from agent models . If the transaction record does not specify the agent the agent delay estimator uses the default agent model whose parameters are set to the modal values of the known agents active during the data collection period.

In the simplest embodiment shown here the agent request timing model comprises agent specific request bias parameter and agent specific request rate parameter . Multiplier then multiplies the agent request rate by the request size outputting the product as agent request lag . Adder then adds the agent request bias to the agent request lag outputting the sum as total agent delay .

Likewise for each service transaction differencer calculates the difference between service receipt date timestamp and service request date timestamp outputting the difference as raw service delay . Differencer then computes the difference between the raw service delay and the agent delay output by agent delay estimator for the same request outputting the difference as service delay model .

Finally for each client as identified by client identifier service delay modeler models the distribution of the service and outputs a model of the distribution of this difference as service delay model . In the simplest embodiment the service delay model gives the service request delay as the mean service delay for that client which is the least squares best fit model.

As depicted in information flow diagram client synchronizer for use in session reconstructor See inputs one client transaction record at a time and uses variance comparator click date estimator and load date estimator and transaction record editor to synchronize the transaction with load date and click date estimates outputting corresponding synchronized client transaction record .

Click date estimator using information from the input client transaction record the client model identified by the client identifier in the input transaction record and the agent model identified by the agent identifier in the input transaction record outputs click date estimate accurately estimating the instant that the client requested the target service from the website such as by clicking on a hyperlink in the source service according to the network service threat detector s master clock. The click date estimator is detailed under .

Similarly load date estimator using information from the client model the server model the service model and the agent model as identified by the client identifier the server identifier the service identifier and the agent identifier respectively in the input transaction record in addition to the click date output by click date estimator for the same transaction record outputs load date estimate accurately estimating the instant at which the client s agent finished loading the source service to the point when the client was able to act upon it for example by clicking on a hyperlink according to the network service threat detector s master clock. The load date estimator is detailed under .

The click date estimator can estimate the click date based either on the request date timestamp recorded by the client when available or on the server s request receive date recorded by the server synchronizer. The client based click time estimate is ordinarily more accurate because it depends only on the ordinarily constant client clock bias and brief agent click delay whereas the server based estimate depends on highly variable transmission time from the client and server which cannot be estimated as accurately. Similarly the load date estimator can estimate the load date based either on the load date timestamp recorded by the client using an embedded load timer when available or on the server s service send date timestamp recorded by the server synchronizer. Again the client based load time estimate is ordinarily much more accurate because it depends only on the ordinarily constant client clock and brief agent click delay whereas the server based estimate depends on highly variable transmission time from the server to the client and on highly variable load time by the client neither of which can be estimated as accurately. On the other hand the date timestamps issued by the client are both unreliably present being optional for example in the HTTP Request header specification and untrustworthy in that fraudsters can tamper with them directly.

Variance comparator first checks whether the client request date and the client load date are available in input client transaction record . If either one is available the variance comparator compares the variance in the client s transmission bias to the variance in the client s clock bias as determined by the client model identified by the client identifier in the input transaction record. If the difference between the clock bias variance and the transmission bias variance is greater than variance threshold then the client s clock is deemed untrustworthy otherwise it is deemed trustworthy where the variance threshold is typically set to a value between zero and a few centiseconds.

If the client request date is available and the client s clock is deemed trustworthy then the variance comparator sets click date estimator switch to use the request based click date estimator else it sets it to use the receive based click date estimator. Similarly if the client load date and the client request date are available and the client s clock is deemed trustworthy then the variance estimator sets load date estimator switch to use the request based load date estimator else it sets it to use the send based load date estimator.

As depicted in information flow diagram for each input client transaction record click date estimator for use in client synchronizer See either uses receive based click date estimator to output receive based click date estimate or uses request based click date estimator to output request based click date estimate depending on the value of the click date estimator switch .

For receive based click date estimator agent model fetcher looks up the agent model identified by agent identifier in transaction record outputting agent request rate and agent request bias modeling the delay between the instant the client requests a service for example by clicking on a hyperlink in the source service and the instant the client begins transmitting the request. Likewise client model fetcher looks up the client model identified by client identifier in the transaction record outputting client transmission rate and client transmission bias modeling the delay between the instant the client begins transmitting a request and the instant the server receives it.

Multiplier multiplies agent request rate by the size of the request obtained from transaction record outputting the product as request duration estimate . Multiplier multiplies the client transmit rate by request size outputting the product as transmit duration estimate . Maximum operator then computes the maximum of these two values outputting the result as total request duration estimate . Adder adds agent request bias and client transmission bias outputting the sum as total request bias estimate . Adder then adds the request duration to the request bias outputting the sum as request delay estimate . Finally subtractor subtracts the request delay from the server request receive date obtained from the client transaction record outputting the difference as receive based click date estimate .

For request based click date estimator agent model fetcher looks up the agent model identified by agent identifier in transaction record outputting agent click rate and agent click bias modeling the delay between the instant the client requests a service for example by clicking on a hyperlink in the source service and the request date recorded by the agent in the client transaction record with a synchronized clock. Client model fetcher looks up the client model identified by client identifier in the transaction record outputting client clock bias modeling the difference between the client s clock setting and the network service threat detector s master clock.

Multiplier multiplies agent click rate by request size outputting the product as agent click duration estimate . Adder then adds the click duration to agent click bias outputting the sum as agent click delay estimate . Adder then adds the agent click delay to client clock bias outputting the sum as total click delay estimate . Finally adder adds the click delay to request date outputting the result as request based click date estimate .

As depicted in information flow diagram for each input client transaction record load date estimator for use in client synchronizer See FIG. either uses load duration estimator and load bias estimator to output send based load date estimate or outputs request based load date estimate depending on the value of load date estimator switch .

Service model fetcher looks up the service model identified by service identifier in client transaction record outputting service duration to the server sent duration estimator multiplier and outputting service size to the client receive duration estimator multiplier and agent load duration estimator multiplier .

Server model fetcher looks up the server model identified by server identifier in client transaction record outputting server service sent rate and server service sent bias modeling the delay between the instant the server begins sending a service to the instant it finishes sending it. Likewise client model fetcher looks up the client model identified by client identifier in the transaction record outputting client service receive rate and client service receive bias modeling the transmission delay between the instant the server begins sending a service and the instant the client finishes receiving it. Likewise agent model fetcher looks up the agent model identified by agent identifier in the transaction record outputting agent service load rate and agent service load bias modeling the delay between the instant the agent begins receiving the service and the instant the agent finishes loading the service to the extent that the client can act on it.

Load duration estimator uses multiplier to multiply server sent rate by service duration outputting the product as sent duration estimate uses multiplier to multiply client receive rate by service size outputting the product as receive duration estimate and uses multiplier to multiply agent load rate by service size outputting the product as load duration . The load duration estimator then uses maximum operator to compute the maximum value among the sent duration receive duration and load duration outputting the maximum as load duration estimate .

Load bias estimator uses adder to add server sent bias client receive bias and agent load bias outputting the result as total load bias .

Load date estimator then adds load duration to load bias outputting the sum as total load delay estimate . Finally adder adds the load delay to server send date in client transaction record outputting the result as send based load date estimate .

Differencer subtracts request date specified in client transaction record from click date output by request based click date estimator See outputting the difference as click delay . Alternatively the click date estimator could pass the click delay directly to the load date estimator. Adder then adds the click delay to the load date obtained from the client transaction record outputting the sum as request based load date estimate .

Information flow diagram depicts timed transition event analyzer a particularly simple exemplary type of session analyzer for use in network service threat detector See which analyzes client transaction sessions into atomic session events or elemental session events comprising timed transitions and repackages them as client event sessions for efficient processing by session modeler and session comparator of . In a more complex embodiment the session analyzer analyzes client sessions into overlapping trigrams or larger chunks when there are sufficient statistics and includes other client distinguishing information.

The source names and target names may be either URLs from HTTP transaction records or internal service names provided by the website in a rearguard deployment. In the embodiment shown service names are tokenized for efficiency in session analyzer . In an alternative embodiment they are tokenized earlier in session reconstructor or even in both website analyzer and record augmenter See .

Source encoder tokenizes source name to output source identifier where the source name is the service name held over from the previous session transaction record. Similarly target encoder tokenizes target service name to output target identifier . The source encoder and target encoder encode a service name by looking up the name in a dictionary and returning the corresponding token typically a hash of the name inserting the name in the dictionary and thereby generating a token for it if the service name was not already entered in the dictionary. The token has the precision of a standard binary word in the machines embodying the threat detector for efficient lookup comparison and other manipulation.

Duration encoder encodes transition duration to output transition duration identifier where the transition duration is computed as the difference between the click date the estimated instant when the client requested the target service and the source load date the load date held over from the previous session transaction record the estimated instant when the client was first able to request the service . In one embodiment the duration encoder simply outputs the quantitative transition time to the precision of a standard binary word. In an alternative embodiment the duration encoder coarsely quantizes the transition time on an exponential scale and tokenizes the quantized intervals for efficient access in a sparse array. A sample exponential scale is 0 . . . 1116 1 16 . . . . . . . . . 112 . . . 1 1.2 2 . . . 0.4 4 . . . 8 8 . . . seconds. A quantitative representation is preferable for atomic session analysis where each individual event in each session is considered separately for accuracy. A tokenized representation is preferable for elemental session analysis where all events of a type within a session are lumped together and treated as a group.

Transition encoder encodes the ordered pair comprising source identifier and target identifier as shown or equivalently comprising source name and target name to output a single transition identifier identifying the transition from the source to the target.

Timed source encoder encodes the combination of source identifier and time interval identifier as shown or equivalently the combination of source name and transition time to output timed source identifier . Similarly timed target encoder encodes the combination of target identifier and time interval identifier as shown or equivalently the combination of target name and transition time to output timed target identifier .

Optional linkage encoder looks up source identifier and target identifier as shown or equivalently source name and target name in website map to determine the linkage type and encodes the linkage type as linkage identifier .

Extrinsic transitions within a session may indicate a hijacking attack. However certain extrinsic links are provided by web browsers and similar applications typically accessed by buttons or menu items in the application user interface including a back feature to return to the previous service in the session a history function to return to other services recently visited by the client and a bookmarks function to return to services previously marked by the client. In the simplest embodiment the linkage encoder classifies links into one of three categories intrinsic back step and extrinsic. In a more complex embodiment the linkage encoder also recognizes back skips to previous services within the current session as a fourth category. Extrinsic links can also be provided by external sources such as websites and email messages and the linkage encoder recognizes such inbound links by the referrer when present in the client action record and classifies them as yet another linkage type.

For elemental session analysis session analyzer uses event type counter to first check whether an existing session event has matching identifiers in this case matching source identifier matching target identifier and matching duration identifier and if available matching linkage identifier and if so merely increments the event type count for that event type rather than encoding the derivative identifiers and packing a separate session event.

Session event record packer assembles source identifier target identifier transition duration identifier timed source identifier transition identifier and timed source identifier into session event record . If available the session event packer also records linkage type identifier in the session event record. For elemental session events the session event packer also stores the event type instance count in the session event record.

Output client event session may be either an atomic event session listing each individual event as a separate record or an elemental event session digest grouping equivalent events into a single record. For atomic session analysis session event packer simply appends each session event record to the current atomic client event session on the fly. For elemental session analysis the event type counter merges equivalent event records within a session maintaining an instance count in the event record for each event type.

In the exemplary embodiment shown the compound attributes service transition timed source and timed target are encoded in session analyzer saving time later in session modeler and session comparator of but at the expense of the space required to store the additional identifiers in the session event records. In an alternative embodiment compound attributes are encoded on the fly whenever needed saving space at the expense of time.

Information flow diagram depicts timed transition event modeler a particularly simple type of session modeler for use in network service threat detector See whose session models comprise event models modeling not entire sessions but only the atomic or elemental transition events of which sessions are composed and modeling only the global statistics of the most rudimentary characteristics of those events the identities of the constituent services of a transition and the duration of the transition along with joint combinations of those characteristics.

In particular event modeler models the global statistics during the data collection period of a transition s source transition duration and target as well as of joint source and target pairs joint transition duration and target pairs and joint source and transition duration pairs. When linkage information from a website map is available the event modeler also models the global statistics of linkage types during the data collection period. In detail for each session event record or session type record source model updater updates the source frequency corresponding to the source identifier transition duration model updater updates the transition duration frequency corresponding to transition duration identifier target model updater updates the target frequency corresponding to target identifier timed target model updater updates the timed target frequency corresponding to timed target identifier transition model updater updates the transition frequency corresponding to service transition identifier timed source model updater updates the timed source frequency and linkage model updater optionally updates linkage type frequency corresponding to linkage type identifier where the source identifier duration identifier target identifier timed target identifier transition identifier timed source identifier and linkage type identifier are obtained from the session event record and the corresponding models are updated in event models database . In addition event frequency updater updates event frequency in the event models database.

Source frequencies are modeled separately from target frequencies because the distribution of source frequencies is not in general identical to the distribution of target probabilities because for example a login page is relatively unlikely to be a target and a logout page is unlikely to be a source since client sessions often begin with a login page and end with a logout page.

Event modeler is designed to operate on either atomic session event records or on elemental session event type records where each event type record contains an instance count in addition to the identifiers. When operating on atomic session event records the event modeler updates source frequency duration frequency target frequency timed target frequency transition frequency timed source frequency linkage frequency and event frequency by simply incrementing each frequency by one the default value of increment . When operating on elemental session event records the event modeler updates these frequencies by incrementing each one by the session count input as increment .

Moreover the event modeler is designed to operate either in batch mode for example for processing from scratch the entire set of website transactions during a data collection period such as one hour or in continual mode for incrementally updating the models on the fly with a sliding window for example by adding each transaction or each minute s worth of transactions as it occurs and removing each transaction or increment of transactions as it ages beyond the data collection period of say one hour. When operating in continual mode switch changes the increment to negative one to remove an atomic event record and changes the increment to the negative of the instance count to remove an event type record from the running frequencies as specified by remove flag .

In an alternative embodiment the joint keys transition identifier timed source identifier and timed target identifier are not directly stored in session event but are constructed from the elemental keys source identifier transition time and target identifier as appropriate on the fly by transition model updater timed source model updater and timed target model updater respectively. This alternative is preferable when the storage space available to store keys in session event records is more critical than the time required to generate the joint keys.

Information flow diagram depicts an independent event session comparator a particularly simple type of session comparator for use in network service threat detector See which scores each event in a client event session independently using session event stepper and event comparator and uses session scorer to combine the event scores into session threat score . The session comparator also optionally uses privilege threat analyzer to weight each event score according to the client s privilege level for the event and also optionally uses intrinsic threat analyzer to weight each event score according to the intrinsic threat level of the event.

Session event stepper steps through the elemental event type records or chronologically sorted atomic event records in client session outputting them one at a time as session events to event comparator .

Event comparator compares each event or event type to the model for that event type outputting event anomaly score for that event. For elemental events the event comparator also outputs the number of instances of that event type from the event type record. The event comparator is discussed further in connection with .

For atomic events session scorer uses score accumulator to accumulate the individual event anomaly scores outputting threat score for the session as a whole. In the preferred embodiment the event anomaly scores are additive rather than multiplicative See to facilitate accumulating the scores for the many events in a long session without overflow. In the simplest embodiment the session scorer simply adds all the event anomaly scores to produce the session threat score. For elemental events the session scorer uses multiplier to multiply the anomaly score for each event type by the number of instances of that event type outputting the result as event score in which case score accumulator sums the events scores instead of the event anomaly scores to compute the session threat score.

In the preferred embodiment for evaluating session hijacking threats such as man in the browser threats and man in the middle threats where to avoid detection to complete their fraudulent privileged transactions before the client closes the session and to maximize the number of sessions hijacked under human supervision attackers are motivated to hijack a session as quickly and soon as possible after the client has successfully gained privileged access to a website session comparator uses privilege threat analyzer to compute a time damped weight according to how soon after login the corresponding anomalous event has occurred. This computation may be based on the session event records and in some embodiments event index output by session event stepper and for elemental events event instance count . For websites offering multiple echelons of privilege the privilege threat analyzer also weights the event score according to the privilege level. Privilege threat analyzer is discussed in connection with .

When using privilege threat analyzer session scorer uses multiplier to multiply the score for each event or event type by corresponding privilege weight outputting the result as weighted event score in which case the session scorer sums the weighted event scores rather than unweighted event scores to produce session threat score .

If website map containing information concerning intrinsic threat levels is available See then the session comparator also takes intrinsic threat levels into account using intrinsic threat analyzer to determine the intrinsic threat weight for each event or event type in order to weight different intrinsic threat levels according to the preferences of the website security personnel.

In detail intrinsic threat analyzer uses intrinsic threat fetcher to look up the intrinsic threat level associated with session event in website map outputting the result as intrinsic threat level . Intrinsic threat scorer then looks up the intrinsic threat score corresponding to the intrinsic threat level in table of intrinsic threat scores outputting the result as intrinsic weight .

When using intrinsic threat analyzer session scorer uses multiplier to multiply the score for each event or event type by corresponding intrinsic threat weight outputting the result as weighted event score . When using both the intrinsic threat analyzer and privilege threat analyzer the session scorer first uses multiplier to multiply the intrinsic threat weight by the privilege weight outputting the result as event weight . It then multiplies the event weight by the event score to yield the weighted event score. In either case the session scorer then sums the weighted event scores rather than the unweighted event scores to produce session threat score .

As depicted in information flow diagram privilege threat analyzer analyzes the privilege related threat of each input session event or session event type using privilege analyzer privilege ager aged privilege rescaler and privilege scorer and outputting privilege weight .

Specifically for atomic session events privilege threat analyzer uses privilege analyzer to monitor the chronologically sorted input events for privilege altering events such as login and logout events secondary authentication events and HTTP Upgrade events outputting the current privilege level at the time of each event and the privilege duration which characterizes the duration since the client last acquired that privilege level within the session.

In the preferred embodiment the privilege duration for a particular privilege level is the total client response delay computed by summing the transition durations in each session event since the acquisition of that level of privilege thereby discounting the phases when the client would ordinarily be waiting rather than acting including the transmission time the serve time and the load time. In an alternative embodiment the privilege duration is the elapsed time since the instant of acquisition of that level of privilege calculated as the difference between the time of the current event and the time of the privilege acquisition event. In another alternative embodiment the privilege duration is the number of client transactions since acquiring that privilege level calculated as the difference in event index output by session event stepper See since the privilege was acquired.

Privilege ager converts the privilege duration to a time damped weight outputting it as aged privilege where the damping is governed by weight decay . Specifically when the privilege duration is measured as elapsed time the privilege ager uses multiplier to multiply the privilege duration by the weight decay outputting the product as weighted age and then uses exponentiator to take the exponential value of the weighted age outputting the result as aged privilege where for time measured in seconds the weight decay is typically around the natural logarithm of two so that the weight drops from 1 at the instant of privilege acquisition to a second later to at the end of 2 seconds. When the privilege duration is measured in terms of the number of transition events the aged privilege may alternatively be calculated recursively by initializing it to 1 at the privilege acquisition event and multiplying the result by the weight decay at each subsequent event.

For elemental session events although neither the date nor the chronological event index is known for individual events nevertheless if session analyzer See includes the privilege level in its event classification then event types repeated within a session can be effectively aged by the minimal duration implied by the number of instances of that event type in the session. Thus for elemental session events privilege pseudo ager effectively ages each repeated event type by the number of instances that must have preceded it in the simplest embodiment by multiplying the weight decay by itself as often as the event instance count and summing the partial products outputting the sum as pseudo aged privilege . The preferred embodiment implements the closed form formula for the geometric series d d d 1 by using incrementer to add 1 to the event instance count n outputting the result as exponent p n 1 using power operator to raise the weight decay to that exponent outputting the result as power using subtractor to subtract the weight decay from the power outputting the result as numerator and using divider to divide the numerator by divisor where the divisor is computed by using decrementer to subtract one from the weight decay the final result being output as pseudo aged privilege .

Rescaler rescales the damped series of aged privilege weights to a minimum specified by weight floor by using complementer to subtract the weight floor from 1 outputting the difference as floor complement using multiplier to multiply the floor complement by aged privilege outputting the result as scaled privilege and using adder to add the scaled privilege to the weight floor outputting the result as decayed weight . A positive weight floor ensures that hijackers will continue be detected even if they change their behavior to postpone their fraudulent transactions later in a session.

Privilege scorer looks up privilege score corresponding to privilege level in table of privilege scores to weight different privilege levels according to the preferences of the website security personnel. Typical privilege score values for a website using logins with both password and secondary authorization are 0.1 for unlogged in 0.9 for logged in with a password and 1.0 for secondarily authorized but other score values could be used.

Finally multiplier multiplies the privilege score by the decayed weight outputting the result as privilege weight .

In an alternative embodiment privilege level is determined beforehand by session analyzer and stored in session event records See .

As depicted in information flow diagram event comparator compares a session event which is either an atomic session event or an elemental session event type to the event models for that type of event and outputs corresponding event anomaly score . In MiB MiM and similar types of hijacking attacks a fraudster uses a website account concurrently with a legitimate client of the account. The hijacker s website actions are thus interspersed with the legitimate client s actions.

In order to maximize the chance of completing the fraudulent transactions and minimize the chance of being discovered the fraudster s actions need to be executed quickly and early in the login session. Therefore the hijacker does not have the leisure to insert actions at appropriate junctures in the legitimate client s flow. As a result the combined flow of the client s and fraudster s actions shortly after login is likely to exhibit transitions which are anomalous often not intrinsic to the website and anomalously quick for normal sessions in general and especially for normal sessions of the victim. Moreover the flow of the fraudster s actions alone is likely to exhibit transitions which are anomalous non intrinsic and anomalously quick for normal sessions in general and especially for normal sessions of the victim because the hijacker is likely to use a streamlined flow skipping normal but strictly unnecessary intermediate steps and is likely to automate that flow.

Thus event comparator examines both the relative frequency and the relative duration of the event comparing the observed frequency of the event type with the predicted frequency of the event type as well as comparing the observed duration of the event or event type with the predicted duration of the event type.

In detail event frequency estimator estimates the relative frequency of session event type from event models outputting observed event frequency .

Event duration estimator estimates the duration of the event outputting observed event duration . When session event is provided by atomic session stepper See duration estimator merely extracts the event duration as adjusted by transaction synchronizer See from the session event record. When on the other hand the session event is provided by session event type stepper See and the duration of individual events in the session is not known but the event type is specific to a coarsely quantized time interval then the event duration estimator estimates the event duration as the mean duration of the event type or if that information is unavailable the event duration is estimated as the mean duration of the quantized time interval either of which is retrieved from event models .

The event comparator uses one or more event frequency predictors to predict the event frequency from marginal event frequencies retrieved from event models each event frequency predictor outputting a corresponding event frequency prediction . Exemplary individual event frequency predictors are described under through and a combined event frequency predictor factoring out common operations among these four exemplary individual predictors is described under .

Corresponding to each event frequency predictor is an event duration predictor which predicts the duration of the event or event type from event models corresponding to those used in the event frequency predictors each event duration predictor outputting a corresponding event duration prediction .

Optional anomalous event duration detector compares each individual event duration prediction with observed event duration outputting predictor switch signal to turn individual event frequency predictors off for computational efficiency when the observed event duration is determined not to be anomalously brief by a particular event duration prediction.

The anomalous event duration detector determines an event to be anomalously brief if the observed duration is less than the predicted duration minus a duration threshold or by another test. In the preferred embodiment the duration threshold is zero in order to postpone threat decisions until the anomaly of the entire session can be compared to the anomaly of all other sessions. Alternatively if the number of detected attacks is expected to be substantially greater than threat processors See can handle then the duration threshold can be adjusted upwards to throttle the least threatening events. The anomalous event duration detector is used as an efficiency optimization in embodiments where it reduces the computation time or other resource demands.

Prediction combiner combines the individual event frequency predictions and corresponding event duration predictions into a single predicted event frequency and a single corresponding predicted event duration . The prediction combiner is detailed under .

Event frequency scorer compares predicted event frequency with observed event frequency taking frequency threshold into account and outputs frequency anomaly score . In one embodiment the event frequency scorer is switched off if duration anomaly score is below duration threshold for computational efficiency. The event frequency scorer is discussed in greater detail under .

Event duration scorer compares predicted event duration with observed event duration taking duration threshold into account and outputs duration anomaly score . In one embodiment the event duration scorer is switched off if the frequency anomaly score is below frequency threshold for computational efficiency. The event duration scorer is discussed in greater detail under .

Event anomaly scorer inputs frequency anomaly score and duration anomaly score and outputs event anomaly score . If either the frequency anomaly score or the duration anomaly score is non positive the event anomaly scorer outputs an event anomaly score of zero. In the preferred embodiment the event anomaly scorer combines the frequency anomaly score and duration anomaly score by multiplying them together where the resulting product can be interpreted as the point wise mutual information between the terms of the event weighted by the anomalousness briefness of the event.

As depicted in atomic timed transition predictor uses source model fetcher to look up source frequency corresponding to source identifier transition duration model fetcher to look up transition duration frequency corresponding to transition duration identifier target model fetcher to look up target frequency corresponding to target identifier optional linkage model fetcher to look up linkage type frequency corresponding to linkage identifier and frequency norm fetcher to look up event frequency norm where the source identifier duration identifier target identifier and linkage type identifier are input from session event and the corresponding models and the frequency norm are retrieved from event models . Multiplier then multiplies together the source frequency the duration frequency the target frequency and optionally the linkage frequency outputting the product as absolute AxTxB frequency . Power operator multiplies the frequency norm to the fourth power outputting the result as quadruple norm . Finally normalizer divides the absolute AxTxB frequency by the quadruple norm outputting the relative frequency as independent frequency prediction AxTxB . If the linkage frequency is not included in the combined frequency computation then the power operator only raises the norm to the third power.

In atomic timed transition predictor duration model fetcher also looks up duration corresponding to duration identifier in session event record which it outputs as duration . Multiplier multiplies the duration by the duration frequency outputting the product as total duration . Divider then divides the total duration by the absolute atomic frequency outputting the quotient as independent duration prediction .

As depicted in biased frequency predictor TxAB uses transition duration model fetcher to look up transition duration frequency corresponding to transition duration identifier transition model fetcher to look up transition frequency corresponding to transition identifier and frequency norm fetcher to look up event frequency norm where the duration identifier and transition identifier are input from session event and the corresponding models and the frequency norm are retrieved from event models . Multiplier then multiplies together the duration frequency and the transition frequency outputting the product as absolute TxAB frequency . Power operator squares the frequency norm outputting the result as double norm . Finally normalizer divides the absolute TxAB frequency by the double norm outputting the relative frequency as biased frequency prediction TxAB .

In biased predictor TxAB duration model fetcher also looks up duration corresponding to duration identifier in session event record which it outputs as duration . Multiplier multiplies the duration by the duration frequency outputting the product as total duration . Divider then divides the total duration by the absolute TxAB frequency outputting the quotient as biased duration prediction TxAB .

As depicted in biased frequency predictor BxTA uses target model fetcher to look up target frequency corresponding to target identifier timed source model fetcher to look up timed source frequency corresponding to timed source identifier optional linkage model fetcher to look up linkage type frequency corresponding to linkage identifier and frequency norm fetcher to look up event frequency norm where the target identifier timed source identifier and linkage type identifier are input from session event and the corresponding models and the frequency norm are retrieved from event models . Multiplier then multiplies together the target frequency the timed source frequency and optionally the linkage frequency outputting the product as absolute BxTA frequency . Power operator multiplies the frequency norm to the third power outputting the result as triple norm . Finally normalizer divides the absolute BxTA frequency by the triple norm outputting the relative frequency as biased frequency prediction BxTA . If the linkage frequency is not included in the combined frequency computation then the power operator only raises the norm to the second power.

In biased predictor BxTA timed source model fetcher also looks up duration corresponding to timed source identifier in session event record which it outputs as duration . Multiplier multiplies the duration by the timed source frequency outputting the product as total duration . Divider then divides the total duration by the absolute BxTA frequency outputting the quotient as biased duration prediction BxTA .

Similarly as depicted in biased frequency predictor AxTB uses source model fetcher to look up source frequency corresponding to source identifier timed target model fetcher to look up timed target frequency corresponding to timed target identifier optional linkage model fetcher to look up linkage type frequency corresponding to linkage identifier and frequency norm fetcher to look up event frequency norm where the source identifier timed target identifier and linkage type identifier are input from session event and the corresponding models and the frequency norm are retrieved from event models . Multiplier then multiplies together the source frequency the timed target frequency and optionally the linkage frequency outputting the product as absolute AxTB frequency . As in AxTB frequency predictor See power operator multiplies the frequency norm to the third power outputting the result as triple norm . Finally normalizer divides the absolute AxTB frequency by the triple norm outputting the relative frequency as biased frequency prediction AxTB . If the linkage frequency is not included in the combined frequency computation then the power operator only raises the norm to the second power.

In biased predictor AxTB timed target model fetcher also looks up duration corresponding to timed target identifier in session event record which it outputs as duration . Multiplier multiplies the duration by the timed target frequency outputting the product as total duration . Divider then divides the total duration by the absolute AxTB frequency outputting the quotient as biased duration prediction AxTB .

As depicted in combined timed transition predictor uses source model fetcher to look up source frequency corresponding to source identifier transition duration model fetcher to look up transition duration frequency corresponding to transition duration identifier target model fetcher to look up target frequency corresponding to target identifier timed target model fetcher to look up timed target frequency corresponding to timed target identifier transition model fetcher to look up transition frequency corresponding to transition identifier timed source model fetcher to look up timed source frequency corresponding to timed source identifier optional linkage model fetcher to look up linkage type frequency corresponding to linkage identifier and frequency norm fetcher to look up event frequency norm where the source identifier transition duration identifier target identifier timed target identifier transition identifier timed source identifier and linkage type identifier are input from session event and the corresponding models and the frequency norm are retrieved from event models .

Multiplier squares the frequency norm outputting the result as double norm multiplier multiplies the double norm again by the norm outputting the result as triple norm and multiplier multiplies the triple norm yet again by the norm outputting the result as quadruple norm .

As in independent frequency predictor AxTxB atomic frequency predictor AxTxB multiplies together the source frequency the duration frequency the target frequency and optionally the linkage frequency dividing the resulting absolute AxTxB frequency by quadruple norm and outputting the resulting relative frequency as independent frequency prediction AxTxB . As in biased frequency predictor AxTB biased frequency predictor AxTB multiplies together the source frequency the timed target frequency and optionally the linkage frequency dividing the resulting absolute AxTB frequency by triple norm and outputting the resulting relative frequency as biased frequency prediction AxTB . As in biased frequency predictor TxAB biased frequency predictor TxAB multiplies together the duration frequency and the transition frequency dividing the resulting absolute TxAB frequency by double norm and outputting the resulting relative frequency as biased frequency prediction TxAB . And as in biased frequency predictor BxTA biased frequency predictor BxTA multiplies together the target frequency the timed source frequency and optionally the linkage frequency dividing the resulting absolute BxTA frequency by triple norm and outputting the resulting relative frequency as biased frequency prediction BxTA . If the linkage frequency is not included in the combined frequency computations then the AxTxB predictor uses the triple norm instead of the quadruple norm and the AxTB predictor and BxTA predictor use the double norm instead of the triple norm.

In an alternative embodiment the joint keys transition identifier timed source identifier and timed target identifier are not directly stored in session event but are constructed from the elemental keys source identifier transition time and target identifier as appropriate on the fly by transition model fetcher timed source model fetcher and timed target model fetcher respectively. This alternative is preferable when the storage space available to store keys in session event records is more critical than the time required to regenerate the joint keys.

In an alternative embodiment double frequency norm triple frequency norm and quadruple frequency norm are pre computed and stored in event models rather than being computed in the event predictor. This alternative is preferable when memory access is quicker than multiplication.

In an alternative embodiment the marginal frequencies source frequency duration frequency and target frequency and sub marginal frequencies transition frequency timed source frequency and timed target frequency are not pre computed and stored in event models database but are instead computed on the fly from atomic events or from elemental frequencies by the marginal frequency fetchers source frequency fetcher duration frequency fetcher and target frequency fetcher and intermediate frequency fetchers transition frequency fetcher timed source frequency fetcher and timed target frequency fetcher respectively. This alternative embodiment is preferable when the storage space available for event models is more critical than the time available to compute the marginal and sub marginal frequencies on the fly.

The marginal frequencies source frequency duration frequency and target frequency and submarginal frequencies transition frequency timed source frequency and timed target frequency as stored in event models database and output by the respective frequency fetchers may be either absolute in which case they can be represented exactly as integers or relative in which case they must be represented as approximate fractions or as space inefficient rational numbers.

However whereas atomic prediction is a product of three marginal frequencies the sub marginal predictions transition prediction timed source prediction and timed target prediction are products of only two frequencies so if these products are computed from absolute frequencies then to make the atomic frequency commensurate with the sub marginal frequencies either the sub marginal frequencies must be multiplied by the norm permitting the products to continue to be represented exactly as integers or the atomic prediction must be divided by the norm in which case the product must be approximated as a fraction or maintained as a rational number. This commensuration may be implemented at any stage between the end of event frequency predictors and the beginning of prediction combiner . Note that at least for straightforward relative frequency estimation all the atomic marginal and sub marginal frequencies have the same norm which is the total timed transition frequency obtained from the event models database.

In some embodiments the event models are stored in a sparse array such as a heap rather than as a complete array or complete tree in order to conserve memory. For a large website the number of observed transition types would otherwise require an impractically large complete array.

As depicted in information flow diagram prediction combiner inputs the individual event frequency predictions and the individual event duration predictions combining them to output predicted event frequency and predicted event duration respectively.

In a preferred embodiment the prediction combiner uses maximum selector to select the maximum event frequency prediction for output as the predicted event frequency and via prediction switch uses selector to select the corresponding event duration prediction for output as the predicted event duration. The use of the maximum here implies that that an event is not to be considered unusual if any of a set of equally credible predictors shows that it is not unusual. In an alternative embodiment not shown prediction combiner computes the Bayesian mean of the input frequency predictions and duration predictions and outputs the means as the predicted event frequency and predicted event duration respectively.

As depicted in event frequency scorer inputs observed event frequency and predicted event frequency compares them using event frequency comparator normalizes the result and outputs frequency anomaly score .

Event frequency comparator uses differencer to compare observed event frequency to predicted event frequency outputting the difference as frequency excess . Next adder adds frequency threshold to the frequency excess outputting adjusted frequency excess . Frequency thresher then tests whether the adjusted frequency excess is greater than zero indicating that the event is not anomalous in which case it outputs a zero as the frequency anomaly score . For computational efficiency the thresher may also optionally input duration anomaly score . If the duration anomaly score is below duration threshold then the event is likewise determined not to be anomalous and the thresher likewise outputs a frequency anomaly score of zero.

In a preferred embodiment the frequency threshold is omitted or set to zero in order to postpone threat decisions until the anomaly of the entire session can be compared to the anomaly of all other sessions. Alternatively if the number of detected attacks is expected to be substantially greater than threat processors See can handle then the frequency threshold can be adjusted upwards to throttle the least threatening events.

If on the other hand frequency thresher determines the event to be anomalous then it passes the observed event frequency through as threshed event frequency .

Event frequency normalizer then divides the threshed event frequency by predicted event frequency outputting the result as frequency ratio . Outputting the frequency ratio rather than the absolute observed frequency ensures that the observed frequency of each event is evaluated only with respected to the predicted frequency of that event and independently of the absolute frequencies of unrelated events.

Since the observed event frequency is a simple frequency whereas the predicted event frequency is a frequency product if the frequencies are represented as absolute frequencies then in order to make the observed event frequency commensurate with the predicted frequency either the observed event frequency is multiplied by the norm or the predicted event frequency is divided by the norm. This commensuration may be implemented at any stage between the end of event frequency estimator or event frequency predictor and prior to comparison in the event frequency comparator or normalization in event frequency normalizer . Postponing this commensuration until the end of prediction combiner can reduce the amount of computation.

Finally log calculates the logarithm of frequency ratio outputting the result as frequency anomaly score . Using the logarithm rather than the ratio itself as the event score permits session comparator See to sum the event anomalies rather than multiplying them thus avoiding overflow.

As logarithms of the ratio of the relative joint frequency to the product of the relative marginal frequencies frequency anomaly scores can be interpreted as measuring the point wise mutual information between the marginal dimensions. In the preferred embodiment calculates the base 2 logarithm so that the score is measured in bits. In particular in the case of timed transitions independent frequency predictor AxTxB measures the point wise mutual information between the source transition time and target biased frequency predictor TxAB measure the point wise mutual information between the transition time and the service transition biased frequency predictor BxTA measures the point wise mutual information between the target and the timed source and biased frequency predictor measures the point wise mutual information between the source and the timed target. Although point wise mutual information can be non positive event anomaly scorer ensures that only positive scores are output. That is the session anomaly is determined only by anomalous events so that no number of normal events can compensate for anomalous ones. This is in accordance with the fact that man in the browser man in the middle and similar attacks characteristically comprise a few brief events typically near the beginning of a session irrespective of how long the session lasts.

As depicted in event duration scorer inputs predicted event duration and observed event duration compares them using event duration comparator normalizes the result and outputs duration anomaly score .

Event duration comparator uses differencer to compare observed event duration to predicted event duration outputting the difference as duration shortfall . Next adder adds duration threshold to the duration shortfall outputting adjusted duration shortfall . Duration thresher then tests whether the adjusted duration shortfall is greater than zero indicating that the event is not anomalous in which case it outputs a zero as the duration anomaly score . For computational efficiency the thresher may also optionally input frequency anomaly score if the frequency anomaly score is less than frequency threshold then the event is likewise determined not to be anomalous and the thresher likewise outputs a duration anomaly score of zero. In the preferred embodiment the duration threshold is omitted or set to zero in order to postpone threat decisions until the anomaly of the entire session can be compared to the anomaly of all other sessions. Alternatively if the number of detected attacks is expected to be substantially greater than threat processors See can handle then the duration threshold can be adjusted upwards to throttle the least threatening events. If on the other hand the event duration comparator determines that the event is anomalous then it passes the adjusted duration shortfall through as threshed duration shortfall .

Event duration normalizer then divides the threshed duration shortfall by the predicted event duration to yield duration anomaly score ranging from zero if the event duration is not anomalous at all to one if the event duration is as anomalously brief as possible.

As has now been explained a network security system can include detection of man in the browser attacks and other attacks using a variety of tools and approaches. Further embodiments can be envisioned to one of ordinary skill in the art after reading this disclosure. In other embodiments combinations or sub combinations of the above disclosed invention can be advantageously made. The example arrangements of components are shown for purposes of illustration and it should be understood that combinations additions re arrangements and the like are contemplated in alternative embodiments of the present invention. Thus while the invention has been described with respect to exemplary embodiments one skilled in the art will recognize that numerous modifications are possible.

For example the processes described herein may be implemented using hardware components software components and or any combination thereof. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims and that the invention is intended to cover all modifications and equivalents within the scope of the following claims.

