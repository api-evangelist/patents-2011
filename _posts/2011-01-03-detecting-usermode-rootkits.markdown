---

title: Detecting user-mode rootkits
abstract: A method and system for determining whether resources of a computer system are being hidden is provided. The security system invokes a high-level function of user mode that is intercepted and filtered by the malware to identify resources. The security system also directly invokes a low-level function of kernel mode that is not intercepted and filtered by the malware to identify resources. After invoking the high-level function and the low-level function, the security system compares the identified resources. If the low-level function identified a resource that was not identified by the high-level function, then the security system may consider the resource to be hidden.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08661541&OS=08661541&RS=08661541
owner: Microsoft Corporation
number: 08661541
owner_city: Redmond
owner_country: US
publication_date: 20110103
---
This application is a continuation application of U.S. patent application Ser. No. 11 183 225 filed on Jul. 15 2005 issued as U.S. Pat. No. 7 874 001 which is incorporated herein in its entirety by reference.

Although the Internet has had great successes in facilitating communications between computer systems and enabling electronic commerce the computer systems connected to the Internet have been under almost constant attack by hackers seeking to disrupt their operation. Many of the attacks seek to exploit vulnerabilities of the application programs operating systems and other computer programs executing on those computer systems. One of the most destructive methods of attacking a computer system has been to modify portions of the operating system that is stored on a boot storage device with software that may perform many of the same functions of the operating system but also includes malicious functions. These modifications can be either to replace portions of the operating system or to add new programs that are automatically started by the operating system. Such software is referred to as malware because of its malicious nature. Once malware is installed on a boot storage device or loaded onto a booted computer system the operating system is infected and the malware can control all aspects of the computer system. Such malware includes rootkits Trojan horses keystroke loggers spyware and so on. For example the malware could intercept keystrokes that a user enters e.g. a password and report them to another computer system. As another example the malware could be a worm that launches a self propagating attack that exploits a vulnerability of a computer system by taking control and using that computer system to find other computer systems with the same vulnerability and launch attacks i.e. send the same worm against them.

To prevent detection malware often uses advanced stealth techniques to make its resources such as executable files data files e.g. recorded keystroke files and processes invisible or hidden. Once malware is started it may intercept all queries e.g. system calls and use filtering to ensure that a chosen subset of its resources is never revealed to any query operations by any program running on the infected computer system. For example a keystroke logger may intercept all requests from programs for file listings and delete the name of its log file from the list that is returned to the programs. The keystroke logger may even intercept requests for available disk space and add the size of the log file to the available disk space to make it difficult to detect the presence of the log file. The keystroke logger may also intercept all requests from programs for process related information and remove any information related to the keystroke logger process task thread and so on. These stealth techniques can defeat both experienced system administrators who use common operating system utilities such as WINDOWS Explorer a directory list command a registry editor a task manger and so on to search the file system configuration files e.g. registry files and process tables for suspicious entries and commonly used malware scanning tools that are based on known malware file signatures.

Many different techniques have been used to help detect the presence of such malware unfortunately detection of some malware has proved to be difficult. One technique attempts to identify the presence of malware by the presence of an open port. Malware may install a backdoor so that the computer system can be accessed at a later time. The backdoor opens a port through which another computer system can gain access to the infected computer system. The technique can initiate a port scan from another computer system to detect the presence of an open port. If however the malware only opens a port at designated times then the scanning may not detect the open port. Another technique may compare the files of the infected operating system with files of a non infected or clean operating system. In particular the technique may generate hash codes for the files of the infected operating system and compare them to hash codes of the clean operating system. However since the malware may have control over the computer system it can provide the clean version rather than the infected version of a file to a program that is calculating the hash codes.

Because of the difficulty in detecting malware some computer users have resorted to reinstalling an operating system onto a storage device that might be infected from a storage device that contains a copy of the operating system that is known or thought to be clean. Such reinstalling of an operating system is time consuming. Moreover such reinstalling is unnecessary if the operating system was not actually infected although the user could not be sure that it was not infected.

A method and system for determining whether resources of a computer system are being hidden is provided. A security system identifies resources that are being hidden by malware executing in user mode. To identify hidden resources the security system invokes a high level function of user mode that is intercepted and filtered by the malware to identify resources the lie list . The security system also directly invokes a low level function of kernel mode that is not intercepted and filtered by the malware to identify resources the truth list . After invoking the high level function and the low level function the security system compares the lie list to the truth list. If the truth list contains a resource that is not in the lie list then the security system may consider the resource to be hidden. By directly invoking low level functions of kernel mode the security system can detect that user mode malware is attempting to hide resources by intercepting user mode invocations of high level functions.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

A method and system for determining whether resources of a computer system are being hidden is provided. In one embodiment a security system identifies resources that are being hidden by malware executing in user mode. To identify hidden resources the security system invokes a high level function of user mode that is intercepted and filtered by the malware to identify resources the lie list . For example the security system may invoke the Process32First and Process32Next APIs of WINDOWS to identify the processes. The malware executing in user mode will intercept and filter the results of these high level functions. In particular the malware will filter out all references to resources e.g. processes registry entries files and directories that may indicate the presence of malware. The security system also invokes a low level function of kernel mode that is not intercepted and filtered by the malware to identify resources the truth list . For example the security system may have code that stores parameters of the low level function on the user mode stack stores an indication of the low level function in a register and then causes the operating system to transition to kernel mode to execute the low level function. The malware executing in user mode will not be able to intercept and filter the results of this low level function unless it can somehow identify and replace the code before it is executed. After invoking the high level function and the low level function the security system compares the lie list to the truth list If the truth list contains a resource that is not in the lie list then the security system may consider the resource to be hidden. It is however possible that a resource may be created after the security system invokes the high level function but before the security system invokes the low level function or may be destroyed after the security system invokes the low level function but before the security system invokes the high level function. In either case the security system may indicate that a resource is hidden when no attempt is being made to hide the resource. To prevent such detection of false positive hidden resources the security system may invoke the high level function and the low level function multiple times. If the results consistently indicate that a resource is hidden then the security system may assume that the resource is hidden with a high degree of confidence. By checking multiple results transient resources will not be identified as being hidden. In this way by directly invoking low level functions that execute in kernel mode the security system can detect user mode malware that is attempting to hide resources by intercepting user mode invocations of high level functions.

In one embodiment the security system identifies hidden processes which are considered to be the malware and then determines whether the hidden process is a root process. A root process is a process of a rootkit whose access to system resources is not filtered by the malware. A root process is not infected in the sense that its invocations of high level functions will return true results. The security system may inject code into a hidden process to determine whether the process is having resources hidden from it. Malware will not filter results i.e. hide resources of the high level functions invoked by its own root processes. Thus if the injected code of the hidden process reports that no resources are being hidden then the security system may assume that the hidden process is a root process. The injected code may be the code as described above that invokes a high level function and a low level function and compares their results. If the hidden process is a root process then the lie list and the truth list will be the same and indicate that the malware is not filtering the high level function invocations of the hidden process. In contrast if the injected code of the hidden process reports that resources are being hidden then the security system may assume that the hidden process is not a root process. In this way the security system can confirm that a hidden process is likely a root process.

In one embodiment once the security system identifies a process as a root process the security system uses the name of the executable file of that process to trick the malware into not infecting non malware processes. The security system renames certain non malware executable files to have the same name as the malware executable file and then launches that renamed executable file as a process. The malware executing on the computer system may incorrectly recognize the processing of the renamed executable file as being a root process. In such a case the malware will allow the process to execute without adversely affecting its behavior. The security system may rename an operating system shell file e.g. cmd.exe to have the same name as the root process executable file. After the renamed shell file is launched as a process the security system may perform various security related functions by launching processes as child processes of the shell. In general malware will allow its own root process and other related processes e.g. child processes of the root process to execute without adversely affecting their behavior. A process is considered to be related to itself and all its descendent processes. The security related functions may include additional functions such as malware detection and removal e.g. virus scanning restoring of anti malware configuration settings and restarting of anti malware systems.

In one embodiment the code of the security system may be downloaded from a security server onto a computing device whenever the security system is to check for hidden resources of the computing device. The code of the security system may be downloaded and executed when a user submits a request to the security server. If the code of the security system is persistently stored at the computing device then the malware may be able to identify and infect the security system. Even if the code is not stored persistently the malware may be able to identify the code of the security system as it is being downloaded from the security server and infect it at that point. To reduce the chances of such identification the security server may use various obfuscation techniques to hide the identity of the code of the security system. For example the security server may perform some binary translation of the code of the security system such as rearranging its basic blocks or encrypting the code. After the check for hidden resources is complete the security system can remove itself from the computing device to help reduce the chances of a hacker gaining knowledge of the security code that can then be used to counteract the security code.

In one embodiment the security system may be used to identify hidden registry entries. Certain registry entries such as auto start extensibility points ASEPs reference executable files that are automatically executed by the operating system. Malware may create such registry entries so that the malware may be automatically launched by the operating system. To prevent detection malware will hide these registry entries. The security system may identify these hidden registry entries by comparing a lie list to a truth list and then remove the hidden registry entries. The security system may also generate a signature e.g. hash value of an executable file pointed to by a registry entry and report the signature to a security server. That signature can then be used to help detect the presence of malware on a computing device.

In one embodiment the security system may use the hidden resource information to help guide the search for malware. Some anti malware systems such as anti spyware software may scan various file system directories trying to identify malware. Because it can take a considerable amount of time to scan all the file system directories such anti malware systems often have a quick scan mode in which only certain suspect directories are scanned. The suspect directories are those in which certain malware is known to store its files. Thus the quick scan mode can be effective in identifying malware. When the security system identifies a hidden directory or a directory of an executable file of a hidden process the security system can add these directories to the list of suspect directories that are to be checked in the quick scan mode of the anti malware systems. By adding these directories to the list of suspect directories the security system can improve the effectiveness of the quick scan mode with very little overhead.

User mode malware intercepts system application programming interface API calls at various levels in order to hide its resources. Such malware may intercept the calls by modifying the Import Address Table of a process or by inserting redirection instructions into system APIs at either a subsystem API level e.g. kernel32 advapi32 etc. or a native API level e.g. ntdll which are referred to as high level functions. In order to detect the hiding the security system completely bypasses these high level functions by invoking low level functions of the kernel mode directly. To invoke low level functions of the kernel mode directly the security code sets up the user mode stack with the parameters for the low level function. To set up the user mode stack the security code may define a private function with a signature that matches a native API that may be infected such as NtQuerySystemInformation of WINDOWS. The private function may store the index of the low level function in a register e.g. EAX and store the address of a transition function that transitions to kernel mode on another register e.g. EDX . The private function then calls the transition function. Upon return from kernel mode the private function returns. Table 1 is an example of a private function corresponding to the native API NtQuerySystemInformation that directly invokes a low level function of kernel mode.

The  declspec naked compiler directive prevents the compiler from generating prolog code for the private function in order to ensure that the user mode stack is in the right form at the time of a kernel mode transition. The private function is labeled as NTAPI to ensure that the right C calling convention is used e.g.  stdcall . The private function moves a value into the EAX register that is the index into a kernel mode function dispatch table that tells the operating system which low level function to invoke. This value is unique to the low level function but may vary from version to version of the operating system. The parameters of the private function match the parameters of the corresponding native API. To help prevent the private function from being intercepted by malware the security code may insert the code of the private function inline and may obfuscate the code by adding instructions that do not affect behavior of the private function.

The security server includes a serve security code component a remove rootkit component a spyware quick scan component an identify new ASEP malware component a find root process component a find hidden resources component and an obfuscate security code component . The components correspond to components of the computing device. The serve security code component downloads components to the computing device via the communications link. The serve security code component may invoke the obfuscate security code component before downloading components to translate the binaries to obfuscate the security nature of the components. The download security code component of the computing device may request that components be downloaded when the check for hidden resources is to be performed. The download security code component may remove the downloaded components from the computing device when the check is complete.

Computing devices on which the security system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives . The memory and storage devices are computer readable media that may contain instructions that implement the security system. In addition the data structures and message structures may be stored or transmitted via a data transmission medium such as a signal on a communications link. Various communications links may be used such as the Internet a local area network a wide area network or a point to point dial up connection.

The security system may be implemented in various operating environments that include personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like. The security system may be implemented on computing devices that include personal digital assistants PDAs cell phones consumer electronic devices e.g. audio playback devices game devices and so on.

The security system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims. For example the terms user mode and kernel mode refer generally to different privilege levels for executing processes. Application programs generally execute in user or application mode with a relatively low privilege level and some programs of an operating system execute in a kernel or operating system mode with a high privilege level. As used herein kernel mode refers to any privilege level higher than user or application mode. Malware often executes in user mode because user mode APIs of an operating system are easier to intercept than kernel mode APIs and because user mode APIs generally do not change from version to version of an operating system while kernel mode APIs often change. Accordingly the invention is not limited except as by the appended claims.

