---

title: Synchronizing development code and deployed executable versioning within distributed systems
abstract: The disclosure provides a solution for associating deployed executables with source code. In the solution, source code of a development environment can be mapped to a deployed executable of a runtime environment. The mapping can ensure that a version of source code from which the deployed executable was produced is always known. The mapping can occur within digitally encoded data stored in a non-transient storage medium. The development environment and the runtime environment can be two distinct and separate computing environments that are isolated from each other.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08683430&OS=08683430&RS=08683430
owner: International Business Machines Corporation
number: 08683430
owner_city: Armonk
owner_country: US
publication_date: 20110107
---
The present invention relates to the field of software development and more particularly to synchronizing development code and deployed executable versioning within distributed systems.

A common problem within distributed systems can be the inability to easily identify which artifact versions correspond to each other between development and runtime environments. That is the relationship between a version of source code in development and the deployed executable e.g. runtime executable can be unknown. This can result in synchronization problems during development and deployment. One such problem can include source code overwriting incorrect versions of the executable within a runtime environment e.g. production system after deployment.

In one scenario developer A can work in a development environment performing changes to source code that was deployed to a runtime environment while developer B can also enact different changes to the same code. Either developer can deploy the updated code with his her changes at any time. Before deploying any changes he she may want to know which version of code is currently running and to ensure whether it is based off of the same version of code being deployed.

Currently there is no viable solution for a developer to retrieve such information that can be used to help manage different versions of source code being developed and deployed. Therefore if developer B has already deployed his her changes first developer A can potentially overwrite developer B s changes.

The problem can be exacerbated when the source code corresponding to the deployed executable cannot be identified nor located. This can occur when a developer performs changes to source code which is deployed to a runtime system and does not make the source code available. Further when the currently running version of a product requires changes it can be difficult to determine which version of the source code is associated with the running version of the product. Additionally obtaining the appropriate version of the source code can be difficult when the source code developer is not available.

Known solutions which are currently employed include requiring developers to manually contact each other to determine which version of the executing product is associated with a version of the source code. One drawback to this approach is the time delay that can occur between developer interactions. For example when a developer is temporarily unavailable for contact determining corresponding source code versions to a product can be delayed.

Another approach includes developers manually comparing source code in a development environment with executables in a runtime environment. In some instances of this approach source code must be compared against multiple executables in multiple runtime environments. This approach also suffers from high levels of complexity considerable temporal delays and is error prone. For example a developer is required to compare all files of all types e.g. text binary etc. traverse through directory structures and use appropriate criteria e.g. size content timestamp etc. to determine a corresponding source code version for a runtime executable. In many instances deployed systems can vary significantly from development systems disallowing automation of this process.

One aspect of the disclosure can be for a solution for associating deployed executables with source code. In the solution source code of a development environment can be mapped to a deployed executable of a runtime environment. The mapping can ensure that a version of source code from which the deployed executable was produced is always known. The mapping can occur within digitally encoded data stored in a non transient storage medium. The development environment and the runtime environment can be two distinct and separate computing environments that are isolated from each other.

Another aspect of the disclosure can be for a system for synchronizing distributed systems. The system can include a versioning engine able to version source code of a development environment and able to map the versions of source code to versions of deployed executables of a runtime environment. Each of the versions of the deployed executables can be generated from the version of the source code to which it is mapped. The development environment and the runtime environment can be two distinct and separate computing environments that are isolated from each other.

The present disclosure is a solution for synchronizing development code and deployed executable versioning within distributed systems. A deployed executable can refer to an executable program able to execute in a production environment. Development code can include source code which is human readable code from which the deployed executable was generated. The deployed executable can be machine generated code such as binary code bytecode etc. The source code maintained in a development environment can be mapped to the deployed executable where this mapping ensures that the version of the source code from which the deployed executable was produced is always known. In one embodiment the mapping can be performed by metadata of the deployed executable. Versioning functions performable in various embodiment of the solution include but are not limited to import export deploy difference comparison synchronization conflict resolution and other such functions.

As will be appreciated by one skilled in the art the present invention may be embodied as a system method or computer program product. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present invention may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium.

Any combination of one or more computer usable or computer readable medium s may be utilized. The computer usable or computer readable medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CDROM an optical storage device a transmission media such as those supporting the Internet or an intranet or a magnetic storage device. Note that the computer usable or computer readable medium could even be paper or another suitable medium upon which the program is printed as the program can be electronically captured for instance via optical scanning of the paper or other medium then compiled interpreted or otherwise processed in a suitable manner if necessary and then stored in a computer memory. In the context of this document a computer usable or computer readable medium may be any medium that can contain store communicate propagate or transport the program for use by or in connection with the instruction processing system apparatus or device. The computer usable medium may include a propagated data signal with the computer usable program code embodied therewith either in baseband or as part of a carrier wave. The computer usable program code may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc.

Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

In process flow a versioning system can maintain a version controlled version of a set of files of the development documents in versioning repository . The files of repository can correspond to source code and related artifacts such as development executables design documents user manuals training materials configuration files and the like. Development executables can be machine readable artifacts e.g. binaries bytecode etc generated from the source code . In one embodiment the versioned files can be mapped to the deployed executables . For example the deployed executables can include metadata that ensures that the version of source code from which the executable was produced is always known. It should be appreciated that traditional synchronization techniques do not permit real time user transparent concurrency of development code and deployed executables which the disclosure provides.

As used herein runtime environment can be a deployment system which can include but is not limited to a local workspace environment e.g. desktop environment virtual machine environment continuous integration build environment test environment staging environment and the like. In one instance environment can be a JAVA 2 ENTERPRISE EDITION runtime environment.

Deployed executable can be an executable code comprising of machine code instructions for performing programmatic actions within runtime environment . Deployed executable can include compiled code interpreted code and the like. For instance deployed executable can be a binary file of a software application. In one embodiment deployed executable can be associated with deployed artifacts including but not limited to configuration files archives and the like. Deployed executable can be linked to a corresponding file of repository maintained in a version controlled manner by versioning system .

As used herein development environment can include but is not limited to a local workspace environment e.g. desktop environment virtual machine environment an integrated development environment a distributed development environment utilized concurrently by a set of distributed developers and the like. The development executable can be generated from source code for environment . Environment specific variables libraries pointers file locations platform specifics and the like can differ from the development environment and the runtime environment which can result in the deployment executable being different from the corresponding deployed executable each customized to function in their specific environment.

It should be appreciated that the disclosure presents a solution that can assist developers during integration testing where frequent deployment of executables upon a runtime environment is common. As such revisions of deployed executable within runtime environments can be in constant flux and can result in unsynchronized development systems and deployment systems. Additionally the disclosure can permit synchronization of development and deployment systems in the absence of best practices.

In the scenario deployment against non versioned executable deployed executable can be linked with a corresponding set of one or more files which can be automatically revisioned. Each file can represent a document or artifact that is under configuration control which has been versioned by system . In one embodiment metadata can be generated and or updated upon revisioning of each versioned file . The metadata can be associated with the deployed file or maintained separate from it by the versioning system . Metadata can include but not limited to associated source code files or links to a stored location of the source code files links to associated files and or records of repository associated source code location information build information deployment information e.g. runtime environment information and the like.

In the scenario synchronization of development code and deployed executable can occur in response to one or more change management actions. Change management actions can include but are not limited to a check in action a check out action a deployment action source code import source code export build automation processes and the like. Versioning system can be comprised of versioning server and or versioning client which can provide the novel change management functionality described herein. For example system can be comprised of a synchronization server able to track deployed executable versioning within runtime environment . System can also include a synchronization server able to track changes to development code of the development environment and to indicate a manner in which these changes relate to managed files .

As shown a check in change management action can trigger versioning tracking for the development code . This can include tracking for source code and or deployment executable . When the check in action occurs revision creation event can be triggered. Revision creation event can include creating a new version of development code associated with check in action within repository . This version can be stored as a versioned file . The creation of the new version file can result in versioning system creating and or updating mapping data which maps the file or record to deployed executables if any exist. Although not shown additional events and or programmatic triggers can be established for updating mappings based on suitable events such as compiling source code generating bytecode from source code updating a version controlled version of source code generating a new version of a development executable or deployment executable etc. In an embodiment where metadata associated with deployed executables is used this metadata can be updated automatically responsive to the above changes.

One or more pre deployment actions can be triggered from development environment which versioning system can respond to. A pre deployment action can for example check to ensure that changes have not occurred within the runtime environment which would negatively affect deployment of a development executable . Towards this end runtime version information can be retrieved from the repository . It should be noted that versioning system can monitor runtime environment and maintain current information about it in repository as previously noted. Thus the information retrieved by action can represent an accurate picture of environment . In compare action versioning system can compute a delta between development code and files records . It can also compute delta s between files and deployed executables if any. In one embodiment significant differences between development environment and runtime environment where significant differences are ones effecting the generation of an executable for that environment from the source code can also be noted. The computed delta s can be utilized to identify version conflicts between the development code files and or deployed executables . Conflicts can include for example revision differences feature differences branch discrepancies software errors and the like.

When conflicts are identified conflict notification can be communicated to appropriate system components and or users. In one instance conflict resolution action can be performed programmatically through the use of one or more conflict resolution policies associated with system and or repository . In another instance conflict resolution action can be performed manually via directed user input. For example a user can be presented with a set of conflicts which can be manually resolved or ignored. Changes associated with the conflict resolution operation can be propagated to system and repository . Notification can additionally permit deployment options to be configured for development code . Deployment options can include but are not limited to installation options notification options and the like. For example in one embodiment a user can configure development executable to be installed within runtime environment without negatively affecting deployed executable .

Changes which modify development code can be recorded and versioning information can be updated in response to the changes effectuated by versioning system . For example when development code has changed and is used to update one or more corresponding files or records the version of file can be incremented. When this happens metadata used to keep source code synchronized with deployed executables of runtime environment can be updated to reflect the change. The updating of metadata can occur immediately or can occur after an appreciable delay such as when a next monitoring action is run by system depending on implementation choices.

Once changes are committed to repository development code can be deployed as shown by deploy event . Deploy event can install development executable within runtime environment . Upon completion of the development executable installation versioning information can be communicated from runtime environment to system .

Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. Process illustrates one possible scenario for synchronizing source code and deployed executables utilizing system other scenarios are contemplated.

It should be understood that versioning system and versioning repository can be combined into a single computing element. In one embodiment versioning system can provide functionality which can be integrated within an integrated development environment IDE repository workspace management tool build automation tool deploy tool software change management tool and the like. In one instance system can be a network element able to communicate with versioning repository runtime environment and or user workspaces. In one embodiment metadata associated with the deployed executable can include tracking information that maps back to the development documents such as source code in which case the versioning system and versioning repository are not necessarily present or needed to implement features described herein.

As used herein system can be a distributed computing environment comprising of one or more components . Distributed computing environment can be comprised of computing elements including server entities client elements and the like. In one configuration system can be organized into one or more cells comprising of one or more nodes. As used herein nodes can refer to a computing device including but not limited to desktop computing devices mobile computing devices server computing elements and the like.

Repository can be a hardware software component able to store development code and or deployed executables. Repository can include but is not limited to source code repository repository clone directory structure and the like. In one instance repository can be a source code repository including but not limited to SUBVERSION Concurrent Versioning System and the like. In one instance repository can be a clone repository common with distributed revision control. In another instance repository can be synchronized e.g. cloned and updated utilizing identical mechanisms for traditional repositories.

Mapping table stored within data store can permit automated version tracking across multiple distributed development and deployment environments. Table can be comprised of deployment metadata which can link development code and deployed executable with a deployment environment. Deployment metadata can conform to one or more traditional and or proprietary formats including but not limited to Extensible Markup Language XML Standard Generalized Markup Language SGML and the like.

In one configuration of table a deployed executable can be mapped to an associated code e.g. deployed executable source code deployment environment repository storing associated code and the like. For example deployment metadata can indicate an executable Exe A version e.g. version A deployment environment e.g. System A associated source Code A and associated source repository Repo A . That is mapping table can provide facile and extensible means for deployment version tracking

In one instance mapping table can be continually and automatically updated during a development and deployment software cycle. In another instance system functionality can be integrated into development tools and or automated build tools which can automatically update table during development and or deployment actions. For example when a new version of an executable is deployed deployment metadata can be amended in table .

Versioning system can be a hardware software component for enabling synchronization of distributed development and deployment environments. System can be comprised of but is not limited to versioning engine reconciliation component notification engine policy data store and the like. In one instance system can be a component of a software change management system. For example system can be an IBM TIVOLI CHANGE AND CONFIGURATION MANAGEMENT DATABASE CCMDB .

System can be configured to function in a variety of scenarios including full synchronization partial synchronization and the like. For instance specific development and or deployment environments within a cell can be selected to participate in synchronization enabling customized synchronization profiles. In one embodiment synchronization can include branch synchronization file synchronization directory synchronization and the like.

System can support deployment and or administrative related tasks including deployment actions administrative actions and the like. System can permit adding deleting and or configuring of deployment environments development environment and the like. In one embodiment system can be configured to automatically detect and register development environments deployment environments e.g. runtime and the like. In another embodiment system can permit manual registration configuration of development environments and or deployment environments.

System can enable auditing actions to be performed including revision tracking of development code and deployed executable via mapping table . For example system can enable viewing version and history of deployed executables within an arbitrary number of deployment and or development environments. In one embodiment system can enable exporting of development source and or deployment executables. In the embodiment relevant metadata can be packaged within development source and or deployment executables which can be stored to a user defined location.

Versioning engine can be a hardware software component for tracking deployed executable and associated source code within system . Versioning engine can be used to identify and locate development source associated with deployed executable within runtime environment . In one instance versioning engine can produce version history information associated with a deployed executable which can be stored within mapping table . Versioning engine can utilize timestamp information location information build information to determine and or verify versioning information. In one embodiment versioning engine can enable registration of development and deployment environments. In the embodiment versioning engine can determine unregistered environments utilizing table data and automatically register development and deployment environments.

Reconciliation component can be a hardware software component for synchronizing development e.g. repository and deployment systems e.g. runtime environment . Component can utilize one or more traditional and or proprietary algorithms for conflict resolution. In one instance component can utilize push pull mechanisms to perform synchronization. For instance source code within repository can be refreshed via pulling deployed executable code to a development system to repository . In one embodiment component can utilize policy to perform conflict resolution. In the embodiment policy can be a heuristically determined policy and or manually established policy.

Notification engine can be a hardware software component responsive to change management events and or synchronization events. Engine can be triggered by a user initiated action and or by an automated action. Triggers can include but are not limited to development code and or deployed executable import export check in check out deployment and the like. Engine can communicate with one or more local and or remote components to permit real time synchronicity between development and deployment systems. For instance when a change occurs within a runtime environment change information can be communicated to relevant entities affected by the change. Engine can convey user notifications conforming to a pop up dialog electronic mail Short Message Service SMS Instant Message IM log message and the like. In one instance user notifications can permit one or more resolution actions to be performed manually and or automatically.

Policy can be one or more rules affecting the behavior of system and constituent components. Rules can include but are not limited to conflict resolution policies auditing rules security policies synchronization rules metric collection rules and the like. In one embodiment policy can support role based policies user based policies and the like. Policy can enable customizable synchronization triggers synchronization options and the like. For instance policy can establish operating parameters for tracking the version of an application with uncommitted source code.

The drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. System functionality can be a component of a middleware software Web service and the like. System can utilize traditional and or proprietary communication mechanisms for synchronizing environment and repository . Communication mechanisms can include communication protocols including but not limited to Hypertext Transport Protocol HTTP HTTP Secure HTTPS File Transfer Protocol FTP Secure File Transfer Protocol SFTP Transport Control Protocol Internet Protocol TCP IP and the like.

In one instance deployment metadata can be stored within a secured environment to ensure data integrity is maintained. In another instance authentication and or encryption mechanisms can be employed to secure deployment metadata stored within data store . System can support traditional enterprise security models including but not limited to Public Key Infrastructure PKI key based cryptography security tokens and the like. Authentication mechanisms for utilizing system functionality can include but is not limited to passwords biometrics and the like.

In one instance system can be a portion of a Service Oriented Architecture SOA . In another instance system can be a functionality present within an application programming interface. In one embodiment system can support Web based Distributed Authoring and Versioning WebDAV operations. In the embodiment system can synchronize development and deployment environments via WebDAV application programming interfaces APIs . In another embodiment system can utilize a Representational State Transfer REST software architecture.

It should be appreciated that system can vary based on implementation requirements of enterprise systems and or distributed environments. In one embodiment versioning system can be comprised of client server components such as a versioning server and or a versioning client permitting compartmentalization of functionality. In another embodiment versioning system can be comprised of a versioning repository. In the embodiment a versioning repository can be used to store development source deployed code metadata and the like.

In one instance change management information can be utilized to enable version tracking Change management information can include but is not limited to source code information e.g. owner group versioning information build information bug tracking information project information and the like. For example metadata obtained from build automation tools can be used to determine the version a deployed executable.

In one instance interface can be a user interface associated with a IBM WEBSPHERE APPLICATION SERVER ADMINISTRATIVE CONSOLE. In another instance interface can permit synchronization configuration of individual nodes cells and the like.

In interface version synchronization parameters can be presented based on the selected tab . Tab can present modules workspace environments deployed environments and the like. Tab can present interface artifacts for synchronizing presented modules including but not limited to deploy synchronize ignore view and the like. Presented interface artifacts can vary depending on module permissions user permissions group permissions and the like. For instance an owner of module A can be presented with a deploy push button enabling synchronized deployment of module A.

In interface synchronization notifications of registered and or unregistered development and deployment environments can be presented within section . For example section can display one or more deployment environments which are not synchronized with a target development environment. In one instance section can present real time notifications of registered environments.

Interface can permit batch synchronization processes to be performed rapidly. In one embodiment interface push button can be presented when synchronization incompatibilities are determined. In the embodiment user interaction with push button can permit simultaneous synchronization of all registered development and deployment environments. In another instance interface push button can permit selective reconciliation actions to be enacted against one or more target environments.

Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. Functionality associated with interface can be a portion of a drop down menu context menu and the like. Interface artifacts can include but are not limited to checkboxes radio buttons interactive push buttons and the like. Interface can include but is not limited to a graphical user interface GUI voice user interface VUI mixed mode interface text based interface and the like.

The flowchart and block diagrams in the illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be run substantially concurrently or the blocks may sometimes be run in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

