---

title: Extending a processor system within an integrated circuit and offloading processes to process-specific circuits
abstract: A method of extending a processor system within an integrated circuit (IC) can include executing program code within the processor system implemented within the IC, wherein the IC includes a programmable fabric. The processor system further can be coupled to the programmable fabric. A process can be performed using a process-specific circuit implemented within the programmable fabric in lieu of using the processor system. A result of the process from the process-specific circuit can be made available to the processor system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09135213&OS=09135213&RS=09135213
owner: XILINX, INC.
number: 09135213
owner_city: San Jose
owner_country: US
publication_date: 20110113
---
One or more embodiments disclosed within this specification relate to integrated circuits ICs . More particularly one or more embodiments relate to extending a processor system implemented within an IC.

Integrated circuits ICs can be implemented to perform specified functions. One type of IC is a programmable IC such as e.g. a field programmable gate array FPGA . An FPGA typically includes an array of programmable tiles. These programmable tiles can include for example input output blocks IOBs configurable logic blocks CLBs dedicated random access memory blocks BRAM multipliers digital signal processing blocks DSPs processors clock managers delay lock loops DLLs and so forth.

Each programmable tile typically includes both programmable interconnect circuitry and programmable logic circuitry. The programmable interconnect circuitry typically includes a large number of interconnect lines of varying lengths interconnected by programmable interconnect points PIPs . The programmable logic circuitry implements the logic of a user design using programmable elements that can include for example function generators registers arithmetic logic and so forth.

The programmable interconnect circuitry and programmable logic circuitry are typically programmed by loading a stream of configuration data into internal configuration memory cells that define how the programmable elements are configured. The configuration data can be read from memory e.g. from an external PROM or written into the FPGA by an external device. The collective states of the individual memory cells then determine the function of the FPGA.

Another type of programmable IC is the complex programmable logic device or CPLD. A CPLD includes two or more function blocks connected together and to input output I O resources by an interconnect switch matrix. Each function block of the CPLD includes a two level AND OR structure similar to those used in programmable logic arrays PLAs and programmable array logic PAL devices. In CPLDs configuration data is typically stored on chip in non volatile memory. In some CPLDs configuration data is stored on chip in non volatile memory then downloaded to volatile memory as part of an initial configuration programming sequence.

For all of these programmable ICs the functionality of the device is controlled by data bits provided to the device for that purpose. The data bits can be stored in volatile memory e.g. static memory cells as in FPGAs and some CPLDs in non volatile memory e.g. FLASH memory as in some CPLDs or in any other type of memory cell.

Other programmable ICs are programmed by applying a processing layer such as a metal layer that programmably interconnects the various elements on the device. These programmable ICs are known as mask programmable devices. Programmable ICs can also be implemented in other ways e.g. using fuse or antifuse technology. The phrase programmable IC can include but is not limited to these devices and further can encompass devices that are only partially programmable including for example application specific integrated circuits ASICs . For instance another type of programmable IC includes a combination of hard coded transistor logic and a programmable switch fabric that programmably interconnects the hard coded transistor logic.

Some modern ICs including some of the varieties of ICs discussed above include an embedded processor that is capable of executing program code. The processor can be fabricated as part of the same die that includes the programmable logic circuitry and the programmable interconnect circuitry also referred to collectively as the programmable fabric of the IC. It should be appreciated that execution of program code within a processor is distinguishable from programming or configuring the programmable fabric that may be available on an IC. The act of programming or configuring programmable fabric of an IC results in the implementation of different physical circuitry as specified by the configuration data within the programmable fabric.

One or more embodiments disclosed within this specification relate to integrated circuits ICs and more particularly to extending a processor system implemented within an IC.

An embodiment can include a method of extending a processor system PS within an IC. The method can include executing program code within the PS implemented within the IC. The IC also can include a programmable fabric. The PS can be coupled to the programmable fabric. A process can be performed using a process specific circuit that is implemented within the programmable fabric in lieu of the PS. A result of the process from the process specific circuit can be made available to the PS.

Another embodiment can include a method of extending a PS within an IC. The method can include executing program code within the PS wherein the program code specifies a plurality of processes. A process from the plurality of processes specified by the program code can be selected. Configuration data specifying a process specific circuit that implements the selected process in hardware can be selected. The selected configuration data can be loaded to implement the process specific circuit within a programmable fabric of the IC. The selected process can be performed using the process specific circuit in lieu of the processor system.

Another embodiment can include an IC including a PS configured to execute program code and a process specific circuit implemented within a programmable circuitry of the IC. The process specific circuit can be coupled to the PS and can be configured to implement a process that is offloaded by the PS. The PS further can be configured to offload the process to the process specific circuit in lieu of executing program code to perform the process.

While the specification concludes with claims defining features of one or more embodiments that are regarded as novel it is believed that the one or more embodiments will be better understood from a consideration of the description in conjunction with the drawings. As required one or more detailed embodiments are disclosed within this specification. It should be appreciated however that the one or more embodiments are merely exemplary. Therefore specific structural and functional details disclosed within this specification are not to be interpreted as limiting but merely as a basis for the claims and as a representative basis for teaching one skilled in the art to variously employ the one or more embodiments in virtually any appropriately detailed structure. Further the terms and phrases used herein are not intended to be limiting but rather to provide an understandable description of the one or more embodiments disclosed herein.

One or more embodiments disclosed within this specification relate to integrated circuits ICs and more particularly to extending a processor system implemented within an IC. An IC can be implemented to include a processor system that is coupled to a programmable fabric portion. Functionality of the processor system can be extended by leveraging capabilities of the programmable fabric to operate in conjunction e.g. in a complementary manner with the processor system. One or more processes that are or can be performed by the processor system for example through the execution of program code can be offloaded to circuitry e.g. hardware implemented within the programmable fabric. In some cases implementing a software process in circuitry requires less time for completion has less latency and or uses less energy than implementing the process through the execution of program code within the processor system.

Accordingly one or more processes can be selected and offloaded to circuitry implemented within the programmable fabric. The circuitry is specifically designed to implement the offloaded process. For example particular algorithms or procedures specified in the program code executed by the processor system can be implemented in hardware within the programmable fabric. The processor system can instruct the circuitry e.g. a process specific circuit to perform the process. Thus the process is performed by the process specific circuit within the programmable fabric rather than through execution of program code within the processor system.

The selection of the process to be offloaded and the determination as to when to offload a process can be performed by the processor system using a variety of different techniques. In one aspect such determinations can be predetermined. For example indicators can be placed within the program code executed by the processor system that specify those processes that are to be offloaded. In another aspect the processor system can make more dynamic and intelligent decisions relating to process selection and when selected processes are offloaded to the programmable fabric.

In some programmable ICs each programmable tile includes a programmable interconnect element INT having standardized connections to and from a corresponding INT in each adjacent tile. Therefore the INTs taken together implement the programmable interconnect structure for the illustrated IC. Each INT also includes the connections to and from the programmable logic element within the same tile as shown by the examples included at the top of .

For example a CLB can include a configurable logic element CLE that can be programmed to implement user logic plus a single INT . A BRAM can include a BRAM logic element BRL in addition to one or more INTs . Typically the number of INTs included in a tile depends on the height of the tile. In the pictured embodiment a BRAM tile has the same height as five CLBs but other numbers e.g. four can also be used. A DSP tile can include a DSP logic element DSPL in addition to an appropriate number of INTs . An B can include for example two instances of an input output logic element IOL in addition to one instance of an INT . As will be clear to those of skill in the art the actual I O pads connected for example to IOL typically are not confined to the area of IOL .

In the example pictured in a columnar area near the center of the die shown shaded in is used for configuration clock and other control logic. Horizontal areas extending from this column are used to distribute the clocks and configuration signals across the breadth of the programmable IC.

Some programmable ICs utilizing the architecture illustrated in include additional logic blocks that disrupt the regular columnar structure making up a large part of the programmable IC. The additional logic blocks can be programmable blocks and or dedicated circuitry. For example a processor block depicted as PROC spans several columns of CLBs and BRAMs.

PROC can be implemented as a hard wired processor that is fabricated as part of the die that implements the programmable fabric of the IC. PROC can represent any of a variety of different processor types and or systems ranging in complexity from an individual processor e.g. a single core capable of executing program code to an entire processor system having one or more cores modules co processors interfaces or the like.

In a more complex arrangement for example PROC can include one or more cores e.g. central processing units cache memories a memory controller unidirectional and or bidirectional interfaces configurable to couple directly to I O pins of the programmable IC and or couple to the programmable fabric of the programmable IC. The phrase programmable fabric can refer to programmable circuitry within an IC e.g. the various programmable or configurable circuit blocks or tiles described herein as well as the interconnect circuitry that selectively couples the various circuit blocks tiles and or elements according to configuration data that is loaded into the IC.

Using the various interfaces available within PROC processes defined by program code executed by PROC can be offloaded to circuitry implemented within the programmable fabric. Configuration data loaded into an IC having an architecture as described for example can implement one or more process specific circuits PSCs within the programmable fabric. PROC can select one or more processes that are associated with hardware implementations i.e. PSCs or configuration data specifying the PSCs and offload the process for implementation within the programmable fabric.

In the example shown in PS is illustrated as occupying approximately two thirds of the die of IC while programmable fabric is shown as occupying approximately one third of the same die. is not however intended to be a scale representation of IC . Rather is provided for purposes of illustration and is not intended as a limitation of the one or more embodiments disclosed within this specification.

In general PS is implemented as a hard wired system within IC . To the extent that various components or modules within PS are coupled by lines e.g. signal or communication links that have arrows such arrows are intended to illustrate the direction or flow of control. In this regard a signal illustrated as a line with a directional arrow generally indicates that control over the signal is exerted by the source component from which the arrow emanates rather than the target component. The arrows in general are not intended to indicate one way flow of data or directionality of the signal. In this regard signals can be implemented as bi directional signals or communication links despite the presence of the directional arrow.

Within this specification the same reference characters are used to refer to terminals signal lines wires and their corresponding signals. In this regard the terms signal wire connection terminal and pin may be used interchangeably from time to time within the this specification. It also should be appreciated that the terms signal wire or the like can represent one or more signals e.g. the conveyance of a single bit through a single wire or the conveyance of multiple parallel bits through multiple parallel wires. Further each wire or signal as noted may represent bi directional communication between two or more components connected by that signal or wire as the case may be.

As shown PS can include a core complex . Core complex can include cores and DSP units and an interrupt request unit IRQ and a snoop control unit SCU . Each of cores and can include a level 1 L1 cache not shown embedded therein. While any of a variety of different types of processor cores and or DSP units can be used in an embodiment disclosed herein cores and each can be implemented as an ARM Cortex A9 type of processor core with each having a 32 KB instruction cache and a 32 KB data cache. DSP units and can be implemented in the form of NEON media and or floating point processing engines. Each DSP unit and can provide 128 bit vector based DSP functions. The ARM Cortex A9 processor cores and the NEON media and or floating point processing engines are available from ARM Holdings of Cambridge UK ARM .

Within PS core complex is coupled to a level 2 L2 cache and an on chip memory OCM . L2 cache can be implemented as a 256 KB memory. OCM also can be implemented as a 256 KB memory. Cores and and DSP units and can directly access L2 cache and OCM . In general OCM provides local memory that is available to PS and or to programmable fabric e.g. circuits implemented within programmable fabric . By comparison L2 cache which is also a memory functions as a cache for PS . Accordingly L2 cache can store small blocks or portions of data e.g. 256 bits which are effectively copies of data bits stored in RAM e.g. execution memory off chip. If for example a read request is issued for data stored in L2 cache the data is read from L2 cache as opposed to being retrieved from the RAM.

PS further can include a reset unit a clock unit and a memory controller . Reset unit can receive one or more signals originating from a source external to IC e.g. signal . Signal can instruct reset unit to reset PS and or one or more or all of the components within PS . Clock unit also can receive one or more reference signals e.g. signal from a source external to IC . Clock unit for example can be implemented as or include phase lock loop circuitry capable of synchronizing to received signal . Clock unit can generate one or more clock signals of one or more different frequencies that can be distributed throughout PS not shown . Further clock unit can generate one or more clock signals of one or more different frequencies that can be distributed to programmable fabric for use by circuits implemented therein.

Memory controller can be implemented to communicate with one or more different types of RAMs located external to IC e.g. off chip. For example memory controller can be implemented to access e.g. read and or write various types of memory including but not limited to Dual Data Rate DDR 2 DDR3 Low Power LP DDR2 types of memory whether 16 bit 32 bit 16 bit with ECC etc. The list of different memory types with which memory controller is able to communicate is provided for purposes of illustration only and is not intended as a limitation or to be exhaustive.

PS also can include a direct memory access DMA interface that is coupled to a core switch and to programmable fabric . PS further includes a memory switch that couples to one of interfaces i.e. interface D to be described within this specification in greater detail OCM and memory controller .

Core switch can route signals among various components of PS as shown. In an embodiment core switch can be coupled directly to an internal bus of PS not shown . In such an embodiment each other component within PS that connects with core switch can be coupled to core switch through the internal bus. For example interfaces and each can couple to core switch via the internal bus. The internal bus can be implemented as any of a variety of different buses such as for example an Advanced Peripheral Bus APB .

In general PS can include approximately four categories of I O. PS can provide flash memory type interfaces higher performance interfaces lower performance interfaces and debugging interfaces. Regarding the first category of I O PS can include one or more flash memory interfaces illustrated as A and B. For example one or more of flash memory interfaces can be implemented as a Quad Serial Peripheral Interface QSPI configured for 4 bit communication. One or more of flash memory interfaces can be implemented as a parallel 8 bit NOR SRAM type of interface. One or more of flash memory interfaces can be implemented as a NAND interface configured for 8 bit and or or 16 bit communication. It should be appreciated that the particular interfaces described are provided for purposes of illustration and not limitation. Other interfaces having different bit widths can be used.

Regarding the second category of I O PS can include one or more interfaces providing a higher level of performance than the first category of I O. Each of interfaces A C can be coupled to a DMA controller A C respectively. For example one or more of interfaces can be implemented as a universal serial bus USB type of interface. One or more of interfaces can be implemented as a gigabit Ethernet type of interface. One or more of interfaces can be implemented as a Secure Digital SD type of interface.

Regarding the third category of I O PS can include one or more interfaces such as interfaces A D that provide a lower level of performance than the second category of I O. For example one or more of interfaces can be implemented as a General Purpose I O GPIO type of interface. One or more of interfaces can be implemented as a Universal Asynchronous Receiver Transmitter UART type of interface. One or more of interfaces can be implemented in the form of a Serial Peripheral Interface SPI bus type of interface. One or more of interfaces can be implemented in the form of a Controller Area Network CAN type of interface. One or more of interfaces can be implemented in the form of a Triple Timer Counter TTC and or a Watchdog Timer WDT type of interface.

Regarding the fourth category of I O PS can include one or more debug interfaces such as processor JTAG PJTAG port or interface A and a trace interface B. PJTAG port A can provide an external debug interface for PS . Trace interface B can provide a port to receive debug e.g. trace information from programmable fabric a port to send debugging data of PS out to programmable fabric and a cross trigger port. The cross trigger port allows circuitry within programmable fabric to trigger debug functions such as trace within PS . Similarly PS can initiate debug functions within circuits implemented within programmable fabric .

As shown each of interfaces and can be coupled to a multiplexer . Multiplexer provides a plurality of outputs that can be directly routed or coupled to external pins of IC e.g. balls of the package within which IC is disposed. For example a plurality of I O pins of IC e.g. 53 pins can be shared among interfaces and . A user can configure multiplexer as part of PS to select which of interfaces are to be used and therefore coupled to I O pins of IC via multiplexer .

As shown interfaces also can be selectively coupled to a fabric multiplexer input output FMIO interface . Accordingly based upon user configuration of IC and more particularly PS any one of I O categories two three or four i.e. interfaces can be coupled to programmable fabric of IC via FMIO interface . This allows data being communicated via any one of interfaces to be routed to circuitry within programmable fabric for further processing and or monitoring.

Control register can be configured to control various if not most aspects of PS . One or more commands can be written to control register to control or regulate operation of PS . For example circuits within programmable fabric can write to control register through an interface such as interface B to be described herein in further detail. Control register can control or regulate functions such as controlling intellectual property IP enable resets setting clock frequencies generated by clock unit specifying I O drive strength and other system level functions. Control register can regulate additional functions such as powering down PS powering down or deactivating particular interfaces of PS independently or the like. Control register can be accessed through a bus such as for example an APB not shown that couples control register to core switch .

PS also can include one or more interfaces depicted as interfaces A D that couple directly with programmable fabric . In an embodiment one or more or all of interfaces can be implemented in accordance with the AMBA AXI Protocol Specification AXI as published by ARM. For example each of interfaces can be implemented in conformance with the AMBA AXI Protocol Specification v. 2.0 which is incorporated herein by reference in its entirety. In general AXI is a high performance high frequency interface that is suitable for submicron interconnect.

Referring again to interfaces A and B for example each can be implemented to provide two 32 bit channels that couple programmable fabric with core switch . Interface A can be implemented as a general purpose master interface. Interface A for example can be used to perform general purpose transfers of data from PS and or a DMA controller therein to programmable fabric . Interface B can be implemented as a general purpose slave interface. For example interface B can be used to perform general purpose data transfer between PS and programmable fabric .

Through interfaces A B and core switch circuits implemented within programmable fabric can access various ones of interfaces and . Through interfaces A and or B in combination with core switch circuits within programmable fabric further can access OCM directly and off chip memory through memory controller etc.

Interface C can be implemented as a 64 bit slave interface that couples programmable fabric directly with core complex and more particularly SCU . Through interface C and SCU circuits implemented within programmable fabric are provided with direct access to the L1 cache within each of cores and IRQ L2 cache and OCM . Accordingly circuits within programmable fabric can read and or write to such memories and detect interrupts generated or asserted within core complex . In addition signal can represent one or more interrupts from programmable fabric that can be provided to IRQ as ports or signals and or one or more copies of interrupts from PS and in particular from core complex that can be provided to programmable fabric as ports or signals. In another embodiment interface C can provide coherent access to core complex that would be suitable for use by circuits functioning as co processors. For example a soft processor implemented within programmable fabric in the form of a PSC e.g. PSC can communicate with PS via interface C.

Interface D can be implemented to provide a plurality e.g. four 64 bit slave interfaces. Interface D can be used to exchange large amounts of data between PS and circuits implemented within programmable fabric efficiently. As shown interface D provides circuits implemented within programmable fabric with access to OCM via memory switch and access to off chip memory via memory switch and memory controller .

PS further includes a processor configuration access port PCAP . As shown PCAP can be coupled to a configuration controller and a system monitor block located within programmable fabric . Configuration controller and system monitor block can be implemented in the form of hard wired circuitry. Configuration controller is responsible for writing configuration data to configuration memory cells thereby physically implementing circuitry specified by the configuration data within programmable fabric . System monitor block can perform functions such as analog to digital conversion voltage monitoring current monitoring and or temperature monitoring.

Programmable fabric can be implemented to include one or more programmable circuit blocks that can be coupled together using programmable interconnect circuitry. The programmable circuit blocks and the programmable interconnect circuitry can be configured to implement one or more different physical circuits e.g. user circuitry and or PSC based upon configuration data loaded into IC . It should be appreciated that programmable fabric with the exception of various hard wired circuits implemented therein is not operational or functional until configuration data is loaded within configuration memory causing physical circuitry to be implemented within programmable fabric .

Programmable fabric also can be configured to implement one or more interfaces in the form of hard wired circuits. For example a JTAG interface one or more MGTs A D a Peripheral Component Interconnect Express PCIe interface an Internal Configuration Access Port ICAP and a security port can be included as hard wired circuits despite being located within the programmable fabric portion of IC . The various interfaces described with reference to programmable fabric illustrate exemplary interfaces that can be implemented and are not intended to be restrictive or limiting as to the one or more embodiments disclosed within this specification.

For example configuration data can be loaded into IC and received by a configuration controller . In an embodiment configuration data can be received through PS which can control the configuration process of IC . Configuration controller can load the configuration data received from PS via PCAP within configuration memory not shown of IC . Different physical circuits such as user circuitry and or PSC can be implemented or formed within programmable fabric as specified by the particular configuration data loaded into the configuration memory of IC . It should be appreciated that the loading of configuration data in this manner due to the use of hard wired circuitry requires no initial configuration of programmable fabric . Circuits implemented within programmable fabric inconsequence of loading configuration data though physical circuits typically are referred to as soft in that the circuitry is formed within the programmable fabric rather than being hard wired or otherwise fixed within IC .

PSC as well as user circuitry can be coupled to PS through any of the various interfaces described. Direct access can be provided via interfaces while further access to PS can be facilitated through FMIO interface . It should be appreciated that the particular functionality and process being offloaded to PSC will in general determine the type of interface necessary for communicating with PS .

In an embodiment process can be identified or otherwise marked within program code for implementation within programmable fabric . For example core can identify an indicator that specifies that process is not to be executed but rather performed in hardware by PSC . In another embodiment process can simply be instructions that inform core to offload a particular process to PSC or perform a process using PSC . In that case process need not include actual program code specifying the process to be performed. Rather during development a decision can be made to implement process within hardware rather than in software. Process effectively can be replaced with an indicator instructing PS to offload the process to PSC . In still another embodiment the decision to offload process to PSC can be made dynamically e.g. during operation of IC in the field.

Whether the decision to implement a particular process in the form of a PSC is performed during the design cycle of the system implemented within IC or dynamically in the field by PS the decision can be made based upon one or more different cost measures or simply costs. The costs can be evaluated to determine a cost of execution that reflects one or more costs associated with performing the process in software in PS . One or more costs further can be evaluated to determine a cost of implementation for offloading the process to PSC in programmable fabric . In general when the cost of implementation is less than the cost of execution or less than the cost of execution by a predetermined amount or percentage a process can be offloaded to a corresponding PSC.

In an embodiment the cost of execution and the cost of implementation each can include a time component or a power component or both a time component and a power component in some combination. In some cases offloading a process from PS to programmable fabric is beneficial since the PSC can perform the process faster than PS can execute the process. In other cases the PSC can perform the process using less energy than is used by PS to execute the process. In still other cases the PSC can perform the process in less time and use less energy than PS . The cost of execution and the cost of implementation can be calculated and compared to identify those situations in which offloading of a process results in a time savings or a power savings or a savings of both time and power.

In an embodiment the time component can be measured in terms of latency. For example the decision whether to offload a process can depend upon whether the PSC can perform the process with less latency than were PS to execute the process. In one example one or more PSCs can be implemented within programmable fabric that each can be configured to handle or process an interrupt provided to IRQ of . One or more interrupts of PS can be exposed to circuitry e.g. one or more PSCs in programmable fabric via the IRQ. Upon detecting an interrupt the interrupt can be handled by the PSC within programmable fabric as opposed to being handled through execution of exception handling program code within PS . Handling interrupts using a PSC can reduce system latency by allowing PS to respond to other tasks or requests.

For example process is implemented in program code and also is associated with configuration data shown as process configuration data. When process configuration data is loaded into IC PSC is implemented within programmable fabric . Process is implemented in program code and also is associated with configuration data shown as process configuration data. When process configuration data is loaded into IC PSC is implemented within programmable fabric .

PSC and PSC are shown as blocks to illustrate the area that would be required to implement each respective circuit within programmable fabric . The area required to implement PSCs and can be known and stored as part of program code or stored within a memory elsewhere within IC for use when required.

In an embodiment each PSC can be implemented in programmable fabric during development so that the size of the PSC can be estimated or determined. In another embodiment the size of the PSC can be estimated or calculated based upon a relationship between one line of program code LOC or instruction to an average number of components of the programmable fabric needed to implement that LOC or instruction. For example each instruction can require a particular number of LUTs to implement. Thus the size of the PSC for a given process can be determined as the LOCs for the process multiplied by the number of hardware units needed to implement each LOC.

As shown programmable fabric includes user circuitry representing a user circuit design already implemented within programmable fabric . IC also includes a configuration controller that is configured to load configuration data into configuration memory cells to implement circuitry within programmable fabric . Available space represents an unused portion of programmable fabric . The size of available space also can be known or determined and made available to core . For example configuration controller can calculate available space and make the information available to PS through a standardized application programming interface API .

Accordingly in an embodiment when deciding whether to implement a particular process such as process within programmable fabric in lieu of executing process core can determine whether available space within programmable fabric is sufficient to implement PSC . As illustrated available space is large enough to implement PSC but not PSC .

It should be appreciated that the amount of available space can change during operation of IC for example as IC undergoes dynamic partial reconfiguration complete reconfiguration or the like from time to time while in the field. Accordingly whether a given process can be implemented in hardware can depend upon various factors already briefly discussed as well as the amount of available space at the particular time that offloading of a process may be desired.

When determining whether to offload a particular process to the programmable fabric as noted a cost of execution can be compared with a cost of implementation. In general the cost of implementation and the cost of execution each can depend upon time e.g. the speed at which the process can be performed latency power e.g. the amount of power consumed or needed to perform the process or some combination of both time latency and or power.

The cost of execution can be calculated using a variety of different techniques. In one aspect for example the cost of execution can be determined according to the number of LOCs of the process to be executed. In another aspect the cost of execution can be determined according to the number of operations and or the type of each respective operation to be executed. For example an addition operation can be known to require a first amount of time and a first amount of power to execute. A particular DSP operation can be known to require a second amount of time and a second amount of power to execute. Information regarding power consumption and execution time generally is available from the manufacturer or provider of the processor or PS.

Thus for a given processor or PS the time needed to execute a LOC or execute a particular operation is generally known. Similarly the amount of power required to execute a LOC or execute a given type of operation is generally known. Each process of the program code to be executed by the PS that can be offloaded can be associated with a profile that can specify the cost of execution. The cost of execution can reflect power consumption time to execute latency or a combination of two or more of power consumption time to execute and or latency.

The cost of implementation also can be determined using a variety of different techniques. For example cost of implementation can depend upon one or more operations that must be performed by the PS to setup offloading of the process. To setup offloading for example the PS may first need to ensure that source data needed by the PSC as input is available. Thus the PS may be required to read data from a source memory compute the source data write the source data to a destination memory from which the PSC can access the source data and or perform one or more address translations. In this regard the setup performed by the PS can have power and or time expenditures that must be included in the cost of implementation.

In addition the amount of time needed to access e.g. read and or write a memory can depend upon the location of that memory. The same is true with respect to power consumption. In general a memory internal to the PS can be accessed in less time and with less of a power expenditure than a memory external to the IC for example a RAM accessed through the memory controller. Further L1 cache can be accessed in less time than L2 cache and either L1 or L2 cache can be accessed in less time than OCM.

When the PSC is not yet implemented within the programmable fabric additional time is required for the configuration data to be loaded into configuration memory to implement the PSC. The time required to implement the PSC can depend upon for example the amount of configuration data to be loaded and the speed at which the configuration can be loaded from an external source. The time required and the power required to implement the PSC within the programmable fabric can be estimated and contribute to the cost of implementation.

In terms of the actual processing to be performed by the PSC the PSC can be profiled for power consumption and time needed to complete the offloaded process according to factors such as the number and or type of operations to be performed the particular circuits that are to perform the operations etc. Typically power consumption and speed can be determined based upon the number of operations to be performed by the PSC the type of operations to be performed by the PSC and the particular circuit elements of the PSC that are to implement the operations of the offloaded process.

Cost of implementation also can depend upon the manner in which results of the offloaded process are returned from the PSC to the PS. As noted the particular memory in which results are stored and the communication channel through which the results are sent to the PS can influence both time and power and therefore the cost of implementation.

In addition to time and power as illustrated in sufficient space within the programmable fabric must be available to implement a PSC. For example each process can be associated with a cost of execution a cost of implementation and configuration data specifying the PSC for the process. The cost of implementation can include or specify an estimate of the area required to implement the PSC within the programmable fabric. Thus in one aspect cost of execution for each process can be stored. One or more factors of the cost of implementation of the process can be stored. As noted however one or more other factors may need to be calculated dynamically e.g. during operation in the field due to changing conditions within the IC itself e.g. whether the PSC is already implemented whether the available space within the programmable fabric is adequate etc.

In general cost of implementation and or the cost of execution can be calculated by summing the various individual cost component s described. As noted one or more of the cost component s can be weighted e.g. multiplied by a factor that either increases the significance of the particular cost component or reduces the significance of the particular cost component within the overall cost of implementation and or execution calculation. The different methods and techniques for determining cost of execution and cost of implementation are provided for purposes of illustration and as such are not intended to limit the one or more embodiments disclosed within this specification.

In an embodiment the process that is offloaded to a PSC can be one that involves input of data to the IC and the PS or output of data from the IC and or PS. The PSC effectively can implement an I O peripheral of the PS. For example a PSC can be configured to accept incoming data perform initial processing of that data and store the data within a RAM that is accessible by the PS. Accordingly the PS can access that data from the RAM when needed. Storage of the data within the RAM as well as the pre processing can be performed by the PSC without involvement of the PS. Similarly data that is stored in memory such as a RAM can be output by a PSC without involvement of the PS. The PSC can read data from the designated memory perform any processing if need be and output the resulting data without involvement of the PS. The PS for example can notify the PSC of the data to be output using one or more of the techniques described within this specification. One example illustrating use of a PSC as an I O peripheral as described above is in the context of video processing. The PSC can perform one or more preprocessing tasks and store the resulting data in memory for use by the PS.

In an embodiment in which the PS determines which processes to implement dynamically e.g. during operation and at runtime in the field the program code executed by the PS can include the intelligence and decision making described with reference to . Further the various quantities used in terms of profiling software processes and the PSCs that implement the software processes can be stored as part of the program code executing within the PS stored elsewhere within the IC in a manner that is accessible by the PS during execution of the program code or calculated at or during runtime.

Accordingly method can begin in step where the PS of the IC is executing program code. As noted the program code can include a plurality of different processes. One or more of the processes can be offloaded to the programmable fabric. The program code that is executed by the PS further can include the functionality described with reference to in selecting processes for offloading and determining when to offload such processes.

In step the PS can determine a candidate process of the program code being executed for offloading to the programmable fabric as a PSC. In an embodiment the PS can identify one or more processes that are expected to be executed within a predetermined amount of time e.g. the next process to be executed a process within the next N processes where N is a predetermined integer value or a process that is estimated to be executed within a predetermined number of clock cycles in the future. For example the PS can utilize a look ahead function that selects the candidate process.

In step the PS can determine whether the candidate process is associated with a PSC. When the candidate process is associated with PSC method can continue. When the candidate process is not associated with a PSC method can loop back to select a different candidate process.

In step the PS can determine whether the PSC is implemented within the programmable fabric. One or more PSCs may already be implemented within the programmable fabric. When the PSC is already implemented within the programmable fabric the time component and the power component of the cost of implementation will be less than had the PSC require implementation within the programmable fabric prior to offloading. When the PSC is not yet implemented within the programmable fabric the time component and the cost component of the cost of implementation each will be larger than had the PSC already been implemented within the programmable fabric. Further the PS must determine whether sufficient available space exists within the programmable fabric for implementation of the PSC. Accordingly when the PSC is implemented within the programmable fabric method can continue to step . When the PSC is not implemented within the programmable fabric method can continue to step .

In step the PS can determine the amount of available space within the programmable fabric. As noted the amount of available space can be the amount of unused programmable fabric that is available to implement further circuit designs such as the PSC. In step the PS can determine whether the amount of available space within the programmable fabric is sufficient to implement the PSC. When there is sufficient available space within the programmable fabric to implement the PSC method can proceed to step . When there is not sufficient available space within the programmable fabric to implement the PSC method can loop back to step to select a different candidate process for offloading if any.

In step the PS can calculate or determine the cost of implementation of the PSC and the cost of execution of the process within the PS. As noted if desired the cost of execution and the cost of implementation can reflect one or more time component s one or more power component s or a combination of one or more time component s and one or more power component s . Whether time power or both are considered a function can be used to weight the various components incorporated into the cost of implementation calculation. For example within the cost of implementation calculation time can be weighted more heavily e.g. given greater importance than power. Alternatively power can be weighted more heavily than time. A different function can be used to weight the various cost components incorporated into the cost of execution calculation.

In another embodiment multiple functions for computing the cost of implementation and or cost of execution can be stored that value time power or a combination thereof differently. A particular function for computing cost of implementation and or cost of execution can be selected dynamically by the PS according to an operating state operating context or other instruction provided to the IC during operation in the field. Thus by changing the cost of implementation calculation and or the cost of execution calculation in the field the way in which the decision to offload a given process is made can be changed from time to time dynamically.

In still another embodiment it should be appreciated that the available space determination can be incorporated into the cost of implementation determination step. For example the determination of whether the programmable fabric includes sufficient available space can be incorporated directly into the cost of implementation as a binary type of variable that can override any result yielded by the cost of implementation calculation. In another example when insufficient space is available within the programmable fabric to implement the PSC a multiplier can be used that is large enough to ensure that the PSC is not implemented within the programmable fabric as the cost of implementation is certain to be larger than the cost of execution.

As noted the cost of implementation and the cost of execution generally can be known or determined during the design process and specified within the program code. One or more cost components however can vary according to the current operating state of the IC including but not limited to the amount of available space within the programmable fabric of the IC and whether the particular process being evaluated is already implemented within the programmable fabric as a PSC. As noted the PS further can select a particular manner or function for determining cost of implementation and or cost of execution.

In step the PS can compare the cost of implementation with the cost of execution. In step the PS can determine whether to offload the process to the programmable fabric. When the cost of execution exceeds the cost of implementation or exceeds the cost of implementation by a percentage or a predetermined amount the PS can determine that offloading of the process to the programmable fabric is worthwhile and is to be performed. When the process is not offloaded to the programmable fabric method loops back to step to evaluate one or more additional processes that are part of the program code being executed. When the process is to be offloaded method can proceed to step .

In step the PS can determine whether the PSC is implemented within the programmable fabric. Step is shown for purposes of clarity and illustration but need not be performed as a separate processing step since the information is already known to PS e.g. from step . Step is shown for example to illustrate that when the PSC is not implemented within the programmable fabric a configuration process must be performed to implement the PSC.

In any case when the process is already implemented within the programmable fabric as a PSC method can proceed to step . When the process is not yet implemented within the programmable fabric as a PSC method can proceed to step . In step the PSC is implemented within the programmable fabric. The PSC can be implemented through the loading of configuration data that specifies the PSC to be implemented. In an embodiment configuration of the programmable fabric can be controlled e.g. initiated by the PS. For example the PS can load the configuration data into the IC from an external source and provide the configuration data to the configuration controller. As noted the programmable fabric can be entirely reconfigured or a portion of the programmable fabric can undergo dynamic partial reconfiguration. Once configuration of the programmable fabric is complete the PSC is physically implemented therein.

In step the PS can offload the process to the PSC. In step the PSC can perform the offloaded process. Accordingly in step any result data generated by the PSC in performance of the offloaded process can be made available to the PS.

In step the PS optionally can compute source data to be provided to the process specific circuit as input. In step the PS can push the source data directly to the PSC. For example the PS can push the source data via a slave interface such as interface B set up a DMA to push the source data to the PSC or send data via the FMIO interface to the PSC. In step the PSC can process the source data. When the PSC does finish processing of the source data the PSC can store any result data that is generated at a memory location within the programmable fabric for retrieval by the PS.

In step the PS can poll circuitry within the programmable fabric to determine when the PSC has completed processing of the source data. For example the processor can poll a particular register within the programmable fabric that indicates the status of the PSC as busy or free. The register can be part of the PSC or can be external to the PSC but still be located within the programmable fabric. A busy status indicates that the PSC is not finished processing the source data. A free status indicates that the PSC has completed processing of the source data and or that result data is available.

In step the PS can determine the status of the PSC. When done result data is available and method can proceed to step . When not done the PSC is not finished processing the source data and method can loop back to step to continue polling the PSC status. Continuing to step when result data is available the PS can read the result data from a memory within the programmable fabric. Data can be read for example through a DMA transfer or the like.

In step the PS can generate and store a descriptor. The descriptor can be a block or segment of memory that includes references and or instructions for the PSC to implement or perform the process to be offloaded. Like the source data the descriptor can be stored in the OCM the L1 cache or the L2 cache. The descriptor can include pointers or references to the source data an instruction as to where to store the result data e.g. which address and memory etc.

In an embodiment when generating the descriptor the PS can perform address translation to translate virtual addresses to physical addresses and vice versa. In general the PS can understand or interpret virtual addresses. The programmable fabric inclusive of any circuitry implemented therein however cannot translate physical addresses to virtual addresses or vice versa. The programmable fabric understands only physical addresses. As such any addresses specified within the descriptor must be specified as a physical address for use by the programmable fabric.

In step the PS can notify the PSC that a process is ready for offloading. The notification can indicate for example that source data is available for processing by the PSC. The PS can notify the PSC using any of a variety of different mechanisms. For example the PS can write via one of the interfaces or FMIO interface to a register within the programmable fabric that is monitored by the PSC or a register within the PSC itself. In step responsive to the PSC determining that the register is written or is written with a particular value the PSC can read the descriptor from the memory within the processor. For example the PSC can be configured to read a particular memory address within the PS where descriptors are to be stored or located when the register is written for notification purposes.

In step the PSC can retrieve or read the source data specified by the descriptor. In step the PSC can process the source data and generate or output result data. In step the PSC can store the result data in the location specified by the descriptor. The result data also can be stored in an internal memory of the PS e.g. the OCM L1 cache or L2 cache.

In step the PSC can notify the PS that result data is available. For example the PSC can write to an address of internal memory that is monitored by the PS e.g. an address within the OCM L2 cache or L2 cache. In an embodiment the address to which the notification is written or provided also can be specified by the descriptor. When the PS determines that the memory address has been written e.g. with a value indicating that result data is ready from the PSC the PS can read the result data from the location to which the PSC stored the result data as specified by the descriptor. It should be appreciated that cache coherency can be achieved when particular ports e.g. interface C are used. Other interfaces e.g. interface A B and or D may not provide access to caches or internal memories of the PS. In step the PS can retrieve or read the result data.

It should be appreciated that the use of descriptors allows the location to which the source data and any result data are stored to be changed even though a same PSC is being called each time. The PSC can read the physical addresses specified by the descriptor to obtain source data from the enumerated location and to store result data at the enumerated location. Such locations can be different across each of a plurality of descriptors intended for a same PSC or for different PSCs.

In step the PS optionally can compute any source data to be provided to the PSC as input for computation. As noted once computed the source data can be stored within the OCM L1 cache or L2 cache. In another embodiment the source data can be stored within a memory located in the programmable fabric of the IC.

In step the PS can generate and store a plurality of descriptors. Each descriptor can be a block or segment of memory that includes references and or instructions for the PSC to implement or perform the process to be offloaded. In an embodiment the PS can store the plurality of descriptors within one of the internal memories of the PS. In another embodiment the PS can store the plurality of descriptors within a memory such as a queue within the programmable fabric that is accessible by the PSC or within the PSC.

As noted each descriptor can specify a location e.g. physical memory address from which to obtain any source data to be used as input and a location to which any result data should be stored. To effectuate the processing of the plurality of descriptors in addition to the information noted previously each descriptor can include or specify a pointer to the next descriptor in the plurality of descriptors forming a linked chain of descriptors. The last descriptor in the chain of descriptors can be characterized by the lack of a pointer to a next descriptor.

Additional information that can be specified within a descriptor can include for example an indicator for a computational step to be performed in hardware buffer pointers from which to obtain data or to which data should be stored mailboxes or register addresses for purposes of notification or communication with the PS. By using a plurality of descriptors as described the PSC can continue processing until no further descriptors remain. For example the PSC can be configured to detect when a descriptor is stored within a particular memory or within the queue. The PSC can continue to process each of the plurality of descriptors automatically without further instruction from the PS until the last descriptor is processed. This arrangement requires setup for processing of the first descriptor in the plurality of descriptors. Setup for subsequent descriptors however is minimized or eliminated.

In step the PSC can fetch a descriptor of the plurality of descriptors. For example the PSC can be configured to check a predetermined memory location for the existence of a first descriptor of the plurality of descriptors generated and stored by the PS. The PSC can fetch the descriptor for processing as the current descriptor. In step the PSC can process the current descriptor. For example the PSC can retrieve any specified source data process the source data to generate result data and store the result data as indicated by the current descriptor.

In step the PSC can determine whether further descriptors remain to be processed. For example the PSC can determine whether the current descriptor specifies a pointer to a next descriptor. When the current descriptor specifies a pointer to a next descriptor the PSC can continue to step . In step the PSC selects the next descriptor as specified by the pointer and loops back to step . When the current descriptor does not specify a pointer to the next descriptor the PSC determines that the current descriptor is the last descriptor. Accordingly the PSC can discontinue processing descriptors and continue to step .

In step when the PSC completes processing of each of the plurality of descriptors the PSC can notify the PS that result data is available. In an embodiment the PSC responsive to completing processing of the descriptors can store the result data in a particular location from which the PS can retrieve the result data. That location can differ from the intermediate location s at which result data from one or more individual ones of the descriptors may be stored.

Responsive to receiving the indication the PS can obtain the result data. For example the PS can execute a separate thread thereby allowing the PS to perform other tasks while awaiting the availability of the result data from the PSC. In another embodiment the PS can utilize a mailbox semaphore or interrupts to notify the PS.

In general using an inappropriate technique for offloading a process can result in any savings in time and or power being overwhelmed by logistical operations such as providing the source data to the programmable fabric or constant polling. In this regard when computing the cost of implementation it should be appreciated that the cost of implementation will vary with the particular technique used to offload the process to the programmable fabric. Thus for example the cost of implementation of a selected process will vary according to whether the offloading is performed using the method of or .

The flowcharts in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to one or more embodiments disclosed within this specification. In this regard each block in the flowcharts can represent a module segment or portion of code which comprises one or more portions of executable program code that implements the specified logical function s .

It should be noted that in some alternative implementations the functions noted in the blocks may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It also should be noted that each block of the flowchart illustrations and combinations of blocks in the flowchart illustrations can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and executable instructions.

One or more embodiments can be realized in hardware or a combination of hardware and software. One or more embodiments can be realized in a centralized fashion in one system or in a distributed fashion where different elements are spread across several interconnected systems. Any kind of data processing system or other apparatus adapted for carrying out at least a portion of the methods described herein is suited.

One or more embodiments further can be embedded in a device such as a computer program product which comprises all the features enabling the implementation of the methods described herein. The device can include a data storage medium e.g. a non transitory computer usable or computer readable medium storing program code that when loaded and executed in a system comprising memory and a processor causes the system to perform at least a portion of the functions described within this specification. Examples of data storage media can include but are not limited to optical media magnetic media magneto optical media computer memory such as random access memory or hard disk s or the like.

The terms computer program software application computer usable program code program code executable code variants and or combinations thereof in the present context mean any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation b reproduction in a different material form. For example program code can include but is not limited to a subroutine a function a procedure an object method an object implementation an executable application an applet a servlet a source code an object code a shared library dynamic load library and or other sequence of instructions designed for execution on a computer system.

The terms a and an as used herein are defined as one or more than one. The term plurality as used herein is defined as two or more than two. The term another as used herein is defined as at least a second or more. The terms including and or having as used herein are defined as comprising i.e. open language. The term coupled as used herein is defined as connected whether directly without any intervening elements or indirectly with one or more intervening elements unless otherwise indicated. Two elements also can be coupled mechanically electrically or communicatively linked through a communication channel pathway network or system.

One or more embodiments disclosed within this specification can be embodied in other forms without departing from the spirit or essential attributes thereof. Accordingly reference should be made to the following claims rather than to the foregoing specification as indicating the scope of the one or more embodiments.

