---

title: Parallel serialization of request processing
abstract: A plurality of servers configured to receive a plurality of requests associated with a plurality of byte sequences are described herein. The requests for each byte sequence are received by a single one of the servers. Each server is further configured to serially process the requests it receives while the other servers also perform serial processing of requests in parallel with the server. Also, the requests for each byte sequence are transmitted to the single one of the servers by a plurality of clients, each client independently identifying the single one of the servers for the byte sequence based on system metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08996611&OS=08996611&RS=08996611
owner: Microsoft Technology Licensing, LLC
number: 08996611
owner_city: Redmond
owner_country: US
publication_date: 20110131
---
Large scale network based services often require large scale data storage. For example Internet email services store large quantities of user inboxes each user inbox itself including a sizable quantity of data. This large scale data storage is often implemented in datacenters comprised of storage and computation devices. The storage devices are typically arranged in a cluster and include redundant copies. This redundancy is often achieved through use of a redundant array of inexpensive disks RAID configuration and helps minimize the risk of data loss. The computation devices are likewise typically arranged in a cluster.

In operation clients accessing these large scale services often need to interact with objects distributed across the data storage. For example the clients may seek to create extend delete read from or write to byte sequences such as binary large objects. Some of these operations such as create extend and delete requests related to a same byte sequence require coordination among multiple clients. For example because a byte sequence can only be created once only a single one of multiple create requests issued by clients for that byte sequence should succeed.

In order to coordinate these requests between the multiple clients large scale services typically utilize a central server that receives all requests requiring coordination and processes those requests serially. The central server also stores metadata for all of the byte sequences to enable the central server to for example determine if a byte sequence has already been created and determine a current size of the byte sequence. While utilization of the central server achieves coordination of the client requests and avoids the inconsistencies that would arise without coordination it also introduces performance bottlenecks as all of the clients must interact with the same central server and wait for it to serially respond to their requests.

Described herein is a plurality of servers configured to act in parallel to serially process requests received from clients. Each server processes requests associated with one or more byte sequences and requests associated with a given byte sequence are processed by a single one of the servers. The serial processing of requests for a given byte sequence at a single server ensures consistency and coordination while the use of multiple servers in parallel avoids the performance bottlenecks associated with a central server.

Clients determine which of the servers to send their requests to based on shared system metadata that associates metadata for each byte sequence with one of the servers and optionally one or more replica servers. The server associated with the metadata for the byte sequence is responsible for serially processing the requests for that byte sequence which require coordination between multiple clients. Upon identifying the servers the clients send their requests to the servers for the servers to act in parallel to serially process the requests.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In various implementations the servers receive requests associated with a plurality of byte sequences. Server receives requests associated with byte sequence . Server receives requests associated with byte sequence . Server receives requests associated with byte sequence . The servers may also receive requests associated with additional byte sequences e.g. server may receive requests associated with a byte sequence but all requests associated with a given byte sequence that require coordination between multiple clients are received by a same one of the servers . For example if there is a byte sequence all requests associated with byte sequence that require coordination would be received by a single one of the servers .

The servers may receive these requests from multiple clients. The clients may identify which servers to send given requests to based on shared system metadata. For example as described further below clients may utilize a locator table to identify which server stores metadata for given byte sequence. In some implementations the clients may also utilize the locator table in a similar manner to identify replicas of the server storing the metadata. These replicas may also be servers . Example requests requiring coordination include create requests for creating byte sequences extend requests for extending byte sequences or delete requests for deleting byte sequences.

In various implementations the servers then serially process the requests performing the serial processing in parallel with respect to each other. As shown by the time axis in requests are serially processed over time at each server one request after another. At any given time on the time axis though multiple requests are respectively processed at multiple servers . For example server serially processes three requests associated with byte sequence in order. The order in which the requests are serially processed may be the order in which they are received or may be based on any other scheme for prioritizing one request over another. Also server serially processes two requests associated with byte sequence one after another and server serially processes three requests associated with byte sequence one after another. As shown request at each of the servers is processed at approximately the same time with reference to time axis as is request .

In some implementations serially processing a request involves a two phase commit process. Such a two phase commit process may involve each server communicating with its replicas to ensure that metadata state and data state is mirrored between the servers and replicas with regard to a byte sequence. Further details of the use of a two phase commit process in serially processing a request are described below.

The serial processing may also involve performing specific operations associated with specific request types e.g. specific operations for create requests extend requests delete requests etc. . Further details of those specific operations are discussed below.

In various implementations at the conclusion of serially processing requests the servers store metadata for the byte sequences associated with the requests on the servers . For example the server stores metadata associated with byte sequence the server stores metadata associated with byte sequence and the server stores metadata associated with byte sequence . After performing the storing the servers respond to the requests by indicating success or failure or by providing other information associated with the type of the request .

In some implementations while serially processing the requests servers can concurrently receive and process requests which do not require coordination and which are thus processed independently of the serial processing such as read or write requests. These read or write requests may be associated with a plurality of tracts of a plurality of byte sequences that may be different from the byte sequences for which each server is serially processing requests . As used herein tracts refer to the units comprising byte sequences. The tracts each have a predetermined same size such as eight megabytes and represent the smallest unit of data that can be read from or written to a storage unit that maximizes performance. For example on a mechanical device such as a disk the tract size would be large enough to avoid giving up performance due to the lost opportunity of reading more data for free after a seek or rotational delay. As a second example on a medium such as flash the tract size would be calculated based on the chip bandwidth and characteristics of the flash storage medium.

As illustrated in each client transmits requests to servers and receives responses in return. The clients determines which server s to transmit the requests to based at least in part on a locator table . The locator table comprises shared system metadata that is generated and maintained by a metadata server . The clients receive or retrieve the locator table from the metadata server . Additionally each client includes a client library that enables the client to perform the requesting receiving responses and receiving retrieving the locator table . The servers as shown comprise serial processing modules to enable the servers to serially process requests that require coordination between multiple clients . The servers also include storage unit memory to store byte sequence metadata and tracts of multiple byte sequences.

In various implementations each of the servers the clients and the metadata server is implemented in a separate computing device. The computing device may be any sort of computing device such as a personal computer PC a laptop computer a workstation a server system a mainframe or any other computing device. In one embodiment one of the servers clients and metadata server is a virtual machine located on a computing device with other systems. In some embodiments rather than implementing each server client and metadata server on a separate computing device two or more of the server client and metadata server are implemented on a shared computing device as separate virtual machines or otherwise. For example a server and metadata server could be implemented on a single computing device. Also multiple ones of the servers may be implemented on a single computing device with one server for each storage unit memory of the computing device. Thus if a single computing device includes both storage unit memory and storage unit memory that computing device would implement both server and server . Example computing devices implementing the servers clients and metadata server are illustrated in and are described in greater detail below with reference to that figure.

In some implementations the computing devices implementing the servers clients and metadata server are connected by one or more switches not shown . These switches can also comprise one or more networks such as wide area networks WANs local area networks LANs or personal area networks PANs . The network may also be a private network such as a network specific to a datacenter. In such an implementation the switches comprise or are connected to routers and or devices acting as bridges between data networks. Communications between the computing devices through the switches and routers may utilize any sort of communication protocol known in the art for sending and receiving messages such as the Transmission Control Protocol Internet Protocol TCP IP and or the User Datagram Protocol UDP .

As illustrated in each client has a locator table and a client library . Each client may also have an operating system OS applications and a file system interface enabling the OS or applications to communicate with the client library . The applications or OS may initiate the requests .

The applications may be any sort of application such as a word processing service or a process thread or routine of such a service. Such applications may make requests related to a file rather than a byte sequence and may have those requests translated to requests associated with a byte sequence by a file system interface. The file system interface maps or translates the request for a file into a request for a byte sequence. To do so the file system interface may make use of a table or other structure storing a mapping of a file name to a byte sequence identifier such as a byte sequence GUID. As used herein the term byte sequence refers to a binary large object also known as a blob or other grouping of data. Each byte sequence is comprised of one or more tracts. As described above each tract represents a location within the byte sequence corresponding to a sequence number or offset and has a same length. For example the same length may be a length of eight megabytes sixty four kilobytes or some length in between. Also as used herein byte sequence identifier refers to a globally unique identifier GUID and may have a one hundred twenty eight bit length a one hundred sixty bit length or some other length. Each tract within a byte sequence may also correspond to a tract identifier the tract identifier being a combination of a byte sequence identifier and a tract sequence number indicating the place of the tract within the sequence. When the sequence number is combined with the tract size a byte offset can be calculated for the tract. For example if the byte sequence identifier has a one hundred twenty eight bit length the tract sequence number may be represented by sixty four bits creating a one hundred ninety two bit length tract identifier.

In other embodiments the file system interface requests a byte sequence identifier from a central store the central store located on the computing device implementing the client or on some other computing device. In other embodiments the client does not include a file system interface and its applications are configured to request a byte sequence rather than a file.

In various embodiments as mentioned above each client may include a locator table received or retrieved from the metadata server . The locator table may be stored in memory of the client or remote memory that is accessible by the client . The locator table includes entries for representations associated with tract identifiers and servers associated with each representation. For example each row in the locator table may be one entry including a representation and the servers associated with that representation. The locator table could then include a column for representations and a column for servers . Each representation may be a bit pattern of a determined bit length such as a length of four . The number of representations and thus the number of entries is a function of that bit length with one representation for each possible bit pattern. Thus if the bit length of each representation is four there will be sixteen representations and sixteen entries in the locator table . In one embodiment the locator table includes additional entries that are specific to tracts where the representations are the full translations of the tract identifiers. Such additional entries may be included for frequently accessed tracts or metadata of frequently accessed byte sequences. Further details regarding the locator table are included in the following description and an example locator table is illustrated in and is described with reference to that figure. In other implementations rather than receiving or retrieving the locator table the client requests identifications of tract servers associated with tract identifiers from the metadata server . The metadata server then consults the locator table and answers the client request. In such implementations the client need not have the locator table .

In various implementations the client library is a component configured to be utilized by other processes threads or routines such as a dynamic link library. The client library may be utilized by a file system interface by an application or by the OS of the computing device implementing the client as mentioned above. The client library provides interfaces such as application programming interfaces APIs and performs actions based on requests received at those interfaces. When the client library receives a request associated with a byte sequence such as a request to create delete read from or write to a byte sequence the client library identifies the server s to direct the request to sends the request and listens for the response.

In some implementations the client library is configured to request the locator table from the metadata server . The client library may receive retrieve the locator table periodically or in response to an event. Such an event could be the receipt from the OS an application or the file system interface of a request associated with a byte sequence the receipt of a response indicating that the locator table used by the client is out of date or the generation of an updated locator table by the metadata server . The client library may provide a version identifier of the locator table already stored at the client when requesting an updated locator table from the metadata server . In response to such a request the client library either receives an updated locator table or a response indicating that the client already possesses the most up to date version of the locator table . The client library may then store the updated locator table .

In some implementations the client library is also configured to generate byte sequence identifiers. The client library may generate such a byte sequence identifier in response to the creation of a new byte sequence by the OS an application or the file system interface of the client . The client library may generate the identifier by determining a random bit sequence of a certain length such as a one hundred twenty eight bit length. The use of the locator table to direct a create request for the new byte sequence would then ensure that the generated byte sequence identifier is a GUID that is not already used to identify another byte sequence in the system. The locator table requires that metadata of any byte sequence having the generated byte sequence identifier as its identifier be stored on a same server . If that server when receiving a create request specifying the byte sequence identifier has no metadata stored for the identified byte sequence then the generated byte sequence identifier is a GUID and the create request succeeds. If metadata is already stored however then the server responds to the create request with an indication of failure. Responsive to receipt of that indication of failure the client library may generate a new random bit sequence as the byte sequence identifier and repeat the create request with the new byte sequence identifier.

In other implementations the client library may utilize other techniques to generate a byte sequence identifier as a GUID or may instead transmit a request to the metadata server for the metadata server to generate a byte sequence identifier. The client library may then receive the byte sequence identifier from the metadata server in response.

As mentioned above the client library receives requests associated with byte sequences from the OS an application or the file system interface of the client . Upon receiving the request the client library determines the type of the request and retrieves the byte sequence identifier from the request. If the request is a create request and no byte sequence identifier has yet been created the client library generates or requests generation of the byte sequence identifier as described above. The client library then determines a tract identifier associated with the metadata of the byte sequence that is the subject of the request. The tract identifier associated with the metadata comprises the byte sequence identifier and a specific reserved tract sequence number such as the number identifying the last available tract in the byte sequence. In some implementations this specific reserved tract sequence number may be used for all byte sequences to generate the tract identifiers associated with the metadata of those byte sequences.

The client library then calculates a translation of the tract identifier for the byte sequence metadata to a fixed length. In some embodiments the calculating makes use of a hash algorithm such as a SHA 1 hash algorithm in translating the tract identifier. As mentioned above the byte sequence identifier portion of each tract identifier may be one hundred twenty eight bits and the tract sequence number may be sixty four bits combining to form a one hundred ninety two bit tract identifier. Each hash or translation of a tract identifier may be a shorter length such as one hundred sixty bits. One result of the calculation is that the translations for two very similar tract identifiers are very different from one another. While the first one hundred twenty eight bits of two sequential tract identifiers are the same the first two three or four bits of the translations of those tract identifiers are likely to be different from one another.

In various implementations the client library looks up the translation by comparing the translation to representations stored in the locator table such as the representations in column of . Because the representations may have a smaller bit length than the translation the client library may determine the length of the representations and determine the first N bits of the translation N being the determined length of the representations. These first N bits are referred to herein as a prefix that is included in the translation. The client library looks up this prefix in the locator table and notes the servers associated with each prefix. For example servers A B and C may be associated with the prefix. The client library may then randomly select one of these servers as the server associated with the metadata and the others as the replicas or may automatically select the first listed server as the server associated with the metadata and the others as the replicas.

Upon identifying the server associated with the metadata and its replicas the client library forms a request for transmission to the identified server . If the request received from the OS application or file system interface was a create or delete request then the client library will form request as a create or delete request. If the request received from the OS application or file system interface was a write request then the client library will form request as an extend request for allocation of tracts of the byte sequence that can be written to. If the request received from the OS application or file system interface was a read request then the client library will form request as a request for a size of the byte sequence in order to learn how many tracts need to be retrieved to read the byte sequence. The request may be any sort of message and may include such information as the byte sequence identifier identifications of the replicas e.g. Internet Protocol IP addresses and an indication of the action requested e.g. create extend delete return size etc. . The client library may also retrieve the version identifier of the locator table used by the client library and include that version identifier in the request to enable the server to determine whether the client library utilized an up to date version of the locator table . In some embodiments the transmission of request may include encapsulating the request in a packet such as a TCP IP packet or a UDP packet and transmitting the request across a network.

In various implementations the client library listens for and receives the response to the request . The response indicates success or failure of the request . If the request was a create or delete request and the response indicates success the client library notifies the OS application or file system interface that requested the creation or deletion of the byte sequence of the success of that operation. If the request was a create request and the response indicates failure the client library may generate another byte sequence identifier in the manner described above and repeat the above discussed client library operations with that new byte sequence identifier. In the alternative the client library may notify the OS application or file system interface that requested the creation of the byte sequence of the failure of that operation. If the request was a delete request and the response indicates failure the client library notifies the OS application or file system interface that requested the deletion of the byte sequence of the failure of that operation.

In some implementations if the request was an extend request then response may also include an identification of the tract or tracts allocated to the client . The identification may be in the form of tract sequence numbers referring to locations within the byte sequence may be tract identifiers generated for those tracts or may be a size of the byte sequence. If the size of a byte sequence was received then the client library may calculate the tract sequence numbers from the byte sequence size and proceed as if tract sequence numbers were received. If tract sequence numbers were received then the client library generates tract identifiers for the allocated tracts based on the byte sequence identifier and tract sequence numbers in the manner described above. Once the tract identifiers for the allocated tracts have been received or generated the client library generates fixed length translations of the tract identifiers and looks up those translations in the locator table in the manner described above. Looking up the translations in the locator table will likely result in a plurality of servers being identified for the multiple allocated tracts. The client library may then perform the write requested by the OS application or file system interface to the identified servers that are to store data for the allocated tracts. Because multiple servers may be identified as storing the multiple tracts the client library may write to the multiple servers in parallel.

In various implementations if request was a request for a size of the byte sequence then response may indicate that size. The client library may then utilize the size of the byte sequence and the uniform tract size to calculate the number of tracts in the byte sequence. For each sequence number in the number of tracts e.g. tract sequence numbers 1 2 3 . . . N with N being the number of tracts in the byte sequence the client library generates a tract identifier based on the byte sequence identifier and that tract sequence number in the manner described above. Once the tract identifiers for the byte sequence have been generated the client library generates fixed length translations of the tract identifiers and looks up those translations in the locator table in the manner described above. Looking up the translations in the locator table will likely result in a plurality of servers being identified for the tracts of the byte sequence. The client library may then perform the read operation requested by the OS application or file system interface by requesting the tracts of the byte sequence from the identified servers that store data for those tracts. Because multiple servers may be identified as storing the multiple tracts the client library may read from the multiple servers in parallel. The client library then provides the tracts of data belonging to the byte sequence to the OS application or file system interface that requested the reading of the byte sequence.

In some implementations a response indicating failure may also specify a reason for the failure such as indicating that the client library is using an out of date locator table . If this reason is provided then the client library may request an updated locator table from the metadata server and repeat the above described operations using the updated locator table .

As mentioned above the metadata server generates and updates the locator table . In some embodiments generating the locator table includes selecting a bit length of the representation. The metadata server performs this selecting based at least in part on the number of servers . For example if there are eight servers the metadata server could select a bit length of three. After selecting the length the metadata server generates a locator table with an entry for each possible representation associating multiple servers with each possible representation as replicas to ensure redundancy. To calculate the number of representations the metadata server may utilize the function 2 where N is the bit length of the representation set by the metadata server . For example if the bit length is three the metadata server will determine that eight representations should be included in the locator table and that those representations will be 000 001 010 011 100 101 110 and 111. Along with generating the representations of the locator table the metadata server associates and apportions the servers in some manner to the representations. For example the metadata server may determine that three servers should be associated with each representation and servers A Z are available for assignment. The metadata server may then associate servers A B and C with a first representation servers D E and F with a second representation and so on. Once each server has been associated with a representation the metadata server may cycle through the servers again associating each server to a second representation. In some embodiments the associating effects a distribution of the tracts among the servers by associating different representations with different servers . As mentioned above each representation corresponds to a prefix included in a translation of a tract identifier. The translating is performed in such a manner that sequential tracts of a byte sequence have different prefixes. Thus by associating the different prefixes of tracts of a byte sequence to different servers the metadata server ensures that the tracts of a given byte sequence are distributed among a plurality of servers .

In some embodiments the metadata server ascertains or is programmed with the knowledge that one of the tracts stored by one of the servers is frequently accessed. The metadata server adds an entry to the locator table for that tract including as the representation the full translation of the tract s identifier. In one embodiment that frequently accessed tract may store the metadata of a frequently accessed byte sequence. The locator table accommodates the inclusion of new tracts without requiring a refresh or update of the locator table . Because as mentioned above the locator table includes all possible representations there is no need for the metadata server to update the locator table in response to the creation of a new tract or new byte sequence as that new tract or the metadata of that new byte sequence will correspond to one of those possible representations.

The metadata server also may update the locator table upon detecting the failure of a server the addition of a new server or to re balance the load between the servers . The generated or updated locator table is then provided to or retrieved by the clients and in some embodiments provided to the servers . The locator table can be transmitted in any format recognizable by the clients and servers . For example the locator table may be represented as a data structure a text file an extensible markup language XML file or a database file such as a Microsoft Access database file. The clients may each be registered with the metadata server thereby informing the metadata server of their identities. In other embodiments the metadata server retrieves a list of clients from another server or computing device. In yet other embodiments the metadata server only provides the locator table to clients in response to requests from the clients for the locator table . In the requests the clients may indicate the version identifiers of locator tables stored on those clients . If the current version identifier shows that the locator table has since been updated the metadata server provides the locator table in response to the requests. If the clients already have the current locator table then the metadata server simply indicates to the clients that their locator tables are current.

As illustrated in the metadata server stores the locator table after generating or updating the locator table . For example the metadata server may store the locator table in DRAM. By storing the locator table the metadata server is enabled to provide the locator table to requesting clients .

In various implementations as mentioned above the metadata server also generates a byte sequence identifier upon request from the client library . The metadata server may generate the byte sequence identifier by selecting a fixed length bit sequence at random and repeating the generation if that fixed length bit sequence is already used as a byte sequence identifier. Discovery that a fixed length bit sequence is already used may be made in a trial and error fashion as described above with regard to client library . Alternatively the metadata server may maintain and reference a list or other indicator of byte sequence identifiers already in use and generate a fixed length bit sequence that is not in use as a byte sequence identifier based on the list or indicator. The metadata server then provides the byte sequence identifier to the client and updates any list or indicator.

In various implementations servers includes a plurality of servers such as server server and server which are described above with reference to . While both show servers including three servers it is to be understood that servers may comprise any number of servers. As previously mentioned servers may be associated with storage nodes of a datacenter storing data of the data center and enabling reading and writing of that data. As shown in these servers may each include a serial processing module to handle the serial processing of requests requiring coordination between multiple clients and a storage unit memory the storage unit memory storing byte sequence metadata and tracts of multiple byte sequences. Thus server includes serial processing module and storage unit memory which stores metadata and tracts . Server includes serial processing module and storage unit memory which stores metadata and tracts . Server includes serial processing module and storage unit memory which stores metadata and tracts . In some implementations each server also includes an OS applications module s enabling read and write operations and a routing module that directs received requests to the serial processing module to module s enabling read and write operations or to another destination.

In various implementations the storage unit memory could be any sort of storage component such as a disk drive a permanent storage drive random access memory an electrically erasable programmable read only memory a Flash Memory a miniature hard drive a memory card a compact disc CD a digital versatile disk DVD an optical storage drive a magnetic cassette a magnetic tape or a magnetic disk storage.

In some implementations the metadata stored by the storage unit memory is stored in tract size increments with the metadata for each byte sequence having its own tract size area of the storage unit memory . For example if the storage unit memory stores metadata for two byte sequences byte sequences and the storage unit memory will include two tract size areas to store the metadata one for each byte sequence. In other implementations metadata for each byte sequence is allocated a fixed size area of the storage unit memory the fixed size being different from the size of a tract . In yet other implementations the storage unit memory reserves an area for all of the metadata of all the byte sequences and does not allocate a fixed size area to metadata of each individual byte sequence.

The metadata may store a number of pieces of information about its associated byte sequence. For instance the metadata for a byte sequence may store a flag indicating that the byte sequence has been created a byte sequence identifier and a size of the byte sequence which may be measured in some unit of bytes e.g. megabytes gigabytes terabytes etc. or in the number of tracts allocated e.g. 10 tracts corresponding to tract sequence numbers 1 10 . The metadata may also include other information useful in serially processing requests that require coordination between multiple clients .

In various implementations the tracts represent tract size areas of the storage unit memory allocated to tracts of data from multiple byte sequences. Since tracts have a fixed size e.g. eight megabytes each tract is allocated a same sized area of the storage unit memory that corresponds to the tract size. In some implementations a part of the storage area allocated to each tract stores a tract identifier. The stored tract identifier may be the full identifier of that tract or a hash or other fixed length translation of the tract identifier that possesses a smaller size. In some implementations the tracts may be stored contiguously but they may also be stored in another manner. The tracts may include tracts from multiple byte sequences including byte sequences that have their metadata stored on another server . As described above the tracts stored on any given server are determined with reference to the locator table which affects a distribution of the tracts among the servers such that the tracts of a given byte sequence are likely to be stored on many different servers. For example if server stores metadata for byte sequence it may store tracts for byte sequences and . In other words the selection of tracts stored on a server is independent of the byte sequence metadata stored on that server .

In some implementations the storage unit memory may also store a version identifier associated with the locator table to enable each server to track updates of the locator table and ensure that the requesting clients are using up to date versions of the locator table . This in turn assures that servers only store byte sequence metadata that they are supposed to store.

In various implementations the serial processing module module s enabling reading or writing operations and routing module of each server may include processes threads or routines and may be stored in the storage unit memory or in additional memory such as cache memory or RAM of the computing device implementing the server .

In some implementations each server utilizes a routing module to direct received requests which may include requests requiring serial processing and other requests. The routing module directs the requests based on a request type specified in each request e.g. in a header field of the request . If the request is a request requiring serial processing such as a create request an extend request or a delete request the routing module directs the request to the serial processing module . If the request is instead a request for the size of a byte sequence a read request or a write request then the routing module directs the request to the module s enabling read or write operations or to some other module s .

In various implementations upon receiving the requests from the routing module the serial processing module enqueues or otherwise orders the requests such that the requests are processed in some sequence one after another. One technique for ordering the requests is for the serial processing module to process the requests in the order they are received. Such a technique may utilize a first in first out FIFO queue to ensure that the requests are processed in the order they are received. In other implementations the serial processing module may utilize alternative schemes for ordering the requests such as giving priority to certain clients or certain request types e.g. execute all create requests before executing requests of any other kind . Regardless of the ordering scheme utilized the serial processing module processes the requests serially to achieve the required coordination between the clients . Thus if two clients request the creation of the same byte sequence one of these requests must be processed before the other preventing the creation of conflicting byte sequences.

When processing a request the serial processing module first compares the version identifier specified in the requests to the version identifier known to the server which as mentioned above may be stored in the storage unit memory . The serial processing module performs this comparison to ensure that the requesting client used up to date system metadata e.g. an up to date locator table in identifying the server . If the comparison indicates that the version used by the client is newer than the version known to the server then the serial processing module updates the known version identifier stored in the storage unit memory based on the version identifier specified in the request . If the comparison indicates that the version used by the client is older than the version known to the server then the serial processing module transmits failure notification to the client in response to the request and forgoes any further processing of that request .

In various implementations the serial processing module then serially processes the request by performing a two phase commit. In the two phase commit the serial processing module determines the replicas of the server by accessing identifications of those replicas that are specified in the request . For example the request may identify the replicas in a header field of the request . Upon determining the replicas the serial processing module provides those replicas with proposal to change to the byte sequence associated with the request . For instance the serial processing module may propose the creation of the byte sequence in response to receiving a create request . Those replicas and the server then transmit their approval of the proposed change to each other. If one or more of the server and replicas does not approve the proposed change e.g. because metadata of replica indicates that the byte sequence was already created then the serial processing module responses to the request notifying the client of the failure of the request .

If the server and replicas all approve the proposal then upon receiving the approvals the serial processing module of each of the server and its replicas commits the change by performing the action sought by the request . Performance of the action by the serial processing module of each of the server and its replicas involves those serial processing modules updating the metadata that is stored in the storage unit memory to reflect the change. Continuing with the example of the create request the serial processing modules allocate memory for metadata associated with the byte sequence identifier specified in the create request and store the byte sequence identifier and a flag indicating creation of the byte sequence in that metadata . After performing the action the serial processing modules of the server and the replicas indicate the success or failure of the performance to each other.

At the conclusion of the two phase commit the serial processing module of the server responds to the client indicating success or failure of the request . The two phase commit can also fail for a number of reasons. For example one of the server or its replicas may fail while performing the two phase commit. In another example one of the replicas may have been misidentified. In such a case the replica may respond in the negative to the proposed change as the replica may be unaware of the byte sequence for which e.g. an extend is sought.

In various implementations the serial processing module may also perform a number of operations that are specific to the type of the request as part of the serial processing of the request . In some implementations the request is a create request for a byte sequence e.g. a request to create byte sequence that is received by server . In processing the request the serial processing module determines if metadata associated with a byte sequence identifier specified in the request is stored on the storage unit memory of the server . If such metadata exists then the serial processing module responds to the request with an indication of failure as the byte sequence specified in the request has already been created. As described above if no such metadata exists than serial processing module allocates memory for the metadata and stores both the byte sequence identifier and optionally a flag indicating the existence of the byte sequence in the allocated memory. If two create requests for the same byte sequence are received at the same time then the serial processing of the requests by the serial processing module will guaranty that at least one of these requests fails.

In various implementations the request is an extend request asking the serial processing module to allocate a number of tracts of a byte sequence to the client . The number of tracts allocated to the client may be a default number allocated responsive to requests or may be a number specified in the request . In some implementations the serial processing module allocates a large number of tracts in response to an extend request to reduce the overall number and frequency of extend requests . The allocated tracts of the byte sequence then belong to the client and are the client s to write data to. It should be noted that the act of allocating tracts does not actually allocate physical memory to store those tracts. Rather it allocates locations in a byte sequence that are identifiable by tract identifiers. The client must then locate the servers that are to store these allocated tracts and write the tracts to those servers . To allocate the tracts the serial processing module checks the metadata of the byte sequence corresponding to the byte sequence identifier specified in the extend request to determine a current size or last allocated tract sequence number of the byte sequence. The serial processing module then updates the metadata to reflect the new size or new last allocated tract sequence number following performance of the extend request and responds to the client with a message notifying the client of the new allocated tracts. The message may include the tract sequence numbers of the allocated tracts or may include tract identifiers generated by the serial processing module based on the tract sequence numbers and byte sequence identifier. In one implementation if the byte sequence has a maximum size specified in the metadata and the current size or last allocated tract sequence number indicates that the maximum has been reached the serial processing module responds to the client with a notification that the extend request has failed.

In some implementations the serial processing module gathers extend requests and when a certain number of extend requests are gathered processes those requests as a single extend request. For example if the serial processing module receives three extend requests each for three tracts the serial processing module processes those requests as a single extend request for nine tracts. In implementations involving two phase commits for each processed request this gathering of extend requests would reduce the number of two phase commits that must be performed from three to one. Also by performing a single extend the serial processing module need only update the metadata once to reflect the addition of the new tract allocations. The serial processing module then responds to the requests as if they were processed individually informing each requesting client only of the three tracts allocated to that client .

In various implementations the request is a delete request for deleting a byte sequence. In processing the request the serial processing module determines if metadata associated with the byte sequence identifier specified in the request is stored on the storage unit memory of the server . If no such metadata exists then the serial processing module responds to the request with an indication of failure as the byte sequence specified in the request has already been deleted or was never created. If such metadata exists than the serial processing module deletes the metadata from the storage unit memory . If two delete requests for the same byte sequence are received at the same time then the serial processing of the requests by the serial processing module will guaranty that at least one of these requests fails.

It will be understood that the specific operations described above for create extend and delete requests may all be performed in the context of the two phase commit process described above or may be serially processed in another manner.

In various implementations as described above the serial processing module completes its operations for a request by responding to the request and indicating at least the success or failure of the request . As mentioned if the request is an extend request the response may specify the allocated tracts. If the response indicates that the request failed the response may indicate the reason for the failure such as out of date locator table. 

Also as mentioned above the server may include module s that enable read or write operations. These module s may be part of serial processing module or may be a separate module or modules. These module s may receive read or write requests from the routing module and may process the read or write requests independently of the serial processing performed by the serial processing module as the read and write requests do not require coordination between multiple clients . Any client making a write request has the tracts allocated specifically to that client and read requests can be processed for multiple clients simultaneously. Thus these read and write requests may be processed concurrently with the operations of the serial processing module and independently of those operations. These read or write requests may be associated with a plurality of tracts of a plurality of byte sequences that may be different from the byte sequences for which each server is serially processing requests . Processing of read or write requests may involve writing a tract or tracts to storage unit memory or retrieving a tract or tracts from the storage unit memory . If the request fails either because there is not available memory to perform the write or the requested tract s do not exist and therefore cannot be read the module s enabling the read or write operations respond to the client with an indication of failure. If the request succeeds then the module s enabling the read or write operations respond to the client with an indication of success. Further details of reading and writing operations may be found in application Ser. No. 12 763 107 entitled Locator Table and Client Library for Datacenters and filed on Apr. 19 2010 and in application Ser. No. 12 763 133 entitled Memory Management and Recovery for Datacenters and filed on Apr. 19 2010.

In various implementations as mentioned above the server may receive a request from a client for the size of a byte sequence. Such a request may be processed by the serial processing module by the module s enabling read or write operations or by another module. Regardless of what module processes the request that module looks up the metadata associated with the byte sequence identifier specified in the request to determine the current size or last allocated tract sequence number. The module then responds to the request by providing the current size or last allocated tract sequence number to the client enabling the client to for example formulate read request s . If metadata corresponding to the byte sequence identifier is not found then the module response with an indication of failure.

In various embodiments the locator table also includes a locator table version identifier such as a sixty four bit number. Each time a new locator table is generated or updated the metadata server increments the version identifier and stores the incremented version identifier in the new locator table . As described in detail above the version identifier enables clients receiving a new locator table to determine whether they have the most recent locator table and enables servers to track the most recent version of the locator table . The version identifier also enables the metadata server to determine whether a requesting client has the most recent locator table as such requests include the version identifier of the locator table stored on the client .

At block each server compares a version identifier included in one of the requests with a version identifier known to the server the version identifiers being associated with a locator table such as locator table . At block when the version identifier in the request indicates a more recent version than the version identifier known to the server the server updates the version identifier known to that server. At block when the version identifier known to the server indicates a more recent version than the version identifier in the request the server notifies a client that sent the request such as a client that the request has failed.

At block when the requests received by one of the servers include multiple extend requests for a byte sequence that server gathers the extend requests for processing as a single extend request.

At block the servers each serially process the requests that each receives but perform the serial processing in parallel with respect to each other. At block the serial processing includes performing a two phase commit at each server and the replica servers of that server the replica servers being identified in the requests. At block the serial processing comprises storing metadata for each byte sequence on the server processing the requests for that byte sequence. At block when the requests include an extend request the serial processing comprises assigning a client that sent the extend request a plurality of tracts of data belonging to the byte sequence that is extended by the extend request. In some implementations when one of the servers gathered extend requests at block for processing as a single extend request the serial processing comprises processing the gathered extend requests as a single extend request.

At block the servers respond to the client requests. At block the responding includes indicating the success or failure of the requests. For example the responding may include notifying a client of the failure of the client s request when that request was a create request for a byte sequence that had already been created or a delete request for a byte sequence that had already been deleted. At block when one of the servers processed gathered extend requests at block as a single extend request that server responds to clients that sent the gathered extend requests as if the gathered extend requests were processed individually.

At block one of the client devices generates a byte sequence identifier that uniquely identifies a byte sequence.

At block each client device independently identifies a same one of servers as storing metadata for a same byte sequence based at least in part on the system metadata. In some implementations the identifying includes generating a tract identifier associated with the metadata of the byte sequence by appending a reserved offset value to a generated byte sequence identifier. Each client device then calculates a fixed length translation of the tract identifier associated with the metadata and identifies a server associated with that fixed length translation in the locator table. At block each client device identifies replicas of the identified server. Identifying the replicas may also involve utilizing the locator table.

At block the client devices send requests associated with the metadata of the same byte sequence to the same identified server. Those requests may include at least one of a size request to determine a size of the byte sequence a create request for creating the byte sequence an extend request for extending the byte sequence or a delete request for deleting the byte sequence. In some implementations the requests may include identifications of replicas of the server to which they are sent.

At block the client devices receive responses to the requests. At block the client devices performs read or write operations to a byte sequence those read or write operations enabled by the sending at block and the receiving at block .

Computer system may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Removable storage and non removable storage may represent the storage unit memory if the computer system implements a server . Computer readable storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer readable storage media. Computer readable storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer system . Any such computer readable storage media may be part of the computer system .

In various embodiment any or all of system memory removable storage and non removable storage may store programming instructions which when executed implement some or all of the above described operations of the servers client or metadata server . In some embodiments the programming instructions include instructions implementing one or more of the client library or the serial processing module .

Computer system may also have input device s such as a keyboard a mouse a touch sensitive display voice input device etc. Output device s such as a display speakers a printer etc. may also be included. These devices are well known in the art and need not be discussed at length here.

Computer system may also contain communication connections that allow the device to communicate with other computing devices . The communication connections are implemented at least partially by network interface components.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claims.

