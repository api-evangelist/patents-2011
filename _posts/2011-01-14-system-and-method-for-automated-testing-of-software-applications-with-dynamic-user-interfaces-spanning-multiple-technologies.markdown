---

title: System and method for automated testing of software applications with dynamic user interfaces spanning multiple technologies
abstract: The present disclosure provides a system, method and computer program product that uses abstraction to enable the definition, development and maintenance of testing libraries for both simple and complex user interface controls. The system and method hide the granular details from the test designer while still promoting reuse. Using the system and method, designers can define a library of functionality for common controls that map 1-to-1 with visual controls, which may be re-implemented across many APIs or programming languages.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08997053&OS=08997053&RS=08997053
owner: Worksoft, Inc.
number: 08997053
owner_city: Addison
owner_country: US
publication_date: 20110114
---
This patent application claims the benefit of U.S. Provisional Patent Application No. 61 295 042 filed Jan. 14 2010 the teachings and disclosure of which are hereby incorporated in their entireties by reference thereto.

Test automation is for example the use of software to control the execution of tests the comparison of actual outcomes to predicted outcomes the setting up of test preconditions and other test control and test reporting functions. Test automation often involves automating a manual process that is already in place and uses a formalized testing process.

Referring to embodiments of the present disclosure provide an extensible display independent software testing system and method designed to simplify the creation and maintenance of control identification algorithms and test libraries as well as the process of creating the automated tests. As will be more hilly explained below the system permits automated software testing across multiple software platforms for applications with dynamically generated user interfaces that can be rendered using a mix of display technologies and programming languages.

System employs a multi layer architecture that uses encapsulation and abstraction to address different dependencies that exist within the automated testing solution domain. As will be described this approach creates a separation of responsibilities between the system developers the control test suite designers and the automated test designers. This separation is designed to maximize the solutions flexibility in order to deal with custom application complexities without the need for constant software updates from the automated testing solution provider.

For each technology supported by system the system developers may implement a compiled module that creates and updates an object hierarchy of the user interface controls for each running application using the supported technology. Each control within the object hierarchy is encapsulated within an abstraction designed to both provide a common interface to the rest of the system and hide any dependencies on the underlying technology or functional libraries used in its implementation. These object hierarchy instances are registered with a broker component by which the other layers of the system may access the running applications.

The control test suite designers access system by means of user interface provided by the system. This user interface provides a drag and drop method of designing a control test suite by means of a toolkit of graphical widgets and a property editor. When adding support for a new control the designer uses the widgets to first create a reusable common interface description for the control followed by an implementation. Once the controls for a given application have been defined and implemented the designer then creates a hierarchy of parent child relationships between implementations using the widget toolkit. This relationship hierarchy is then combined with an object hierarchy for an application to create an application hierarchy of control instances found within a running application. Also associated with each node in the relationship hierarchy is a set of uniqueness rules also created by the designer used to determine the data that will be extracted from each control in the application hierarchy during the process of identifying controls for an application under test. In addition to defining control test suites a user interface of system also contains a set of widgets that allow the implementer to design a set of transformation rules used to re map previously identified controls of an application once it has been ported to a new technology.

Within system each widget in the toolkit corresponds to a generic pre compiled meta object of the system . Each widget used by a designer is customized to its specific purpose by means of a property editor. The property editor receives data for the properties of each widget. Each time a widget is configured within the user interface a new instance of its corresponding meta object is created and its properties are initialized with the user provided data. As controls suites relationship hierarchies and rule sets are defined within the user interface the underlying meta objects are chained together to create the reusable execution logic of control libraries supporting the automated testing of a specific application. Due to the separation between the generic meta objects and their initialization a.k.a. property data the system is capable of persisting the designer defined content into a number of different formats and storage mediums which can easily be distributed to other systems or reconstructed at a later time.

Embodiments of the present disclosure provide a system method and computer program product for creating and maintaining user interface control test libraries used in the automated testing of software applications. Still referring to system uses a multi layer architecture with supporting infrastructure services. Each layer encapsulates and abstracts dependencies and points of change within the automated testing solution problem domain. An abstraction layer hides supported application technology dependencies from the other layers by representing user interface content for each application as a generic control hierarchy implementing a common interface for user interaction emulation and state a.k.a. property verification. A meta layer decouples the identification and functional algorithms of the user interface control test library from the user interface content for each of the software applications a user is interacting with. Because unique control types typically remain behaviorally equivalent between different technology implementations meta layer also separates control test interfaces from their implementation. This promotes a reusable unified control interface suite that allows extensibility without breaking implementation compatibility. An application layer decouples the application specific parent child relationships and uniqueness rules used for persisting control references from the system defined control implementations and application control content.

In automated testing solutions the responsibilities of creating automated tests may be separated between two parties. For example system developers may implement the technology interfaces the algorithms to find controls in a user interface for supported application and the control test libraries used to interact with controls while automated test designers may use these solutions to select the controls around which they build scripts to emulate manual workflows for a specific application. In the event that changes are made to the user interface for application such that unsupported controls are added or currently supported control implementations are changed automated test designers may need to wait on the system developers to introduce software updates to the system to support modification.

In some embodiments the responsibilities of the system designer may be split between two parties. The system developers remain responsible for designing the technology interfaces. However the responsibilities of creating the control identification algorithms and control test libraries is assumed by control test suite designers. By separating these responsibilities system enables test suite designers to deal with general or application specific functional needs without requiring software updates from the system developers.

This separation may be achieved within the architecture of system by special purpose system provided meta objects that are combined to define the complex structures of a test library and its algorithms. Meta objects are instances of pre compiled software classes used to define a piece of a control test library such as a control type a property an action or an algorithm unit of work. Control test suite designers request new or existing meta objects by means of system provided creation application programming interfaces APIs which can easily be wrapped within a drag and drop user interface of widgets. Meta objects may be customized i.e. tailored to a user specified behavior by means of meta object properties that represent i.e. define the object s user customizable data. Each meta object creates a well defined separation between the user provided data and its executable behavior by implementing separate APIs for each purpose.

Within system the meta object property API used to get and set property names and values is uniform across all meta object types. This enables system to provide a standardized means of persisting and reconstructing meta objects regardless of the their underlying type. A meta object s executable behavior on the other hand is implemented i.e. exposed by a specialized meta object type specific API.

Collectively the control definitions created by combining these meta object types make up the test library API of system which is available to automated test designers. These meta objects point to and include implementation algorithms created using declarative functions that are chained together. Declarative functions are created by the system developers and deployed with the system as its declarative function library. Each unique declarative function implementation provides a self contained unit of work.

When the encapsulated logic of a declarative function is executed there will exist in many cases one or more conditions under which execution is considered to have failed such as a verify property declarative function not matching the property criteria it was assigned. When this occurs or a sub branch i.e. other declarative functions that have been chained to the current declarative function returns a failure the declarative function returns to its immediate caller without executing any further logic or sub branches. By default it returns a failure to its caller. However by means of a declarative function property this can be overridden to return success even on failure. The result of this behavior is that though each branch will be executed specific branches may be prematurely ended by means of a failure.

Referring now to abstraction layer comprises three conceptual components technology managers views and an abstraction broker . Technology manager is the component responsible for interfacing with a supported technology. Technology manager observes the running applications and hooks into any applications that are implemented using the technology it supports. When a new application is first hooked or its user interface changes state technology manager passes the user interface content of the application to each of the views associated with the technology. Views are the components of abstraction layer responsible for navigating technology specific user interface content and abstracting them into a technology nonspecific control hierarchy. Each member of the hierarchy is an object that wraps a user interface element and uses the API of the element to implement a common control interface for accessing the properties of and emulating user interaction with the element. Views are not required to create a control hierarchy that mimics the original user interface hierarchy or contains all the original user interface elements. As its name suggests its abstraction creates a view of the original user interface content that may implement additional goals such as simplifying complexity creating more intuitive parent child relationships or eliminating redundant or formatting elements. As a result a given technology may implement views more than once per supported technology. Once control hierarchies are created by views they are made accessible to the other layers e.g. meta layer and application layer of system through abstraction broker . In other words views produce control hierarchies providing a technology independent representation of graphical elements for a running application and parent child relationships between the graphical elements.

As an example consider an execution flow of abstraction layer in the context of an HTML base application as collectively illustrated in . In this scenario a Technology Manager component is designed to interface with Internet Explorer IE browsers running on a Windows host machine. Its implementation runs on an independent thread and uses the ShellWindows object provided in the SHDocVw COM library to periodically poll the running IE browsers. Once a new IE browser is identified it acquires an InternetExplorer object reference to the browser that it will use to register for events signaling changes to the state of the users interface. Access to the user interface of the HTML application is provided through the Document Object Model DOM of InternetExplorer. The DOM provides an object hierarchy of the HTML content including the user interface currently loaded within the browser. Two IE View components have also been implemented as part of this scenario. As shown in . IE View implements an algorithm that creates a control hierarchy containing all user interface HTML elements including those used for formatting. The algorithm for IE View further minimizes its control hierarchy to include only those elements that enable user interaction i.e. INPUT .

With the IE Technology Manager running an IE browser is loaded which points to an HTML Login page whose content is shown in . After loading the page a DOM hierarchy of the browser exists in a state represented in . Each element in DOM hierarchy a.k.a. DOM representation is labeled with the HTML element it encapsulates and shows the HTML type specific interface it exposes. DOM hierarchy is then passed by technology manager of to each of the views associated with the IE Abstraction layer solution. After receiving DOM hierarchy each of the views will begin a depth first search that navigates the tree according to the following path 

When components from each of the views encounter a DOM object that its algorithm accepts as a member of its control hierarchy each of the views creates a control object specifically designed to re wrap the interface API of the DOM object with a common IControl interface shared by all members of the control hierarchy. The created control object is then added to the child collection its closest ancestor control object found along the path between itself and the root. If no control object meeting this criterion is found then the control object becomes the root of the control hierarchy as is the case with the BODY object. contains the resulting control hierarchy trees created by each of the views . The control hierarchy of IE View appears on the left and the control hierarchy of IE View appears on the right. As per their algorithms the control hierarchies of IE View and IE View contain the three interactive INPUT elements. The control hierarchy of IE View also contains the BODY TABLE TR and TD formatting elements. Both IE View and IE View use the BODY element as their hierarchy root.

Once the control hierarchies of IE View and IE View are returned to technology manager e.g. an IE technology manager they are registered with abstraction broker . Each registration links a control hierarchy instance with an identification pair that is made up of an application identifier and a view identifier. Over time as the user interface state of each browser changes the manager responds by refreshing the corresponding IE View hierarchy instances e.g. IE View and IE View and re registering the new instances using the same identification pair.

The design and implementation of each component within the abstraction layer may be the responsibility of the system developers. As new technologies emerge corresponding implementations of technology manager and the views may be developed to enable system to interact with their user interfaces.

Referring now to meta layer provides control test suite designers with a collection of pre compiled meta objects that are combined to create the suite of supported user interface control test libraries of system from . The four core components of meta layer are an interface manager a control manager a declarative function library and a meta broker . In addition meta layer also provides seven types of meta objects interfaces implementations a.k.a. controls identities properties child collections actions and declarative functions .

The process of creating a new control test library begins with defining the functional interface of the control using interface property and action meta objects. Interface is a simple meta object that manages a collection of properties and actions . These collections store property and action meta object instances created and added to the interface by a designer to declare the set of verifiable properties and emulate able user actions supported by a control test library implementation. Before adding any meta object to an interface collection the designer may first assign it a name that is unique to the all property and action currently managed by the interface . In addition the designer may also declare the set of expected values before adding any action meta object to the interface . These expected values are unique string identifiers that represent the data passed to the action meta object when it is executed.

It should be noted that each interface created by a designer does not necessarily have to be associated with a single control type it is possible to define an inter that may be implemented i.e. different implementations are created for different control types sharing common properties and user interaction behavior i.e. actions such as a textboxes and password fields or checkboxes and radio buttons. Using this interface meta objects paradigm i.e. the previously defined approach a standardized library of common interfaces can be defined that promotes reuse across different implementations and technologies.

After an interface meta object has been created or modified it is registered with interface manager using a name unique to all interfaces currently defined within system . Each interface manager implements an API that handles addition removal retrieval and persistence of interface meta objects.

Once the interface has been created a designer creates a test library implementation using the implementation meta object. The implementation meta object is created using a selected user created interface that acts as its creation prototype. The implementation will manage read only property and action collections that contain the same property and action members defined in its corresponding interface as well as a collection of child collection meta objects. These child collection nieta objects are optional constructs that enable designers to develop reusable algorithms that return specialized collections of nested controls such as day or month elements within a calendar control. As is the case for property and action meta objects before child collections are added to the collection of the implementations they are assigned a name that is unique with respect to all members of the child collection . Each implementation also contains a reference to a single identity meta object that a designer uses to create an algorithm for identifying instances of the control associated with the implementation .

Each meta object associated with i.e. added to an implementation hosts i.e. has assigned to it a specialized algorithm created by the implementation a.k.a. control test suite designer. These algorithms are created by chaining together i.e. combining by adding to their collections declarative function meta objects that the user selects. Meta layer provides a library of declarative function meta objects designed and implemented by the system developers which provide the functionality to organize and interact with the control hierarchies of abstraction layer.

It should be noted that depending on the underlying technology control test library implementations may either be generic a.k.a. most basic or application specific solutions. This is best conceptualized when considering HTML based applications. When a designer such as a control test suite designer creates control test library implementations for HTML the generic or most basic approach is to focus on the low level or primitive HTML control types that make up the language. However in sophisticated HTML based applications the lack of support for modem controls such as trees and calendars forces developers to create composite controls typically made up of a dynamic number of low level or primitive controls to bridge this gap. These composite control designs may be either application specific or templates within an HTML application rendering framework. Using the generic approach an end user such as an automated test designer manages not only the identification of all low level controls used in the composite control but also the complex scripts required to emulate user interaction with the composite control. An alternative to this approach is to create test library implementations specific to and for the composite control type that hides this complexity from the automated test designer.

Once implementations have been fully configured or assembled they must be registered with control manager using a name unique to all implementations within system . Like interface manager control manager is responsible for managing the life cycle of all implementations that have been registered within system and must provide an API that handles their addition removal verification retrieval and persistence.

As an example of this process consider an HTML based application that contains a custom drop down composite control. Referring now to a possible HTML rendering of a drop down control is depicted. Control starts with a DIV element that provides the parent context used for cascading style sheet CSS positioning of the nested elements. Within the DIV are a read only INPUT element that displays the selected item an MG element that acts as the click target for triggering the drop down and a DIV element that contains the selectable items offered by the drop down. Since script and class details of each element are not required to implement a test library for this drop down control they have been omitted from the sample HTML.

For this example it is assumed that the instances of the drop down control defined in would emulate a look and behavior of a traditional drop down control. In addition it is assumed that system has provided view for abstraction layer for HTML called OneToOne that implements a one to one mapping of HTML interactive and formatting elements i.e. HTML primitive elements to controls in the control hierarchy. Because the choice of declarative functions available in declarative function library of meta layer in is left to the system developers this example uses seven possible declarative functions that meet the needs of the meta object algorithms i.e. algorithms created using declarative functions that are associated with each property action child collection and identity . Their purpose and parameters are described in the table in . The algorithms in the example are displayed such that any declarative function containing more than one executable branch will order their execution from top to bottom.

After analyzing the test cases created for this application it is determined that the test library for the control includes an item count property and a select item action . Based on this determination an interface for this control is constructed as shown in . The property collection of interface contains a single property meta object that has been assigned the name item count and it is action collection contains a single action meta object that has been assigned the name select item . Select item action also defines a single expected value item name . Interface is then registered with the interface manager using the name drop down interface.

Using this interface an implementation meta object is created and configured as shown in . Implementation defines a single meta object property called view which defines the expected view type for the implementation as OneToOne. In addition to the property and action defined in its associated interface implementation also defines and contains an identity and three child collection meta objects. Each child collection extracts specific child control elements of the drop down that are required within the identity property and action algorithms.

In this example the identity meta object of implementation defines a single meta object property called skip children in addition to its declarative function based algorithm. Because the value is set to true the calling algorithm a.k.a. the caller should skip all nested children i.e. any other children of the control hierarchy instance where a match is made . The algorithm of the identity has been designed based on the assumption that the three visual components of the drop down control which are the input field the clickable button and the drop down list all have a unique class attribute that are not used by the any other control constructs within the application.

To understand how the algorithm of the identity identifies drop down control instances assume that there exists an algorithm that navigates a.k.a. navigation algorithm the control hierarchy i.e. the view created control hierarchy structure of the HTML application using a depth first search. At each control i.e. the control instance in the control hierarchy encountered by this algorithm the identity of the drop down is executed passing the current control hierarchy instance as its parameter. Each time this occurs the identity executes its associated algorithm passing the array as a parameter. If execution returns a true success indicator a match is identified and the navigation algorithm skips the current control hierarchy instances children during its traversal due to the skip children meta object property of the identity . If execution returns a false success there is no impact on the navigation algorithm s traversal. Using the declarative functions previously defined the logic flow of the identity algorithm is as follows.

Execution begins in the execute declarative function which contains three logic branches i.e. user added declarative functions . Each branch is designed to retrieve a child collection and verify that the array i.e. collection count consists of a single member. According to the configuration of the algorithm the child collections are evaluated in order from Input to Button to DropDown. If any branch returns a success indicator of false to execute execution returns a result with the success indicator set to false. However if all three branches return a result pair containing a true success indicator the execute returns a corresponding result with a success indicator set to true.

The algorithm of identity is responsible for not only evaluating whether meta layer control has been identified but also determines what control hierarchy instance is the starting context from which all other algorithms for meta Objects begin. When identity returns a result indicating that a match was made to the provided control hierarchy instance the reference to that instance is a pair consisting of implementation and the control hierarchy instance provided when the match was made. All other meta objects i.e. property child collections and action belonging to implementation are passed the identity matched control hierarchy instance as their starting context.

Three child collection meta objects are defined within the implementation and used by the algorithm for identity . Each is assigned a single meta object property value called name which represents the lookup name of the child collection when called via a declarative function . Though the algorithm for each child collection uses the same declarative functions and organization each returns a different array a.k.a. collection of controls hierarchy instances due to customization differences in the meta objects properties. The algorithm for each child collection begins by using the starting context control hierarchy instance to search its children for hierarchy controls that have a specific HTML tag. Once this array has been constructed it is then reduced to only those controls or instances that match on a specific HTML class name. The configuration customizations result in an input child collection matching INPUT HTML tags and the class name combobox input a button child collection matching MG HTML tags and the class name combobox click and a DropDown Child Collection matching DIV HTML tags and the class name combobox dropdown.

The property meta object defines three meta object properties . The first is the name property whose value is inherited from the interface property meta object used to create the Implementation. The property context property enables the designer to define the source from which the property value will be queried. In this example the value has been set to array which indicates that the array returned from the result for the algorithm will be used as the source. An alternative value would be control which would indicate that the first control in the result array would be the source. The property value provides the name of the property to be queried from the source object in this case the property count. Given this configuration the property will execute its algorithm and given a result pair with a success indicator of true will query the element count of the associated control array.

The algorithm for the property is comprised of two declarative functions that returns a control array containing the selectable items of the drop down meta layer control. The process of creating this array begins by retrieving the DropDown child collection . Using the single control hierarchy instance contained within this array as the starting context each child control hierarchy instance that has an HTML tag type property of DIV is added to a new control hierarchy array. This control array is then returned as the result via the result pair.

The action meta object defines the two meta object properties name and expected value whose values are inherited from the interface action meta object. Because this action has an associated expected value its execution includes both a starting context control as well as an expected value name value pair array. The expected value array for this action contains a single name value pair which defines the runtime value associated with the item name identifier.

The algorithm for the action is designed to select a drop down item by name following a three step process. Each step is represented by a declarative function branch that starts at the root execute declarative function . The first branch checks whether the drop down is visible and if it s not clicks the drop down button. Note that if the visible property of DropDown is not true then the on failure property prevents the branch from continuing execution and prevents a success indicator of false from being returned. It then identifies the DropDown items and searches for an item that matches the item name value. If a match is made the item is clicked. If an item was selected the algorithm then verifies that the current value displayed in the input field of the drop down is equal to the item name value. If all three steps return a success indicator of true then the action returns an indicator that is passed. Otherwise it returns an indicator that it failed.

With the implementation complete the design process ends by registering the implementation with the control manager of meta layer . The name used when registering the implementation is preferably unique and may include details related to its application and control context to assist in avoiding a name clash. In this example the implementation of the control is registered with the name my app drop down implementation. A final registration with the meta broker is made to make this implementation visible to other layers e.g. abstraction layer application layer within the system . This registration provides the implementation and associated interface meta objects and names.

Referring now to application layer has dual responsibilities within the system . It provides control test suite designers with a set of meta objects used to customize tree structures that represent the allowed parent child relationships between meta layer implementations e.g. implementation for a given application or technology. Each implementation defined within the meta layer provides an identity meta object used to identify instances of the control it represents in an application. Each application layer tree structure also enables the designer to define rules that are evaluated for each identity identified instance to determine what control hierarchy instance properties are needed to identify a specific instance within the context of its application screen. By combining an implementation of a tree structure relationship with a control hierarchy of a running application from the abstraction layer the application layer creates a new hierarchy whose elements are composed of an implementation and the identified control hierarchy instance for that implementation. This hierarchy is used by three APIs defined within the application layer that enable test designers such as automated test designers to extract references for controls of interest in a given screen transform these control references to new references of the same control implemented within a different technology and execute actions or properties of a control.

The application layer parent child tree structures are designed using an application layout GUI Element Binding and uniqueness rule meta objects. Each tree structure is encapsulated and contained by an application layout meta object customized using its meta object properties to indicate what technology and view is compatible with the contained tree. Application layout meta objects maintain a GUI Element Binding collection that supports the addition of multiple GUI Element Binding meta objects with each GUI Element Binding in an application layout representing the root of a tree structure. Multiple tree structures defined for a single application layout are allowed to support technologies that provide more than one top level window types such as dialogs versus standard windows.

Each node of a tree structure is created using a GUI Element Binding meta object which contains a GUI Element Binding collection a uniqueness rule collection and a reference to an implementation meta object . The implementation meta object referenced by the GUI Element Binding defines the control type associated with the node. Each child GUI Element Binding added to a parent GUI Element Binding collection defines an allowable meta layer implementation that may be found nested within the parent meta layer implementation . A GUI Element Binding with no elements in its GUI Element Binding collection is a leaf node of the tree structure and represents a meta layer control that is not a container for other meta layer controls. References to a single GUI Element Binding meta object may be added to many Gill Element Binding collections which in some cases may create circular references within the tree structure. This behavior is allowed to ensure that repeating parent child pattern matches may be identified regardless of the depth of a control hierarchy of an application .

When GUI Element Binding meta objects are evaluated against an application control hierarchy e.g. DOM hierarchy their associated identity from implementation is used to evaluate hierarchy controls for a match to the meta layer control encapsulated by the implementation . When a match is made to a hierarchy control the APIs for the application layer will be required to provide a relocate able string based reference to the hierarchy. Each reference contains a series of name value pairs that encode properties of the tree structure used to evaluate the control hierarchy of the source application and the identity matched hierarchy control. The tree structure properties used in a reference are queried from the application layout meta object encapsulating the current tree structure. The control hierarchy instance properties used in a reference are determined by executing the uniqueness rule collection members of the GUI Element Binding . Each uniqueness rule provides meta object properties that define the criteria under which the rule is applied and the property name whose value should be used use as part of the reference. When the uniqueness rules for the a GUI Element Binding are executed each uniqueness rule is passed the control hierarchy instance for which a reference is being created. Using this control hierarchy instance the uniqueness rule then evaluates all meta object property defined criteria which in a simple implementation would constitute property verifications. Using this approach as an example if all properties passed verification then the uniqueness rule would query the control for the value associated with the test designer defined property name. The property name and value would then be encoded into a name value pair format and added to the end of the current reference string. If one or more properties failed verification the uniqueness rule exits execution effectively skipping the rule.

Once a tree structure has been configured it is registered with the application layout manager using a name unique to all application layouts registered within the system . The application layout manager is responsible for managing the life cycle of all application layouts that have been registered within the system and must provide an API that handles their addition removal verification retrieval and persistence.

The method for creating automated tests within the system includes two processes. In the first process the test designer extracts references to specific meta control instances used in their test cases. The application layer API supporting this process is implemented by the object manager component. This API for the component provides methods that enable a test designer to query for tree structures and running applications visible within the system . Then by passing a selected target application and a tree structure that supports the chosen application the test designer calls the API of the object manager to request the control instances for the current screen. The control instances returned to the test designer are represented as their string based reference created by the uniqueness rules of the GUI Element Binding .

Once references are created the test designer implements scripts that emulate the user interaction required for their test cases. This second process is supported by the API for the execution manager which implements methods to execute actions and retrieve or verify properties of a meta control using a reference input. Before an action or property can be executed an implementation meta object and starting context hierarchy control is acquired by resolving the input reference to a member of the application layer created hierarchy. The API of the execution manager calls on the API of the object manager to perform this reference resolution. In addition to the reference a name is provided which indicates the property or action meta object that will executed by the script call. Lastly in the case of executing actions the user provides any name value pairs that correspond to the expected values of the action .

The API of the execution manager also provides methods that allow references created for a specific application and technology to be transformed into equivalent references for the same application in a different technology. These methods are supported by the transformation engine component of the application layer . Before an application technology specific reference can be transformed the test suite designer configures the transformation engine using transformation rule meta objects. Similar to uniqueness rules transformation rules include one or more criteria and associated result. Each transformation rule takes the source reference string as an input and if its criteria such as name value pairs matching on a value or pattern are verified as true will return a string representing a fragment of the transformed reference. Like declarative functions system developers may choose to implement different types of transformation rule to handle static and dynamic re mapping of references. Static rules enable designers to alter some aspect of a name value pair according to logic that is known at design time while dynamic rules require a live application to be present that provides a runtime context from which session specific values can be re mapped. Once all existing transformation rules are executed a new reference returned by the transformation engine is created by concatenating all fragments together.

Referring back to a connectivity layer provides a plug in service architecture that enables system developers or third party providers a means of creating connectivity interfaces to the system . By means of the public APIs exposed by each layer e.g. abstraction layer meta layer application layer of the system each plug in can create domain business and or application models that best support the type of connectivity interface they implement. Examples of connectivity interface implementations include established protocols and technologies such as tcp ip named pipes web services COM DCOM .Net JAVA CORBA as well as custom GUI based applications designed to create and execute automated test scripts.

The persistence service is responsible for defining and providing a persistence API to those system layers where meta objects are created by test suite designers. A possible system persistence strategy is for each meta object type to implement a common persistence API that allows the extraction of meta object property names and associated values. Using this approach the persistence data for each meta object is reduced to its type and meta object property data. Since meta object properties are either strings or references to other meta objects persistence data is extracted hierarchically and as such lends itself to persistence mediums or encoding strategies such as XML that support data relationships.

The logging service provides a standard means by which any layer can report information during the course of system execution. The logging service may provide alternative means by which users can capture logging data during system use. In addition depending on the implementation used to enable test suite designers to create meta layer and application layer meta objects the logging service may choose to support multiple logging channels or levels that enable separation between different types or classifications of logs such as layer created declarative function created or exception created logs.

This system has been designed to provide a layered API designed to decouple and abstract automated testing solution dependencies into components that allow the greatest flexibility and extensibility. The system software responsible for meeting this aspect includes three types of external dependencies. Generally these are a driver that provides direction a medium for persistence of system data and the applications under test. In there is displayed an example configuration of the system assuming deployment on a single machine . In this example the driver is represented as a GUI and the persistence medium a database. However these could be any form of communication supported by the connectivity layer of the system or persistence technology available. Deployment options for the system software are largely based on the approach used to implement the system .

As will be appreciated by one skilled in the art aspects of the present disclosure may be embodied as a system method or computer program product. Accordingly aspects of the present disclosure may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer usable or computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory RUM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with and instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing. The program code may execute entirely on the user s computer partly on the users computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

It will be understood that various functions or operations of the present disclosure can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks. These computer program instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function acts specified. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified.

