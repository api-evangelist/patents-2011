---

title: Software architecture for validating C++ programs using symbolic execution
abstract: Particular embodiment compile a C++ program having one or more input variables to obtain bytecode of the C++ program; compile a C++ library to obtain bytecode of the C++ library; symbolically execute the bytecode of the C++ program and the bytecode of the C++ library, comprising assign a symbolic input to each input variable of the C++ program; determine one or more execution paths in the C++ program; and for each execution path, construct a symbolic expression that if satisfied, causes the C++ program to proceed down the execution path; and generate one or more test cases for the C++ program by solving the symbolic expressions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08869113&OS=08869113&RS=08869113
owner: Fujitsu Limited
number: 08869113
owner_city: Kawasaki-shi
owner_country: JP
publication_date: 20110120
---
This disclosure generally relates to testing and validating computer software and more specifically relates to testing and validating computer software written in C C or C using symbolic execution and automatic test generation.

Validating or verifying computer software is a common concern among software developers and users. Whether a piece of software is for example a desktop application for installation and execution at one or more client computer systems or a web application for execution at one or more server computer systems it is often important to carefully verify the quality of the software in order to ensure that it functions correctly. While some types of errors in software such as bugs cause annoyance or inconvenience to software users other types of errors in software have the potential of causing more serious problems possibly even resulting in significant financial losses to institutions.

Software testing is a common method of verifying the quality of software. With software testing the software or one or more portions of the software under analysis is are put through a suite of regression tests after each revision or modification and the outputs are evaluated for correctness. However software testing often provides only limited coverage and has a tendency to miss corner case bugs. Formal verification tends to address these problems. Formal verification mathematically proves the satisfiability of a specific requirement on the software under analysis or obtains a counter example in the form of a test case that breaks the requirement and thus indicates a bug.

A software application may include any number of modules and each module may be tested or validated individually or multiple modules may be tested or validated in combination. A software module may be tested or validated manually or automatically. In the former case a person e.g. a software testing engineer may manually design test cases for the software module based on the design specification of the module execute the module under the test cases and check for module behavior or output that does not agree with the test cases. In the later case a software testing tool implemented as computer software or hardware may automatically generate test cases for a software module under analysis execute the module while simulating the test cases and check for module behavior or output that does not agree with the test cases.

Particular embodiments provide symbolic execution and automatic test generation for computer software written in C C or C . More specifically particular embodiments provide a symbolic execution and automatic test generation tool for formally validating computer software written in C C or C . In particular embodiments a C C or C program e.g. a software application or module is complied into Low Level Virtual Machine LLVM bytecode and then dynamically linked to a light weight C or C library to symbolically execute the program. In particular embodiments low level libraries e.g. the POSIX C library and the C library are implemented to avoid superfluous paths and support in house solving. In particular embodiments efficient solvers for commonly used data structures such as string integer or vector are provided to reduce processing time. In particular embodiments specific handlers are used to optimize the processing of domain specific operations such as database access. In particular embodiments the symbolic execution and automatic test generation tool supports data structures with symbolic lengths and is able to automatically generate test cases with high coverage guarantee and reveal bugs in the C C or C program omitted by traditional testing tools.

A software application is often organized into a number of software modules and each software module may include code that perform specific functionalities. In a typical scenario a software module may have any number of input or output variables. When the software module is invoked actual input values may be passed to the software module e.g. by the code that has invoked the software module as the values assigned to the input variables of the software module. The code of the software module may be executed in connection with the actual input values. Eventually actual output values for the output variables of the software module may be determined and returned by the software module e.g. to the code that has invoked the software module at which point the software module completes its execution. Moreover the actual output values determined by the code of the software module usually depend on the actual input values passed to the software module upon its invocation. In addition the software module may have any number of local variables also referred to as intermediate variables whose values may also depend directly or indirectly on the values of the input variables. A local variable has a local scope. It only exists and is only accessible from within the context of the software module in which the local variable is declared. In contrast the software application to which the software module belongs may have any number of global variables. A global variable has a global scope within the software application itself and is accessible to all the software modules that belong to the software application. When a software module is invoked it may access or modify the value of a global variable and the value modification is persistent even after the software module completes its execution.

In particular embodiments when the value of a first variable is determined based on the value of a second variable i.e. the value of the first variable depends on the value of the second variable the first variable is considered to depend on the second variable. A variable whether input or output and whether local or global usually has a specific data type such as for example and without limitation character string integer float double Boolean pointer array and enumeration. The data type of a variable indicates what type of data e.g. actual values may be assigned to the variable. For example only integer values should be assigned to a variable whose type is integer and only true false values should be assigned to a variable whose type is Boolean. Different programming languages may define different data types that the variables of the software modules or applications written in the specific languages may have as well as different operations that may be applied to the specific data types.

A software application may be formally tested and validated. In particular embodiments to formally test and validate a software application the individual modules included in the software application are formally tested and validated. In particular embodiments a software module may be formally tested and validated using symbolic execution. More specifically particular embodiments may use symbolic execution to automatically generate test input values to be used for testing the software module. These test input values may be assigned to the input variables of the software module under analysis when the software module is invoked for testing purposes and the output values resulted from the software module based on these test input values may be analyzed to determine the behavior of the software module and formally validate the software module.

In the filed of computer science symbolic execution refers to the analysis of software programs by tracking symbolic rather than actual values as a case of abstract interpretation. It is a non explicit state model checking technique that treats input to software as symbol variables. It creates complex equations by executing all finite paths in the software with symbolic variables and then solves the complex equations with a solver typically known as a decision procedure to obtain error scenarios if any. In contrast to explicit state model checking symbolic execution is able to work out all possible input values and all possible use cases of all possible input values in the software under analysis. Thus symbolic execution can exhaustively validate software under analysis.

To further explain symbolic execution consider an example software module e.g. a method written in C named foo 

Software module foo has two input variables a and b and two local variables c and d . In particular embodiments the value of a local variable may depend directly or indirectly on the value of one or more input variables of the software module. For example with module foo the value of local variable c depends directly on the values of input variables a and b as indicated by line 3 of the code and the value of local variable d depends indirectly on the values of input variables a and b through local variable c as indicated by line 5 of the code. In addition module foo contains a conditional branching point at line 4 of the code caused by the if else statement. The conditional branching point at line 4 is associated with a branching condition c qrs . Depending on whether this branching condition is satisfied or holds true that is whether local variable c equals qrs module foo proceeds down different execution paths and different portions of the code of module foo is actually executed. More specifically if local variable c does not equal qrs then the value of local variable d is computed and returned as indicated by lines 5 and 6 of the code. On the other hand if local variable c does equal qrs then the value of local variable c is returned as indicated by line 8 of the code.

When symbolic execution is performed on module foo its input and local variables are each assigned a symbolic value instead of an actual value. illustrates an example execution flow representing the steps of performing symbolic execution on module foo . In this example input variable a is assigned symbolic value x input variable b is assigned symbolic value y local variable c is assigned symbolic value z and local variable d is assigned symbolic value w . Since variables a b c and d are of type string symbolic values x y z and w each represent an arbitrary string.

In addition is the symbolic expression that represents the result of the symbolic execution at various points along the execution paths. More specifically at which corresponds to line 2 of the code of module foo variables a b c and d are assigned their respective symbolic values x y z and w and initially has an empty or null expression. As the execution proceeds further expressions are added to depending on what code has been executed. At which corresponds to line 3 of the code of module foo has the expression z x y because line 3 of the code is c a b and x y and z are the symbolic value assigned to variable a b and c respectively. Next line 4 of the code of module foo is a conditional branching point and there are two possible execution paths down which the execution may proceed. Thus the symbolic execution may also proceed down two different paths from the first path PATH includes and corresponding to lines 5 and 6 of the code and the second path PATH includes corresponding to line 8 of the code.

In order to proceed down PATH variable c does not equal qrs which means symbolic value z does not equal qrs . Therefore the expression z qrs is added to at . Conversely in order to proceed down PATH variable c does equal qrs which means symbolic value z equals qrs . Therefore the expression z qrs is added to at . Along PATH the value of variable d is determined at line 5 of the code which corresponds to . Therefore the expression w z t is added to at . Note that because z x y the expression for w may be rewritten as w x y t . is the end of PATH and thus the expression of at represents the conditions in symbolic form that need to be satisfied in order to reach the end of execution PATH . Similarly is the end of execution PATH and thus expression of at represents the conditions in symbolic form that need to be satisfied in order to reach the end of PATH .

Since module foo has two possible execution paths symbolically executing module foo results in two sets of expressions one corresponding to each execution path. In particular embodiments solving for the expression of at may provide the actual values for input variables a and b that cause module foo to reach the end of PATH and solving for the expression of at may provide the actual values for input variables a and b that cause module foo to reach the end of PATH .

In particular embodiments the expressions obtained from symbolically executing a software module e.g. at and in may be solved using a solver. For example a solver for solving symbolic expressions may be implemented based in part on the Satisfiability Modulo Theories SMT . In particular embodiments a SMT solver may take as input a symbolic expression which may include any number of constraints that need to be satisfied in order to proceed down a specific path in the software module and attempt to find one or more solutions that satisfy all the constraints from the symbolic expression. If any solution may be found the SMT solver may provide the solution as its output. Of course it is possible that a symbolic expression may not have any solution that satisfy all the constraints in the expression in which case the expression is considered unsatisfiable or unsolvable. In particular embodiments the outputs from the SMT solver may be used as test cases for formally testing and validating the software module.

For example in at is the expression for PATH w x y t z qrs . The solutions obtained from solving this expression may be used as test cases for testing module foo along PATH . Similarly at is the expression for PATH z x y z qrs . The solutions obtained from solving this expression may be used as test cases for testing module foo along PATH .

As the above example illustrates symbolic execution is a software program or software module analysis technique that starts the execution of a software program or module on symbolic rather than concrete inputs and it computes the effect on the software program or module on these symbolic inputs using symbolic expressions e.g. the symbolic expressions represented by in . Symbolic execution characterizes each path in a software module it explores with a path condition defined as a conjunction of Boolean expressions. Each Boolean expression denotes one branching decision made during the execution of a distinct path of the program or module under test e.g. PATH and PATH illustrated in . When the execution is finished multiple path conditions may be generated each corresponding to a feasible execution path of the code in the software module with respect to the symbolic input. The solutions to these conditions are the test inputs. In addition during symbolic execution some sanity properties may be checked such as memory out of bound access divide by zero and user defined assertions. Symbolic execution thus has the advantage of achieving much more coverage of program behaviors than traditional testing approaches.

Currently there exit no symbolic execution tools for computer software written in C which is a statistically typed free form multi paradigm complied general purpose programming language. Existing symbolic execution tools such those suitable for computer software written in C are inefficient due to the lack of good abstractions of library Application Programming Interfaces APIs fast solvers for commonly used data structures domain specific handlers and so on. To address these problems particular embodiments provide a symbolic execution and automatic test generation tool especially suitable for software written in C C or C that includes customized implementations of low level libraries e.g. the POSIX C library and the C library to avoid superfluous symbolic paths and improve solver performance uses an intermediate language IL to model a set of application specific AS operations and compiles the C C or C program under analysis and C library to LLVM bytecode.

Suppose a program is to be analyzed e.g. formally validated using symbolic execution . As an example further suppose that program is written in C . Program may have one or more input variables. In particular embodiments each input variable may be assigned a symbolic value. Thus program has symbolic inputs.

Typically a C or C program may require one or more runtime libraries when being compiled or executed. For example these libraries may include the C library or the C library provided by a C or C compiler In addition there may be one or more user libraries. In particular embodiments these libraries may be dynamically linked to the C or C program at runtime. Suppose a library includes the necessary libraries required by program which may include the C library the C library and any user library.

In particular embodiments program and library may be compiled by bytecode compiler to generate program bytecode for program and library bytecode for library as illustrated in STEP . In particular embodiments compiler bytecode may be any suitable C compiler that is capable of compiling the source code of a C program into bytecode. For example bytecode compiler may be a LLVM compiler e.g. LLVM G compiler in which case program bytecode and library bytecode are LLVM bytecode.

In particular embodiments program bytecode and library bytecode may be symbolically executed by symbolic executor as illustrated in STEP . As described above in connection with through symbolic execution the possible execution paths in a software module caused by conditional branches in the source code e.g. a if else statement may be individually analyzed and a symbolic expression may be obtained for each path.

The C programming language is an object based language objected oriented programming language . It has unique features such as classes that are not available with the C programming language. When a C program is complied into bytecode it also has unique features not available with bytecode obtained from compiling for example a C program. Thus in order to symbolically execute the bytecode resulted from compiling a C program the symbolic executor used needs to be able to handle these unique features from the C programming language. In particular embodiments symbolic executor is capable of handling all C features as well as features from C C or another other applicable programming language.

In particular embodiments when symbolically executing the bytecode of a program a symbolic state is used to model a machine execution state. In particular embodiments a register stores a concrete value or a symbolic expression. In particular embodiments mimicking the machine stack a symbolic stack consists of multiple frames. In particular embodiments a memory is organized as components each of which has a concrete address and an array of bytes recording the value. In particular embodiments the fields of a C object are allocated consecutive memory blocks. For example suppose that the addresses of the two fields of an object are mand mrespectively and the relation m m size fd holds. On the other hand the memory blocks of different objects do not have to be consecutive which can support automatic resizing described in more detail below . The following example illustrates the memory block allocations for two objects each having a number of fields 

To support object level reasoning described in more detail below in particular embodiments an entire object may be represented by a single symbolic expression whose width is equal to the size of the object. Width checking is an important approach to ensure a symbolic executor s e.g. symbolic executor sanity. In particular embodiments if a pointer can refer to multiple components a new state is generated for each possible reference decided by a solver e.g. solver when solving the symbolic expressions. Although this method may be expensive for pointers with large points to sets typical programs only use symbolic pointers that refer to a single component and there may be optimization for this case.

In particular embodiments symbolic executor interprets program bytecode and library bytecode . In particular embodiments most C features such as polymorphism and templates are handled by bytecode compiler e.g. LLVM GCC compiler . However since C programs are far more complicated than C programs this may introduce extra LLVM instructions mainly LLVM intrinsic functions that need to be handled by symbolic executor . In particular embodiments symbolic executor may implement some advanced instructions in order to handle these extra LLVM instructions. In practice there may be more than fifteen such advanced instructions. For example the llvm.stacksave intrinsic is used to remember the current state of the function stack which is to be restored by llvm.stackrestore as illustrated in As another example the three llvm.bswap instructions byte swap integer values with an even number of bytes as illustrated in . Symbolic executor may implement these instruction and the implementation of these instructions follows their semantics.

The C programming language provides built in support for raising and handling exceptions. The eight llvm.eh instructions along with external exception calls need to be interpreted in the right exception semantics e.g. exception handling in C propagates the exceptions up the stack . In particular embodiments a specific data structure is used by symbolic executor to represent exceptions. Symbolic executor builds the exception table and interprets the exception instructions according to their semantics. In practice there may be approximately ten such exceptions.

In particular embodiments symbolic executor uses a C memory model which involves many atomic operations and synchronization intrinsics. For example llvm.memory.barrier guarantees ordering between specific pairs of memory access types and llvm.atomic.load.add performs the add and store atomically. In particular embodiments with symbolic executor these intrinsics are implemented by serializing the operations. For example atomic.cmp.swap is implemented by a compare operation followed by a swap operation and atomic.load.max is by a load followed by the max function. In particular embodiments no interfering from other instructions is allowed between the two operations. In practice there may be approximately thirteen instructions involved with the C memory model.

In particular embodiments symbolic executor supports floating point numbers. In practices there may be more than thirty instructions and intrinsics for manipulating floating numbers. Particular embodiments extend the intermediate representation and use more advanced SMT solvers e.g. as a part of solver to support floating point numbers.

In particular embodiments each symbolic expression may be solved using solver to obtain one or more test cases as illustrated in STEP . In particular embodiments solver may be a SMT solver which take symbolic expressions as input and provide test cases as output. In addition in particular embodiments symbolic execution may also provide statistics information such as bytecode coverage and sanity and functional correctness.

In particular embodiments test cases may then be used to formally test and validate program using for example tester as illustrated in STEP . For example program may be complied into machine code using machine code compiler and executed on a computing device in a real life setting e.g. a setting that is similar to the environment in which the program is intended to be execute while applying test cases to determine coverage information about program using for example tools such as gcov or lcov. If there is any error e.g. program bugs in the source code of program it may be discovered through the testing process. In particular embodiments machine code compiler may be any suitable C compiler e.g. gcc that is able to compile a C program into executable machine code. Machine code compiler may provides a C library or C library already compiled into machine code which may be dynamically linked to program machine code at runtime.

In order to further improve system particular embodiments may implement a number of optimizations for system . These optimizations in some cases scale up the performance of system .

First particular embodiments may optimize the C library e.g. library used with system . The C standard includes a library for all commonly used data structures and algorithms. Instead of using the standard C library coming with a compiler e.g. the GCC compiler particular embodiments choose and optimize the uClibc library so as to improve the performance of symbolic execution. In this case library in system is the optimized C library. Particular embodiments compile this optimized library into LLVM bytecode e.g. library bytecode and load it into the engine at the beginning of symbolic execution. Particular embodiments maintain two versions of the C library one for symbolic execution the other one for handling concrete values and the Just In Time compilation of external functions such as system APIs. When the expression contains no symbolic variable or an external function is to be made the standard uClibc library is used otherwise the one optimized for symbolic execution is used.

The C standard comes with a standard library defining over forty classes. Unfortunately they are designed for concrete execution. Efficient symbolic execution may require particular embodiments to rewrite some or all the C and C class implementation to cater for the need of symbolic execution such as 1 unnecessary conditional statements should be avoided to reduce the number of generated paths 2 expensive expressions should be converted into cheaper ones e.g. multiplications are replaced by bit operations and 3 fast decision procedures shall be built into the library implementation. In particular embodiments library used system contains a number of commonly used classes highly optimized for symbolic execution.

As described above in connection with with symbolic execution the individual execution paths in the source code of a software module is analyzed. A branching or forking of the execution path occurs when there is a conditional branching statement such as an if else statement. Typically when the branching conditions are satisfied the program proceeds down one execution path and when the branching conditions are not satisfied the program proceeds down another execution path. Each execution path results in a symbolic expression at the end. The more execution paths there are in a software module the more symbolic expressions result from symbolic execution. If there is a branching condition inside for example a loop then for every iteration of the loop there is a branching or forking of the execution path. In such cases there may be an exponential blow up in the number of execution paths resulting from the repeated branching occurring at every iteration of the loop and this in turn may result in a very large number of symbolic expressions. The symbolic expressions will themselves grow in size exponentially which will render them difficult to solve by a solver.

Particular embodiments may modify the source code of the standard C library functions to move branching conditions outside of loops while maintaining the same functionalities of these library functions. This way having a loop with many iterations does not result in many execution paths. More specifically particular embodiments modify the body of a library function and return an expression. This optimization may be considered as an operational approach since the body of the function is still executed directly. For example the compare method of the String class in the uClibc library may be modified as follows. The modified compare method produces only one execution path regardless of the values of the two input strings of concrete lengths because there is no conditional branching inside the for loop.

Particular embodiments may provide some hack in functions to access symbolic executor . For example function is symbolic tells whether a variable s value is symbolic and function make ite asks symbolic executor to create an if then else expression so as to avoid creating two paths. The library optimization uses these functions to interact with symbolic executor .

The operational method may build up a very complicated symbolic expression as the return value. To avoid this particular embodiments may develop another method which adds constraints into the current state rather than executes all the code. This optimization may be considered a relational approach. For a function symbolic executor is informed to create a symbolic variable Vr representing the return value and then relate this variable with the inputs of the function using logical formulas. For example the find last of method of the String class is illustrated below. Function assume indicates to symbolic executor to put the constraint into the path condition. This implementation produces only one execution path even when the return value can be 1 or any position within the input string. In fact such definitions implement a decision procedure e.g. for the String class in the source code. In particular embodiments building solvers e.g. as a partial replacement of standalone solver through source code definitions is a core feature of system . This avoids the complexity of implementing such external solvers.

The following example illustrates how the optimized library implementation results in a fast solver for strings replacing part of the functionality of external solver 

In this example the String.find last of function is used as a specific illustration. In particular embodiments upon visiting the first statement at line 1 symbolic executor adds the constraints shown above into the path condition where Vr is replaced a fresh variable i i represents an integer . This variable is written into the destination register and then propagated along the execution. Thus the k variable in the above source code is replaced with i. Similarly the second statement at line 2 is executed leading to a fresh string variable s replacing the rest variable. At line 3 the find method results in another integer variable i. Then the path condition contains the conjunction of all constraints relevant to find last of substr and find. The conditional statement i npos along with the path condition containing all the constraints is dumped to SMT solver to obtain a test case on the input string str for one execution branch. Similarly the condition i npos along with the path condition containing all the constraints is dumped to SMT solver to obtain a second test case on the input string str for the other branch. In other words particular embodiments implement a string solver by purely modifying the source code. It does not require modifying the executor s e.g. symbolic executor intermediate language or linking in external solvers. It is highly extensible since the source C code is easy to modify. Furthermore the correctness of the code can be checked directly using symbolic execution. This technique may be similarly extended to handle other C or C library classes.

One of the main features of the C programming language is class and object. Particular embodiments extend the intermediate language IL used by system to model C classes and objects directly. During symbolic execution the symbolic expressions may contain symbolic variables representing the objects and the names of method calls on these objects. In particular embodiments a method call is not immediately expanded to its implementation when it is first encountered. Instead a lazy evaluation approach is adopted to delay the evaluation of objects and methods until they are needed. This also helps the simplification and reasoning on the objects. For example the following piece of sample code involves the String class.

Upon encountering the branching condition at line 3 the expression str.substr str.find last of 1 EasyChair is built which may be simplified with respect to the semantics of these string operations to str s EasyChair for a free string variable s. Particular embodiments build in such simplifications and decision procedures described in more detail below for common classes. Note that particular embodiments may simply use the library definitions of the methods to interpret this expression now the interpretation is delayed to the condition point. For particular embodiments extending the intermediate language for object level abstractions may be crucial for the symbolic execution of object oriented programming languages such as C .

To further improve the performance of object level reasoning particular embodiments implement specific solvers e.g. included in solver for some common data structures. For example particular embodiments may implement a string solver based on SMT solving which may be incorporated seamlessly in symbolic executor . Consider the example illustrated above particular embodiments may implement a string solver that creates the following expression constraining the values and lengths of the string variables whose lengths are not fixed 

In this example the constraints on the lengths are first extracted and dumped to solver to get a minimal instance of each length and then the length of each string is set and the constraints on the strings are built and dumped to solver to obtain a satisfiable case. With such built in solvers incorporated in solver particular embodiments only improve the performance of system but also loose constraints on the inputs e.g. having variable lengths .

Sometimes when a symbolic expression e becomes very complicated a regular SMT solver may take too much time to respond. For such cases in particular embodiments the users may choose to concretize e s value. In particular embodiments solver may give a possible value or a small set of values for each involved symbolic variable such that e is satisfiable. Then this knowledge is added into the path condition by replacing the involved variables with their concrete values.

In practice a software validation system usually generates more than 10 000 test cases so as to obtain high coverage even for small C programs. In particular embodiments system may also suffer from this problem when the program being analyzed has loops whose bodies contain many branches. In particular embodiments the effort to minimize the number of test cases is essential to make a software validation system such as system usable and friendly to the users especially for industrial applications. Thus particular embodiments develop some path reduction mechanisms to avoid visiting the blocks or branches that do not lead to new coverage. In particular embodiments the first approach is based on a reachability analysis. More specifically when a branch is encountered particular embodiments check whether it will lead to some unvisited corner instructions by chasing the subsequent control flows. The corner instructions include branch instructions procedure call instructions or those specified by the users. To bound the chasing limits are set on chasing over procedures. Although this approach may miss some e.g. tricky branches it is effective in reducing around approximately 90 duplicate paths without sacrificing the coverage for unit testing where a lot of redundancy exist in the diver. Particular embodiments may also develop a lossless approach mainly for component testing which delays the exploration of branches whose path conditions are independent of those already visited. It mimics the Partial Order Reduction POR algorithms used in model checkers. In particular embodiments variety of optimizations may be employed in system such as for example and without limitation expression rewriting constraint set simplification constraint independence compact state representation implied value concretization counter example cache and compact state representation.

It is inefficient to execute the bytecode of the implementation of a function call each time it is seen especially considering that the same function may be invoked many times. In practice functions may be related to each other and in particular embodiments the relationship between functions may be specified in a high level. The concrete implementation of these functions shall satisfy this relationship. This is particularly the case for C classes whose methods may be grouped together with respect to data member accesses.

For example a C class usually provides a read method getvalue and a write method setvalue to access the private data members of the class. Their semantics satisfies rules or theorems obj.setvalue i v .getvalue i v and obj.setvalue i v .setvalue j w .getvalue i if i j then w else v . Particular embodiments may utilize these rules for the purpose of optimizing system . Particular embodiments may first build up these rule and then use them during symbolic execution to avoid executing the bytecode implementation of these methods. This technique may be referred to as Meta Execution since the execution is in the mete level where the method names rather their definitions are manipulated. Of course the sanity of these rules should be proved once and for all by for example symbolically executing the bytecode annotated with post conditions.

Particular embodiments may extend the intermediate language IL used by system to model an object and its methods directly. During symbolic execution a symbolic expression may contain symbolic variables representing the objects and the names of the methods. A method call will not be expanded to its bytecode implementation.

To solve such an expression particular embodiments may apply a set of rules to simplify the expression until no more simplification is possible. For example with a Boolean expression if the result is true or false then a conclusive answer may be obtained. In particular embodiments an independent variable which is not related to others in the expression can be instantiated to an arbitrary value. If there are not enough rules to simplify an expression then particular embodiments may use the bytecode implementation of the involved methods or any specific solver to solve it.

In particular embodiments the rules may be specified by the users who have the sufficient and specific knowledge about the application under analysis or derived automatically or semi automatically from the source code and unit testing code. Typical unit testing code establishes the relation between methods.

For each rule derived particular embodiments use symbolic execution to verify its correctness. Once it is proved correct the rule maybe used anywhere during the meta execution without causing false alarms.

To further explain the concept of application specific meta execution consider an example database application which uses methods insert get delete and count to access a database. An empty database object is denoted by db. The following sample code executes a sequence of database operations 

Right before the condition statement the if statement at line 5 IL expression db.insert k v .insert k v .delete k is built which may be simplified to if k k then dbelse db.insert k v . During symbolic execution this branching expression may spawn two states one with k k and an empty object the other one with k k and an object containing entry k v . For the first state the condition is false. For the second state expression db.insert k v .get k is simplified to v then predicate v v will lead to two execution paths if v and v are symbolic variables.

The rules used in this example include the following. Note that the entries in the object are sorted according to their keys. If the keys have symbolic values the entries in the database may overlap with each other over the keys. For example the key of an incoming entry may or may not equal to that of an existing entry. In this case the process may spawn two states one for the equality case and one for the inequality case.

In particular embodiments each rule needs to be verified. For example to verify the first rule the following driver program with a post condition may be implemented and executed in system e.g. by symbolic executor .

Particular embodiments may be implemented in a network environment. illustrates an example network environment suitable for providing software validation as a service. Network environment includes a network coupling one or more servers and one or more clients to each other. In particular embodiments network is an intranet an extranet a virtual private network VPN a local area network LAN a wireless LAN WLAN a wide area network WAN a metropolitan area network MAN a portion of the Internet or another network or a combination of two or more such networks . This disclosure contemplates any suitable network .

One or more links couple a server or a client to network . In particular embodiments one or more links each includes one or more wireline wireless or optical links . In particular embodiments one or more links each includes an intranet an extranet a VPN a LAN a WLAN a WAN a MAN a portion of the Internet or another link or a combination of two or more such links . This disclosure contemplates any suitable links coupling servers and clients to network .

In particular embodiments each server may be a unitary server or may be a distributed server spanning multiple computers or multiple datacenters. Servers may be of various types such as for example and without limitation web server news server mail server message server advertising server file server application server exchange server database server or proxy server. In particular embodiments each server may include hardware software or embedded logic components or a combination of two or more such components for carrying out the appropriate functionalities implemented or supported by server . For example a web server is generally capable of hosting websites containing web pages or particular elements of web pages. More specifically a web server may host HTML files or other file types or may dynamically create or constitute files upon a request and communicate them to clients in response to HTTP or other requests from clients . A mail server is generally capable of providing electronic mail services to various clients . A database server is generally capable of providing an interface for managing data stored in one or more data stores.

In particular embodiments one or more data storages may be communicatively linked to one or more severs via one or more links . In particular embodiments data storages may be used to store various types of information. In particular embodiments the information stored in data storages may be organized according to specific data structures. In particular embodiment each data storage may be a relational database. Particular embodiments may provide interfaces that enable servers or clients to manage e.g. retrieve modify add or delete the information stored in data storage .

In particular embodiments each client may be an electronic device including hardware software or embedded logic components or a combination of two or more such components and capable of carrying out the appropriate functionalities implemented or supported by client . For example and without limitation a client may be a desktop computer system a notebook computer system a netbook computer system a handheld electronic device or a mobile telephone. This disclosure contemplates any suitable clients . A client may enable a network user at client to access network . A client may enable its user to communicate with other users at other clients .

A client may have a web browser such as MICROSOFT INTERNET EXPLORER GOOGLE CHROME or MOZILLA FIREFOX and may have one or more add ons plug ins or other extensions such as TOOLBAR or YAHOO TOOLBAR. A user at client may enter a Uniform Resource Locator URL or other address directing the web browser to a server and the web browser may generate a Hyper Text Transfer Protocol HTTP request and communicate the HTTP request to server . Server may accept the HTTP request and communicate to client one or more Hyper Text Markup Language HTML files responsive to the HTTP request. Client may render a web page based on the HTML files from server for presentation to the user. This disclosure contemplates any suitable web page files. As an example and not by way of limitation web pages may render from HTML files Extensible Hyper Text Markup Language XHTML files or Extensible Markup Language XML files according to particular needs. Such pages may also execute scripts such as for example and without limitation those written in JAVASCRIPT JAVA MICROSOFT SILVERLIGHT combinations of markup language and scripts such as AJAX Asynchronous JAVASCRIPT and XML and the like. Herein reference to a web page encompasses one or more corresponding web page files which a browser may use to render the web page and vice versa where appropriate.

Particular embodiments may be implemented on one or more computer systems. illustrates an example computer system . In particular embodiments one or more computer systems perform one or more steps of one or more methods described or illustrated herein. In particular embodiments one or more computer systems provide functionality described or illustrated herein. In particular embodiments software running on one or more computer systems performs one or more steps of one or more methods described or illustrated herein or provides functionality described or illustrated herein. Particular embodiments include one or more portions of one or more computer systems .

This disclosure contemplates any suitable number of computer systems . This disclosure contemplates computer system taking any suitable physical form. As example and not by way of limitation computer system may be an embedded computer system a system on chip SOC a single board computer system SBC such as for example a computer on module COM or system on module SOM a desktop computer system a laptop or notebook computer system an interactive kiosk a mainframe a mesh of computer systems a mobile telephone a personal digital assistant PDA a server or a combination of two or more of these. Where appropriate computer system may include one or more computer systems be unitary or distributed span multiple locations span multiple machines or reside in a cloud which may include one or more cloud components in one or more networks. Where appropriate one or more computer systems may perform without substantial spatial or temporal limitation one or more steps of one or more methods described or illustrated herein. As an example and not by way of limitation one or more computer systems may perform in real time or in batch mode one or more steps of one or more methods described or illustrated herein. One or more computer systems may perform at different times or at different locations one or more steps of one or more methods described or illustrated herein where appropriate.

In particular embodiments computer system includes a processor memory storage an input output I O interface a communication interface and a bus . Although this disclosure describes and illustrates a particular computer system having a particular number of particular components in a particular arrangement this disclosure contemplates any suitable computer system having any suitable number of any suitable components in any suitable arrangement.

In particular embodiments processor includes hardware for executing instructions such as those making up a computer program. As an example and not by way of limitation to execute instructions processor may retrieve or fetch the instructions from an internal register an internal cache memory or storage decode and execute them and then write one or more results to an internal register an internal cache memory or storage . In particular embodiments processor may include one or more internal caches for data instructions or addresses. This disclosure contemplates processor including any suitable number of any suitable internal caches where appropriate. As an example and not by way of limitation processor may include one or more instruction caches one or more data caches and one or more translation lookaside buffers TLBs . Instructions in the instruction caches may be copies of instructions in memory or storage and the instruction caches may speed up retrieval of those instructions by processor . Data in the data caches may be copies of data in memory or storage for instructions executing at processor to operate on the results of previous instructions executed at processor for access by subsequent instructions executing at processor or for writing to memory or storage or other suitable data. The data caches may speed up read or write operations by processor . The TLBs may speed up virtual address translation for processor . In particular embodiments processor may include one or more internal registers for data instructions or addresses. This disclosure contemplates processor including any suitable number of any suitable internal registers where appropriate. Where appropriate processor may include one or more arithmetic logic units ALUs be a multi core processor or include one or more processors . Although this disclosure describes and illustrates a particular processor this disclosure contemplates any suitable processor.

In particular embodiments memory includes main memory for storing instructions for processor to execute or data for processor to operate on. As an example and not by way of limitation computer system may load instructions from storage or another source such as for example another computer system to memory . Processor may then load the instructions from memory to an internal register or internal cache. To execute the instructions processor may retrieve the instructions from the internal register or internal cache and decode them. During or after execution of the instructions processor may write one or more results which may be intermediate or final results to the internal register or internal cache. Processor may then write one or more of those results to memory . In particular embodiments processor executes only instructions in one or more internal registers or internal caches or in memory as opposed to storage or elsewhere and operates only on data in one or more internal registers or internal caches or in memory as opposed to storage or elsewhere . One or more memory buses which may each include an address bus and a data bus may couple processor to memory . Bus may include one or more memory buses as described below. In particular embodiments one or more memory management units MMUs reside between processor and memory and facilitate accesses to memory requested by processor . In particular embodiments memory includes random access memory RAM . This RAM may be volatile memory where appropriate Where appropriate this RAM may be dynamic RAM DRAM or static RAM SRAM . Moreover where appropriate this RAM may be single ported or multi ported RAM. This disclosure contemplates any suitable RAM. Memory may include one or more memories where appropriate. Although this disclosure describes and illustrates particular memory this disclosure contemplates any suitable memory.

In particular embodiments storage includes mass storage for data or instructions. As an example and not by way of limitation storage may include an HDD a floppy disk drive flash memory an optical disc a magneto optical disc magnetic tape or a Universal Serial Bus USB drive or a combination of two or more of these. Storage may include removable or non removable or fixed media where appropriate. Storage may be internal or external to computer system where appropriate. In particular embodiments storage is non volatile solid state memory. In particular embodiments storage includes read only memory ROM . Where appropriate this ROM may be mask programmed ROM programmable ROM PROM erasable PROM EPROM electrically erasable PROM EEPROM electrically alterable ROM EAROM or flash memory or a combination of two or more of these. This disclosure contemplates mass storage taking any suitable physical form. Storage may include one or more storage control units facilitating communication between processor and storage where appropriate. Where appropriate storage may include one or more storages . Although this disclosure describes and illustrates particular storage this disclosure contemplates any suitable storage.

In particular embodiments I O interface includes hardware software or both providing one or more interfaces for communication between computer system and one or more I O devices. Computer system may include one or more of these I O devices where appropriate. One or more of these I O devices may enable communication between a person and computer system . As an example and not by way of limitation an I O device may include a keyboard keypad microphone monitor mouse printer scanner speaker still camera stylus tablet touch screen trackball video camera another suitable I O device or a combination of two or more of these. An I O device may include one or more sensors. This disclosure contemplates any suitable I O devices and any suitable I O interfaces for them. Where appropriate I O interface may include one or more device or software drivers enabling processor to drive one or more of these I O devices. I O interface may include one or more I O interfaces where appropriate. Although this disclosure describes and illustrates a particular I O interface this disclosure contemplates any suitable I O interface.

In particular embodiments communication interface includes hardware software or both providing one or more interfaces for communication such as for example packet based communication between computer system and one or more other computer systems or one or more networks. As an example and not by way of limitation communication interface may include a network interface controller NIC or network adapter for communicating with an Ethernet or other wire based network or a wireless NIC WNIC or wireless adapter for communicating with a wireless network such as a WI FI network. This disclosure contemplates any suitable network and any suitable communication interface for it. As an example and not by way of limitation computer system may communicate with an ad hoc network a personal area network PAN a local area network LAN a wide area network WAN a metropolitan area network MAN or one or more portions of the Internet or a combination of two or more of these. One or more portions of one or more of these networks may be wired or wireless. As an example computer system may communicate with a wireless PAN WPAN such as for example a BLUETOOTH WPAN a WI FI network a WI MAX network a cellular telephone network such as for example a Global System for Mobile Communications GSM network or other suitable wireless network or a combination of two or more of these. Computer system may include any suitable communication interface for any of these networks where appropriate. Communication interface may include one or more communication interfaces where appropriate. Although this disclosure describes and illustrates a particular communication interface this disclosure contemplates any suitable communication interface.

In particular embodiments bus includes hardware software or both coupling components of computer system to each other. As an example and not by way of limitation bus may include an Accelerated Graphics Port AGP or other graphics bus an Enhanced Industry Standard Architecture EISA bus a front side bus FSB a HYPERTRANSPORT HT interconnect an Industry Standard Architecture ISA bus an INFINIBAND interconnect a low pin count LPC bus a memory bus a Micro Channel Architecture MCA bus a Peripheral Component Interconnect PCI bus a PCI Express PCI X bus a serial advanced technology attachment SATA bus a Video Electronics Standards Association local VLB bus or another suitable bus or a combination of two or more of these. Bus may include one or more buses where appropriate. Although this disclosure describes and illustrates a particular bus this disclosure contemplates any suitable bus or interconnect.

Herein reference to a computer readable storage medium encompasses one or more non transitory tangible computer readable storage media possessing structure. As an example and not by way of limitation a computer readable storage medium may include a semiconductor based or other integrated circuit IC such as for example a field programmable gate array FPGA or an application specific IC ASIC a hard disk an HDD a hybrid hard drive HHD an optical disc an optical disc drive ODD a magneto optical disc a magneto optical drive a floppy disk a floppy disk drive FDD magnetic tape a holographic storage medium a solid state drive SSD a RAM drive a SECURE DIGITAL card a SECURE DIGITAL drive or another suitable computer readable storage medium or a combination of two or more of these where appropriate. Herein reference to a computer readable storage medium excludes any medium that is not eligible for patent protection under 35 U.S.C. 101. Herein reference to a computer readable storage medium excludes transitory forms of signal transmission such as a propagating electrical or electromagnetic signal per se to the extent that they are not eligible for patent protection under 35 U.S.C. 101. A computer readable non transitory storage medium may be volatile non volatile or a combination of volatile and non volatile where appropriate.

This disclosure contemplates one or more computer readable storage media implementing any suitable storage. In particular embodiments a computer readable storage medium implements one or more portions of processor such as for example one or more internal registers or caches one or more portions of memory one or more portions of storage or a combination of these where appropriate. In particular embodiments a computer readable storage medium implements RAM or ROM. In particular embodiments a computer readable storage medium implements volatile or persistent memory. In particular embodiments one or more computer readable storage media embody software. Herein reference to software may encompass one or more applications bytecode one or more computer programs one or more executables one or more instructions logic machine code one or more scripts or source code and vice versa where appropriate. In particular embodiments software includes one or more application programming interfaces APIs . This disclosure contemplates any suitable software written or otherwise expressed in any suitable programming language or combination of programming languages. In particular embodiments software is expressed as source code or object code. In particular embodiments software is expressed in a higher level programming language such as for example C Perl or a suitable extension thereof. In particular embodiments software is expressed in a lower level programming language such as assembly language or machine code . In particular embodiments software is expressed in JAVA. In particular embodiments software is expressed in Hyper Text Markup Language HTML Extensible Markup Language XML or other suitable markup language.

Herein or is inclusive and not exclusive unless expressly indicated otherwise or indicated otherwise by context. Therefore herein A or B means A B or both unless expressly indicated otherwise or indicated otherwise by context. Moreover and is both joint and several unless expressly indicated otherwise or indicated otherwise by context. Therefore herein A and B means A and B jointly or severally unless expressly indicated otherwise or indicated otherwise by context.

This disclosure encompasses all changes substitutions variations alterations and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend. Similarly where appropriate the appended claims encompass all changes substitutions variations alterations and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend. Moreover reference in the appended claims to an apparatus or system or a component of an apparatus or system being adapted to arranged to capable of configured to enabled to operable to or operative to perform a particular function encompasses that apparatus system component whether or not it or that particular function is activated turned on or unlocked as long as that apparatus system or component is so adapted arranged capable configured enabled operable or operative.

