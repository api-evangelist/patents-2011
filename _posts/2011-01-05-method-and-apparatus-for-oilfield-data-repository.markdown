---

title: Method and apparatus for oilfield data repository
abstract: The invention relates to a method for performing operations of an oilfield having at least one wellsite, a surface network, and a process facility, each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The method includes storing oilfield data associated with a plurality of oilfield entities in a first data repository, obtaining a first target metamodel comprising structural description of a first plurality of data entities of the first data repository, obtaining a domain metamodel interleaved with a first mapping specification, the domain metamodel comprising structural description of a domain model for representing the plurality of oilfield entities in an application programming interface, obtaining a mapping specification associating the first target metamodel with the domain metamodel and forming the application programming interface based on the domain metamodel, the first target metamodel, and the first mapping specification using a computer implemented method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08326888&OS=08326888&RS=08326888
owner: Schlumberger Technology Corporation
number: 08326888
owner_city: Sugar Land
owner_country: US
publication_date: 20110105
---
This continuation patent application claims benefit of priority to U.S. patent application Ser. No. 11 873 366 to Shoen et al. filed Oct. 16 2007 and entitled Method and Apparatus for Oilfield Data Repository incorporated herein by reference in its entirety which in turn claims benefit of priority to U.S. Provisional Patent Application No. 60 852 175 filed on Oct. 16 2006 and incorporated herein by reference in its entirety.

The present invention relates to techniques for performing oilfield operations relating to subterranean formations having reservoirs therein. More particularly the invention relates to techniques for performing oilfield operations involving an analysis of reservoir operations and the impact on such oilfield operations.

Oilfield operations such as surveying drilling wireline testing completions simulation planning and oilfield analysis are typically performed to locate and gather valuable downhole fluids. Various aspects of the oilfield and its related operations are shown in . As shown in surveys are often performed using acquisition methodologies such as seismic scanners to generate maps of underground structures. These structures are often analyzed to determine the presence of subterranean assets such as valuable fluids or minerals. This information is used to assess the underground structures and locate the formations containing the desired subterranean assets. Data collected from the acquisition methodologies may be evaluated and analyzed to determine whether such valuable items are present and if they are reasonably accessible.

As shown in one or more wellsites may be positioned along the underground structures to gather valuable fluids from the subterranean reservoirs. The wellsites are provided with tools capable of locating and removing hydrocarbons from the subterranean reservoirs. As shown in drilling tools are typically advanced from the oil rigs and into the earth along a given path to locate the valuable downhole fluids. During the drilling operation the drilling tool may perform downhole measurements to investigate downhole conditions. In some cases as shown in the drilling tool is removed and a wireline tool is deployed into the wellbore to perform additional downhole testing.

After the drilling operation is complete the well may then be prepared for production. As shown in wellbore completions equipment is deployed into the wellbore to complete the well in preparation for the production of fluid therethrough. Fluid is then drawn from downhole reservoirs into the wellbore and flows to the surface. Production facilities are positioned at surface locations to collect the hydrocarbons from the wellsite s . Fluid drawn from the subterranean reservoir s passes to the production facilities via transport mechanisms such as tubing. Various equipments may be positioned about the oilfield to monitor oilfield parameters and or to manipulate the oilfield operations.

During the oilfield operations data is typically collected for analysis and or monitoring of the oilfield operations. Such data may include for example subterranean formation equipment historical and or other data. Data concerning the subterranean formation is collected using a variety of sources. Such formation data may be static or dynamic. Static data relates to for example formation structure and geological stratigraphy that define the geological structure of the subterranean formation. Dynamic data relates to for example fluids flowing through the geologic structures of the subterranean formation over time. Such static and or dynamic data may be collected to learn more about the formations and the valuable assets contained therein.

Sources used to collect static data may be seismic tools such as a seismic truck that sends compression waves into the earth as shown in . These waves are measured to characterize changes in the density of the geological structure at different depths. This information may be used to generate basic structural maps of the subterranean formation. Other static measurements may be gathered using core sampling and well logging techniques. Core samples may be used to take physical specimens of the formation at various depths as shown in . Well logging typically involves deployment of a downhole tool into the wellbore to collect various downhole measurements such as density resistivity etc. at various depths. Such well logging may be performed using for example the drilling tool of and or the wireline tool of . Once the well is formed and completed fluid flows to the surface using production tubing as shown in . As fluid passes to the surface various dynamic measurements such as fluid flow rates pressure and composition may be monitored. These parameters may be used to determine various characteristics of the subterranean formation.

Sensors may be positioned about the oilfield to collect data relating to various oilfield operations. For example sensors in the drilling equipment may monitor drilling conditions sensors in the wellbore may monitor fluid composition sensors located along the flow path may monitor flow rates and sensors at the processing facility may monitor fluids collected. Other sensors may be provided to monitor downhole surface equipment or other conditions. The monitored data is often used to make decisions at various locations of the oilfield at various times. Data collected by these sensors may be further analyzed and processed. Data may be collected and used for current or future operations. When used for future operations at the same or other locations such data may sometimes be referred to as historical data.

The processed data may be used to predict downhole conditions and make decisions concerning oilfield operations. Such decisions may involve well planning well targeting well completions operating levels production rates and other operations and or conditions. Often this information is used to determine when to drill new wells re complete existing wells or alter wellbore production.

Data from one or more wellbores may be analyzed to plan or predict various outcomes at a given wellbore. In some cases the data from neighboring wellbores or wellbores with similar conditions or equipment may be used to predict how a well will perform. There are usually a large number of variables and large quantities of data to consider in analyzing oilfield operations. It is therefore often useful to model the behavior of the oilfield operation to determine the desired course of action. During the ongoing operations the operating conditions may need adjustment as conditions change and new information is received.

Techniques have been developed to model the behavior of various aspects of the oilfield operations such as geological structures downhole reservoirs wellbores surface facilities as well as other portions of the oilfield operation. Typically there are different types of simulators for different purposes. For example there are simulators that focus on reservoir properties wellbore production or surface processing. Examples of simulators that may be used at the wellsite are described in U.S. Pat. No. 5 992 519 and WO2004 049216. Other examples of these modeling techniques are shown in Patent Publication Nos. U.S. Pat. No. 5 992 519 U.S. Pat. No. 6 313 837 WO1999 064896 WO2005 122001 US2003 0216897 US2003 0132934 US2005 0149307 and US2006 0197759.

Recent attempts have been made to consider a broader range of data in oilfield operations. For example U.S. Pat. No. 6 980 940 to Gurpinar discloses integrated reservoir optimization involving the assimilation of diverse data to optimize overall performance of a reservoir. In another example Patent Application No. WO2004 049216 to Ghorayeb discloses an integrated modeling solution for coupling multiple reservoir simulations and surface facility networks. Other examples of such recent attempts are disclosed in Patent Publication Application Nos. U.S. Pat. No. 6 018 497 U.S. Pat. No. 6 078 869 U.S. Pat. No. 6 106 561 U.S. Pat. No. 6 230 101 U.S. Pat. No. 7 164 990 GB2336008 US2006 0129366 US2004 0220846 US2006 0184329 and U.S. Ser. No. 10 586 283. Some techniques involve mapping data between a data base format and an object oriented format are described for example in European Patent Application Nos. 1383056 1385100 1696348 U.S. Pat. Nos. 694 598 5 765 159 5 829 006 and PCT Patent Application No. WO1999 032996.

Despite the development and advancement of managing oilfield data for oilfield operations there remains a need to provide techniques capable of automatically generating an object oriented application programming interface or object API allowing oilfield data to be accessed from a data repository of various formats. It would be desirable to have a system that allows oilfield data throughout the oilfield operation to be stored in a data repository suitable for retrieving large amounts of very specific information. One such example is a relational database which has a constant time overhead associated with each query therefore suitable for applications that retrieve large datasets infrequently. In some cases it may be desirable to access oilfield data through object APIs which emphasize object to object navigation. In other cases it may be desirable to eliminate expensive overhead caused by frequent suboptimal queries that retrieve single items of information. It is further desirable that such techniques be capable of one of more of the following among others mapping one application programming interface to multiple data repositories with different formats accessing oilfield data from different oilfield functions using consistent interface to request data based on oilfield entities automatically producing and maintaining mappings associating relational data with object data implementing such mappings by generating a source code of an object library that when compiled provides an object view of relational data.

In general in one aspect the invention relates to a method for performing operations of an oilfield having at least one wellsite a surface network and a process facility each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The method includes storing oilfield data associated with a plurality of oilfield entities in a first data repository obtaining a first target metamodel comprising structural description of a first plurality of data entities of the first data repository obtaining a domain metamodel interleaved with a first mapping specification the domain metamodel comprising structural description of a domain model for representing the plurality of oilfield entities in an application programming interface obtaining a mapping specification associating the first target metamodel with the domain metamodel and forming the application programming interface based on the domain metamodel the first target metamodel and the first mapping specification using a computer implemented method.

In general in one aspect the invention relates to a method for performing operations of an oilfield having at least one wellsite a surface network and a process facility each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The method includes storing oilfield data associated with a plurality of oilfield entities in a data repository obtaining a first structural description of a plurality of data entities of the data repository obtaining a second structural description of a representation of the plurality of oilfield entities in an application programming interface at least a portion of the representation of the plurality of oilfield entities is obtained from a reference metamodel obtaining a mapping specification associating the first structural description with the second structural description and forming the application programming interface based on the first structural description the second structural description and the mapping specification using a computer implemented method.

In general in one aspect the invention relates to a system for performing operations of an oilfield having at least one wellsite a surface network and a process facility each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The system includes a first structural description of a representation of a plurality of oilfield entities in an application programming interface wherein the application programming interface comprises an interface layer and an implementation layer wherein oilfield data associated with the plurality of oilfield entities is stored in a data repository accessible through the application programming interface a first plurality of hierarchical tasks for forming the interface layer of the application programming interface based on the first structural description and a code generator kernel for receiving user inputs and invoking the plurality of hierarchical tasks.

In general in one aspect the invention relates to a system for performing operations of an oilfield having at least one wellsite a surface network and a process facility each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The system includes a first structural description of a plurality of data entities of a data repository a second structural description of a representation of a plurality of oilfield entities in an application programming interface wherein oilfield data associated with the plurality of oilfield entities is stored in the data repository a mapping specification associating the first structural description with the second structural description a plurality of hierarchical tasks for forming the application programming interface based on the first structural description the second structural description and the mapping specification using a computer implemented method and a code generator kernel for receiving user inputs and invoking the plurality of hierarchical tasks to form the application programming interface.

In general in one aspect the invention relates to a method for performing operations of an oilfield having at least one wellsite a surface network and a process facility each wellsite having a wellbore penetrating a subterranean formation for extracting fluid from an underground reservoir therein. The method includes storing oilfield data associated with a plurality of oilfield entities in a data repository obtaining a first structural description of a plurality of data entities of the data repository obtaining a second structural description of a representation of the plurality of oilfield entities in an application programming interface obtaining a mapping specification associating the first structural description with the second structural description forming an interface layer of the application programming interface based on the second structural description and forming an implementation layer of the application programming interface based on the first structural description the second structural description and the mapping specification using a computer implemented method.

Other aspects and advantages of the invention will be apparent from the following description and the appended claims.

Presently preferred embodiments of the invention are shown in the above identified figures and described in detail below. In describing the preferred embodiments like or identical reference numerals are used to identify common or similar elements. The figures are not necessarily to scale and certain features and certain views of the figures may be shown exaggerated in scale or in schematic in the interest of clarity and conciseness.

In response to the received sound vibration s representative of different parameters such as amplitude and or frequency of the sound vibration s . The data received is provided as input data to a computer of the seismic recording truck and responsive to the input data the recording truck computer generates a seismic data output record . The seismic data may be further processed as desired for example by data reduction.

A surface unit is used to communicate with the drilling tool and offsite operations. The surface unit is capable of communicating with the drilling tool to send commands to drive the drilling tool and to receive data therefrom. The surface unit is preferably provided with computer facilities for receiving storing processing and analyzing data from the oilfield . The surface unit collects data output generated during the drilling operation. Computer facilities such as those of the surface unit may be positioned at various locations about the oilfield and or at remote locations.

Sensors S such as gauges may be positioned throughout the reservoir rig oilfield equipment such as the downhole tool or other portions of the oilfield for gathering information about various parameters such as surface parameters downhole parameters and or operating conditions. These sensors S preferably measure oilfield parameters such as weight on bit torque on bit pressures temperatures flow rates compositions and other parameters of the oilfield operation.

The information gathered by the sensors S may be collected by the surface unit and or other data collection sources for analysis or other processing. The data collected by the sensors S may be used alone or in combination with other data. The data may be collected in a database and all or select portions of the data may be selectively used for analyzing and or predicting oilfield operations of the current and or other wellbores.

Data outputs from the various sensors S positioned about the oilfield may be processed for use. The data may be historical data real time data or combinations thereof. The real time data may be used in real time or stored for later use. The data may also be combined with historical data or other inputs for further analysis. The data may be housed in separate databases or combined into a single database.

The collected data may be used to perform analysis such as modeling operations. For example the seismic data output may be used to perform geological geophysical reservoir engineering and or production simulations. The reservoir wellbore surface and or process data may be used to perform reservoir wellbore or other production simulations. The data outputs from the oilfield operation may be generated directly from the sensors S or after some preprocessing or modeling. These data outputs may act as inputs for further analysis.

The data is collected and stored at the surface unit . One or more surface units may be located at the oilfield or linked remotely thereto. The surface unit may be a single unit or a complex network of units used to perform the necessary data management functions throughout the oilfield . The surface unit may be a manual or automatic system. The surface unit may be operated and or adjusted by a user.

The surface unit may be provided with a transceiver to allow communications between the surface unit and various portions or regions of the oilfield or other locations. The surface unit may also be provided with or functionally linked to a controller for actuating mechanisms at the oilfield . The surface unit may then send command signals to the oilfield in response to data received. The surface unit may receive commands via the transceiver or may itself execute commands to the controller. A processor may be provided to analyze the data locally or remotely and make the decisions to actuate the controller. In this manner the oilfield may be selectively adjusted based on the data collected to optimize fluid recovery rates or to maximize the longevity of the reservoir and its ultimate production capacity. These adjustments may be made automatically based on computer protocol or manually by an operator. In some cases well plans may be adjusted to select optimum operating conditions or to avoid problems.

The wireline tool may be operatively linked to for example the geophones stored in the computer of the seismic recording truck of . The wireline tool may also provide data to the surface unit . As shown data output is generated by the wireline tool and collected at the surface. The wireline tool may be positioned at various depths in the wellbore to provide a survey of the subterranean formation.

While depict monitoring tools used to measure properties of an oilfield it will be appreciated that the tools may be used in connection with non oilfield operations such as mines aquifers or other subterranean facilities. Also while certain data acquisition tools are depicted it will be appreciated that various measurement tools capable of sensing properties such as seismic two way travel time density resistivity production rate etc. of the subterranean formation and or its geological structures may be used. Various sensors S may be located at various positions along the subterranean formation and or the monitoring tools to collect and or monitor the desired data. Other sources of data may also be provided from offsite locations.

The oilfield configuration in is not intended to limit the scope of the invention. Part or all of the oilfield may be on land and or sea. Also while a single oilfield at a single location is depicted the present invention may be used with any combination of one or more oilfields one or more processing facilities and one or more wellsites. Additionally while only one wellsite is shown it will be appreciated that the oilfield may cover a portion of land that hosts one or more wellsites. One or more gathering facilities may be operatively connected to one or more of the wellsites for selectively collecting downhole fluids from the wellsite s .

The respective graphs of contain static measurements that describe the physical characteristics of the formation. These measurements may be compared to determine the accuracy of the measurements and or for checking for errors. In this manner the plots of each of the respective measurements may be aligned and scaled for comparison and verification of the properties.

Data plots are examples of static data plots that may be generated by the data acquisition tools respectively. Static data plot is a seismic two way response time and may be the same as the seismic trace of . Static plot is core sample data measured from a core sample of the formation similar to the core sample of . Static data plot is a logging trace similar to the well log of . Data plot is a dynamic data plot of the fluid flow rate over time similar to the graph of . Other data may also be collected such as historical data user inputs economic information other measurement data and other parameters of interest.

The subterranean formation has a plurality of geological structures . As shown the formation has a sandstone layer a limestone layer a shale layer and a sand layer . A fault line extends through the formation. The static data acquisition tools are preferably adapted to measure the formation and detect the characteristics of the geological structures of the formation.

While a specific subterranean formation with specific geological structures is depicted it will be appreciated that the formation may contain a variety of geological structures. Fluid may also be present in various portions of the formation. Each of the measurement devices may be used to measure properties of the formation and or its underlying structures. While each acquisition tool is shown as being in specific locations along the formation it will be appreciated that one or more types of measurement may be taken at one or more location across one or more oilfields or other locations for comparison and or analysis.

The data collected from various sources such as the data acquisition tools of may then be evaluated. Typically seismic data displayed in the static data plot from the data acquisition tool is used by a geophysicist to determine characteristics of the subterranean formation . Core data shown in static plot and or log data from the well log is typically used by a geologist to determine various characteristics of the geological structures of the subterranean formation . Production data from the production graph is typically used by the reservoir engineer to determine fluid flow reservoir characteristics.

Each wellsite has equipment that forms a wellbore into the earth. The wellbores extend through subterranean formations including reservoirs . These reservoirs contain fluids such as hydrocarbons. The wellsites draw fluid from the reservoirs and pass them to the processing facilities via surface networks . The surface networks have tubing and control mechanisms for controlling the flow of fluids from the wellsite to the processing facility .

Wellbore production equipment extends from a wellhead of wellsite and to the reservoir to draw fluid to the surface. The wellsite is operatively connected to the surface network via a transport line . Fluid flows from the reservoir through the wellbore and onto the surface network . The fluid then flows from the surface network to the process facilities .

As further shown in sensors S are located about the oilfield to monitor various parameters during oilfield operations. The sensors S may measure for example pressure temperature flow rate composition and other parameters of the reservoir wellbore surface network process facilities and or other portions or regions of the oilfield operation. These sensors S are operatively connected to a surface unit for collecting data therefrom. The surface unit may be for example similar to the surface unit of .

One or more surface units may be located at the oilfield or linked remotely thereto. The surface unit may be a single unit or a complex network of units used to perform the necessary data management functions throughout the oilfield . The surface unit may be a manual or automatic system. The surface unit may be operated and or adjusted by a user. The surface unit is adapted to receive and store data. The surface unit may also be equipped to communicate with various oilfield equipment. The surface unit may then send command signals to the oilfield in response to data received or modeling performed.

As shown in the surface unit has computer facilities such as memory controller processor and display unit for managing the data. The data is collected in memory and processed by the processor for analysis. Data may be collected from the oilfield sensors S and or by other sources. For example oilfield data may be supplemented by historical data collected from other operations or user inputs.

The analyzed data e.g. based on modeling performed may then be used to make decisions. A transceiver not shown may be provided to allow communications between the surface unit and the oilfield . The controller may be used to actuate mechanisms at the oilfield via the transceiver and based on these decisions. In this manner the oilfield may be selectively adjusted based on the data collected. These adjustments may be made automatically based on computer protocol and or manually by an operator. In some cases well plans are adjusted to select optimum operating conditions or to avoid problems.

To facilitate the processing and analysis of data simulators may be used to process the data for modeling various aspects of the oilfield operation. Specific simulators are often used in connection with specific oilfield operations such as reservoir or wellbore simulation. Data fed into the simulator s may be historical data real time data or combinations thereof. Simulation through one or more of the simulators may be repeated or adjusted based on the data received.

As shown the oilfield operation is provided with wellsite and non wellsite simulators. The wellsite simulators may include a reservoir simulator a wellbore simulator and a surface network simulator . The reservoir simulator solves for hydrocarbon flow through the reservoir rock and into the wellbores. The wellbore simulator and surface network simulator solves for hydrocarbon flow through the wellbore and the surface network of pipelines. As shown some of the simulators may be separate or combined depending on the available systems.

The non wellsite simulators may include process and economics simulators. The processing unit has a process simulator . The process simulator models the processing plant e.g. the process facilities where the hydrocarbon s is are separated into its constituent components e.g. methane ethane propane etc. and prepared for sales. The oilfield is provided with an economics simulator . The economics simulator models the costs of part or the entire oilfield throughout a portion or the entire duration of the oilfield operation. Various combinations of these and other oilfield simulators may be provided.

As described above data plots are examples of oilfield data entities collected from various sources such as the data acquisition tools of . These oilfield data entities are associated with oilfield entities. For example the seismic trace may be associated with the formation and the core sample data may be associated with a portion of the formation such as the sandstone layer the limestone layer the shale layer the sand layer or the fault line where the core sample is collected. In another example the logging trace may be associated with a well monitored by the data acquisition tool and the fluid flow rate plot may be associated with the well monitored by the data acquisition tool . The collected oilfield data may be stored in a data repository or multiple data repositories as shown in later. The data repository or multiple data repositories may be located in the surface unit of . Data may then be simulated analyzed or otherwise processed by wellsite and non wellsite simulators or other modeling tools as described above. The processed data such as results generated by the wellsite and non wellsite simulators may then be further stored in the data repository or multiple data repositories. Data may be stored using different formats depending on for example a particular oilfield function e.g. drilling function production function reservoir engineering economic function etc. for which data is collected or generated. In general in one aspect the invention relates to technology for accessing data e.g. oilfield data stored in a data repository or multiple data repositories using an interface independent of the various formats of the data repository or multiple data repositories. This interface may be automatically generated. Examples of such data repository include relational database object oriented database or other forms of database or data store. An example of this interface is an object oriented application programming interface e.g. the Object API as shown in later . Object relational mapping ORM is a term that describes software technology that allows a program to view data stored in a database e.g. a relational database through an object oriented application programming interface.

Relational databases are designed to store large amounts of information. Information in relational databases is stored in different tables each defined to contain one or more columns each column containing a primitive item of information for example a string or a number. Programs add information to a relational database by adding rows containing values for one or more defined table defined columns to database tables and find information in relational databases by issuing queries. Typically all operations on a relational database are performed by operations expressed in a textual query language such as Structured Query Language SQL . The relational database is an example of the data repository or multiple data repositories described above. The tables columns rows and the primitive item of information are examples of data base entities. The relational interface such as queries or SQL are examples of commands for accessing data in the data repository or multiple data repositories.

The term relational database refers to the fact that a column in a row of one table can identify a row of another or the same table. This reference mechanism supports relations between rows of information. Relational databases can enforce consistency of information both between table rows and within table rows. Database designers may choose to declare integrity constraints that ensure that column data is valid for example that a column can never refer to a non existent table row. Defining such constraints is a recommended good practice but is not mandatory. Even when integrity constraints are designed they are not as readily visible to database programmers as is table structure. Thus while the physical model of data in the database the tables and their columns may be visible to developers the conceptual model the high level concepts represented by the tables and the relationships between tables which gives significant meaning to the data is not immediately obvious.

In addition the definitions of the tables included within a relational database can change over time. When these definitions change any application using a relational interface to access data in the database may also change to assure proper operation of the application. When a database is used by many independently developed applications it can be extremely difficult to identify all applications that are to be changed in response to a database definition change.

More importantly designers desire the flexibility to make applications store their data in a plurality of relational databases e.g. the multiple data repositories described above having different physical models e.g. based on a particular oilfield entity associated with the stored data and conceptual models e.g. based on a particular oilfield function for which data is collected or generated for . Good software engineering practices include the use of a software layer that insulates the application from the underlying database. The adaptor presents a single stable interface for the application program while supporting multiple backend implementations that are specific to each underlying database to be used. This approach solves the database portability problem for the application programmer but still requires significant coding investment for each backend database to be used. Moreover when the backend coding task is difficult because programming against relational databases is difficult the adaptor layer tends toward exposing a least common denominator view over the intersection of databases to be supported. Such views can ultimately render the adaptor useless as often critical and or valuable information cannot be stored and retrieved through the adaptor leading programmers to circumvent the adaptor.

These characteristics of relational programming can be the root level cause of many errors that only occur after an application has been delivered to its end users and has motivated the software industry to develop ORM tools.

Object oriented application programming interfaces APIs e.g. the Object API of are designed to make types and relationships explicit and obvious for programmers. Object interfaces such as the object APIs are well suited to expressing high level domain specific concepts. Domain refers to a relevant set of entities. For example oilfield domain may refer to a collection of oilfield data. In other examples a domain associated with a particular oilfield function e.g. drilling function production function reservoir engineering economic function etc. may refer to a portion of the collection of oilfield data related to the particular oilfield function. In these exemplary domains data object may be defined relating to physical oilfield entities e.g. a formation a well a process facility etc. . Entities or domain entities such as object types may be defined within a taxonomic hierarchy of a domain in which subtypes inherit the generic behavior of super types but either refine that behavior or add additional behavior. Furthermore well designed object interfaces completely encapsulate implementation details from applications that use the interfaces. This encapsulation allows the interface to remain stable while the underlying implementation changes.

Object based programming languages e.g. used for application as shown in later in general do not provide query persistence or integrity that relational databases provide. However a developer may explicitly declare types and relationships in object interfaces and a compiler for an object oriented programming language can verify that the application is performing legal operations on objects in an object oriented interface. The explicit declarations are a significant advantage for developers because the compiler can verify that the application is not attempting to violate domain level concepts before the application runs.

However query and persistence remains an issue for programmers using an object API. It is common practice in the software industry for developers to write his her own persistence mechanisms from scratch and also to simply not provide a query mechanism. Developers develop some mission critical software for a long life cycle and occasionally for accessing large persistent data stores. These issues also motivate tools to create object relational mapping adaptors.

ORM tools adapt relational programming interfaces such as queries or SQL to object oriented application programming interfaces and give programmers the encapsulation expressiveness and compile time safety of object interfaces while taking advantage of the efficiency and integrity offered by relational databases. The fundamental service of object relational mapping is to translate between data stored in columns of database table rows and data expressed through properties of related objects defined in a type hierarchy. ORM allows applications to perform the database operations of create update delete through the compile time safe object API while storing the data in the relational database. Some ORM tools also permit applications to perform the database operation of find with respect to data. Data may be for example oilfield data shown in and .

It should be noted that relational databases excel at retrieving large amounts of very specific information. This is because relational databases retrieve data in a set oriented manner efficiently returning data that matches a query predicate in a single potentially very large dataset. This relational query interface lends itself to applications that retrieve large datasets infrequently. Consequently there is a constant time overhead associated with each query. Ultimately the overhead causes frequent queries that retrieve single items of information to be very expensive. Unfortunately object APIs which emphasize object to object navigation can end up exercising a relational database for these suboptimal queries when the object model is mapped onto a relational database.

ORM tools come in many forms. Common to all tools is the need to state how relational data will be mapped to object data. Producing and maintaining these mappings can be an onerous task. An example of this invention includes an embodiment of an ORM tool that implements the mapping between an object interface and a relational interface by generating the source code of an object library that when compiled provides an object view e.g. for accessing data through the object APIs of relational data e.g. stored in the relational data base . The tool reduces the workload of software developers when creating and maintaining the object relational mapping. The ORM tool infers or derive much of the information that would ordinarily be entered manually by a person developing or maintaining a mapping. The inferred information includes 1 defaults for properties of domain objects 2 queries to find database entities that map to domain objects 3 queries to preload domain object properties with information from a complex web of interrelated database entities thus minimizing the suboptimal small query result usage pattern and 4 queries to follow relationships between database entities that are equivalent to relationships between domain objects.

The metamodels used as the target relational metamodel and possibly the reference metamodel are typically developed independently of the domain metamodel . Developers can expect that the information needed to populate them already exists in some machine readable form when they begin to define the domain metamodel . In particular the metamodel of a database can be used to supply information missing from the domain metamodel allowing the developer of the domain metamodel to specify only as much information as needed to make the combination of the domain metamodel and the reference metamodel complete.

The output from the code generator is source code in a particular programming language. The source code can be compiled by a compiler into a compiled domain model which may include a library of domain objects i.e. an object library . A domain object may relate to a type of oilfield entity e.g. a well a formation etc. . Domain object instances may be created or instantiated during execution or run time of the application from a domain object. A domain object instance may relate to a particular oilfield entity e.g. a particular well in an oilfield a particular portion of a formation etc. Accordingly an object API may be formed using the compiled domain model that allows an application to create update delete and find data in a relational database described by the input database metamodel for example the target relational metamodel . More details of an exemplary implementation of the object API are described in below.

For describing the target relational metamodel the IEntityMeta contains structural description of a database entity e.g. a table of a relational database the IPropertyMeta contains structural description of non relational data associated with the database entity e.g. an attribute of a relational database and IRelationalMeta contains structural description of relations between database entities e.g. a foreign key of a relational database .

The UML standard is well known to those skilled in art. For clarity the significance of the decorations at the end of the links between the interfaces is reiterated here.

The and 1 at the end of a link indicate cardinality of the object at that end of the link. 1 indicates one indicates zero or more. The use of the cardinality decorators is generally implicit in the UML. For example one ILinkMapping can refer to multiple IMappingConstraints . Similarly one IAttributeMapping and one IEntityMapping can also refer to many IMappingConstraints. One IEntityMapping can refer to multiple IEntityPartMappings IRelationMappings and IAttributeMappings.

The solid diamond indicates that the link is a composition. For example an IMappingConstraint cannot exist without being referred to from an IEntityMapping IAttributeMapping or ILinkMapping. For example to support the ability to delete an IEntityMapping any IMappingConstraint objects that the IEntityMapping also refers to need to be deleted.

The simple arrowheads such as pointing into IMappingConstraint indicate that the relation is navigable it is possible to enumerate all of the IMappingConstraints associated with an IEntityMapping IAttributeMapping or ILinkMapping.

The triangular arrowhead such as pointing into the bottom of ILinkMapping indicates an inheritance relation. IEntityPartMapping and IRelationMapping are both subtypes or subclasses of ILinkMapping.

As shown in the domain metamodel includes fmp IMetaProvider fe1 IEntityMeta fe2 IEntityMeta fp IProperty and fr IRelationMeta . The mapping specification includes mm IModelMapping em1 IEntityMapping am1 IAttributeMapping lm1 ILinkMapping and emp1 IEntityPartMapping . The target relational metamodel includes dmmp IMetaProvider dme1 IEntityMeta dme2 IEntityMeta dmp IProperty and dmr IRelationMeta . Each of the fmp IMetaProvider and dmmp IMetaProvider is an instance of the IMetaProvider . Each of the fe1 IEntityMeta fe2 IEntityMeta dme1 IEntityMeta and dme2 IEntityMeta is an instance of the IEntityMeta . Each of the fp IProperty and dmp IProperty is an instance of the IMetaProvider . Each of the fr IRelationMeta and dmr IRelationMeta is an instance of the IMetaProvider . The mm IModelMapping is an instance of the IModelMapping . The am1 IAttributeMapping is an instance of the IAttributeMapping . The lm1 ILinkMapping is an instance of the ILinkMapping . The emp1 IEntityPartMapping is an instance of the IEntityPartMapping .

Further shown in the mm IModelMapping maps the fmp IMetaProvider to the dmmp IMetaProvider using a hierarchical and recursive mapping structure by way of mappings performed by the em1 IEntityMapping am1 IAttributeMapping 1 ml ILinkMapping and emp1 IEntityPartMapping . The emp1 IEntityPartMapping is shown to have a recursive structure .

One example of a metamodel used as a target metamodel or a reference metamodel is the data dictionary of Seabed. Seabed is a relational database produced by Schlumberger Information Solutions for holding exploration and production information in support of a borehole operation. Other metamodels may also be used by configuring the metametamodel illustrated above to describe the structural format of the information contained in the metamodels so that the information may be provided to the Model Mapping Code Generator Task see .

Within the XML file line is an example of a structure described by IEntityMeta of line is an example of a structure described by IEntityMapping of line is an example of a structure described by IEntityMeta of line is an example of a structure described by IEntityMapping of line is an example of a structure described by IEntityPartMapping of line is an example of a structure described by IMappingConstraint of line is an example of a structure described by IPropertyMeta of line is an example of a structure described by IRelationMeta of line is an example of a structure described by IEntityMapping of line and line are examples of a structure described by IEntityPartMapping of . The indention between the lines and indicate three levels of hierarchical nesting as an example of the hierarchical recursive structure of mapping specification illustrated in .

The ORM tool implements nine distinct mapping capabilities based on the structure of the mapping specification and the abstraction of the domain model and data models described above 

Capabilities 1 2 and 3 are provided in object relational mapping tools. In the present invention the implementation of composition the relational queries that compose one database entity with another are not supplied by the developer of the mapping specification. Instead based on the structure of the mapping specification described above the developer of the mapping specification defines a domain object mapping in terms of a root database entity e.g. line in the XML file and zero or more ancillary part entities e.g. lines and in the XML file . Part entities may in turn be composed of other subpart entities in a recursive manner. The properties of a domain object map to attributes of the root entity or one of the ancillary part entities.

The queries to compose database entities are constructed automatically during code generation by analysis of the mapping specification i.e. the relationship between the root and its parts and parts and their subparts and the underlying relational metamodel. A part is specified by its database type. In many cases this is the only information the developer need provide in the specification for the code generator to determine the relational query that links entities in the database. Where there is more than one way to compose entities the developer needs to name the database relationship with which to compose the entities. In order to establish recursive relationships a developer specifies the directionality of the relationship. A recursive relationship is a relationship that links entities of the same type such as one used to compose a part whole hierarchy. Directionality specifies between two entities which entity is the parent and which entity is the child.

4. Hidden relationships allow one domain object to relate directly to another while in the data model the underlying data entities relate indirectly through intermediate data entities that are not exposed in the data model. Hiding relationships is a form of composition capability 3 but is well suited to hiding indirect relations that create one to many or many to many relationships. In this case the part entity may be many valued typically because it is related to the root or super part through a relation in which the subpart is the child . From each individual entity comprising the part the mapping then follows a single valued relation to a single entity which is then inversely mapped to a domain object. The collection of such entities is a multi valued relation in the domain model.

5. Hidden redundancy allows domain object to update a denormalized data model property or relation consistently. The mapping specification can contain any number of mappings for a domain property or relation the code generator creates code to set each such mapping.

This capability supports creating domain objects that map to root entities or compose parts with mandatory attribute values or which maintain a usage rule invariant.

7. Conditional attributes expose data entity attribute values through domain object properties when specified constraints are met the property has null value if the constraints are not met.

8. Relation abstraction allows the implementation of a domain model relation to be insulated from the underlying implementation of a data model relation e.g. direction or implementation technique . The mapping specification refers to relations that compose parts and subparts or which are exposed as domain object relation values by name only. The code generator is responsible for creating queries to expose the relation value the code that it generates is dependent upon the relation type e.g. traditional foreign key join or proprietary techniques that support non relational concepts relation directionality and cardinality. If the relation implementation changes in future versions of the database the mapping specification and the domain API exposed to programmers does not change.

9. Natural key semantics recognize that some domain object properties map onto data entity attributes controlled by unique key constraints such properties cannot be updated arbitrarily but instead must be treated as creating a reference to a different object which itself must be created if nonexistent .

As shown in ICodeGenerationHelper is an interface that identifies three additional interfaces IEntityGenerationHelper IPropertyGenerationHelper and IRelationGenerationHelper . In one example implementations of IEntityGenerationHelper contain methods that the DOGEntityGenerationTask uses to help to form the implementation of a domain type within the implementation of the domain API for a specific target database. In another example implementations of IPropertyGenerationHelper contain methods that DOGPropertyGenerationTask uses to form the implementation of a property of a domain type within the implementation of the domain API for a specific target database. In yet another example implementations of IRelationGenerationHelper contain methods that DOGRelationGenerationTask uses to form the implementation of a relation between one domain type and another domain type within the implementation of the domain API for a specific target database. The same DOGEntityGenerationTask DOGPropertyGenerationTask and DOGRelationGenerationTask can be used to generate code that implements the domain API for different target databases by using different implementations of IEntityGenerationHelper IPropertyGenerationHelper and IRelationGenerationHelper .

Consider the UWI property of the BoiBorehole domain object . Referring back to the UWI property maps to the UBHI attribute of the Seabed Borehole entity portion of the XML file . This is a straightforward mapping. The code for mapping the BoiBorehole domain object is generated by the following process using tasks illustrated in .

Finally DOGPropertyGenerationTask invokes the IPropertyGenerationHelper implementation for the Seabed database to create the code to set and get the UWI property. There are many possible ways to implement these operations. Fundamentally they involve a query to load the property and a query to save the updated property 

The tokens p0 and p1 represent parameters that allow the same queries to be executed multiple times referring to different boreholes or UBHI string values. The actual values to use in the query are provided externally to the parameters. A relational database may substitute the actual values into the actual query when it processes the query request.

Next referring back to consider the BusinessAssociateList relation exposed by BoiBorehole . This is a significantly more complicated query because it involves relation hiding and abstraction.

1. Once again the DOGEntityGenerationTask and DOGPropertyGenerationTask objects of are responsible for creating the BoiBorehole domain object declaration 

Note that the BusinessAssociateList property is get only. This is because the DOGRelationGenerationHelper recognizes that the relation is multi valued. When the relation is multi valued application code may only get the value of the relation but can subsequently add and remove from the returned collection.

2. The DOGRelationGenerationTask asks the IRelationGenerationHelper implementation for the Seabed database to supply code that queries the database to find the BBAI part of the BoiBorehole domain object. Referring to BBAI is defined as the set of Borehole BA Involvement entities whose Involvement Role is the value Project Team . Implicit in the relationship between the Borehole and the Borehole BA Involvement entities is the Borehole relation that links the Borehole BA Involvement to its Borehole. Thus the query to find the set of Borehole BA Involvement entities that includes the BBAI part is 

In this query the parameter p1 is bound to the string Project Team. Passing the constraint value by parameter allows the relational database to reprocess the same query with potentially different bindings for p1. More importantly passing the constraint value by parameter prevents a SQL Injection Attack. A SQL injection attack involves passing malformed strings to the relational query interface that causes the database server to damage or destroy critical data.

3. The DOGRelationGenerationTask asks the IRelationGenerationHelper implementation for Seabed to supply code that queries the database to find the set of Business Associate entities associated with the BBAI part. The helper generates code that executes this query 

This query nests the previous query as a subquery. It is also within the scope of the invention for the generated implementation to cache the Id values of the entities that comprise the BBAI part and to supply those values in the query to find the Business Associate entities 

4. The DOGRelationGenerationTask creates code to respond to add and remove events from the multi valued collection. In response to a BoiBusinessAssociate being added to the list the IRelationGenerationHelper generates code that creates a new Borehole BA Involvement and relates it to the Borehole and the Business Associate entities in the database. In response to removing a BoiBusinessAssociate from the list it generates code that removes the appropriate Borehole BA Involvement from the database.

Also shown in BOI3 BoiSurvey BOI3 BoiBusinessAssociate BOI3 BoiWell and BOI3 BoiActivity describe other types in the BOI drilling domain model.

As shown in the relational metamodel may include multiple Generic Borehole Activities Deviation Surveys Borehole BA Involvement and Borehole Statuses associated with one Borehole. Here BA stands for Business Associate e.g. company person etc. and Borehole BA Involvement supports encoding a many to many relationship between boreholes and business associates.

A single well may be associated with multiple boreholes. A Deviation Survey and a Borehole Activity are subtypes of Activity . A Generic Borehole Activity is a subtype of Borehole Activity . A Business Associate Well Borehole and Activity are all subtypes of Entity which is a subtype of IT Object .

Some of the links in are labeled for clarity. For example the link between Borehole and Borehole BA Involvement is labeled Borehole. This identifies the name of the relation in the Seabed metamodel that associates a Borehole BA Involvement with a Borehole . There is a link from Activity to itself called Super. This means an activity can have zero or one parent activities and is a concise way of illustrating that activities can form a tree hierarchy. The decoration . . . in indicates zero or one objects.

The invention may be implemented on virtually any type of computer regardless of the platform being used. For example as shown in a computer system includes a processor associated memory a storage device and numerous other elements and functionalities typical of today s computers not shown . The computer may also include input means such as a keyboard and a mouse and output means such as a monitor . The computer system is connected to a local area network LAN or a wide area network for example the Internet via a network interface connection or transceiver not shown . A transceiver is a device that transmits data by a wired or wireless connection. Those skilled in the art will appreciate that these input and output means may take other forms.

Further those skilled in the art will appreciate that one or more elements of the computer system may be located at a remote location and connected to the other elements over a network. Further the invention may be implemented on a distributed system having a plurality of nodes where each portion of the invention for example object store layer communication layer simulation logic layer etc. may be located on a different node within the distributed system. In one embodiment of the invention the node corresponds to a computer system. Alternatively the node may correspond to a processor with associated physical memory. The node may alternatively correspond to a processor with shared memory and or resources. Further software instructions to perform an embodiment of the invention may be stored on a computer readable medium such as a compact disc CD a diskette a tape a file or any other computer readable storage device.

Specifically the architecture includes a visualization and graphical user interface infrastructure sub system a process workflow sub system a data sub system and a core system implementation and Ocean services sub system . In addition such an architecture may support a product family including Schlumberger Information Solutions products such as Core Petrel and Petrel AppShell. Furthermore a pluggable application module may connect to one or more subsystems. The pluggable application module may be made by a third party or by Schlumberger Information Solutions.

Further provides context for understanding the relationship between domain object services and the broader Ocean program. Domain object services include a portion of the Data Centric Software Infrastructure. Product family developers or programmers in turn use domain object services to create domain data classes.

Domain object services help to deliver a productive development environment for all Ocean developers. Domain object services extend the Core s domain object hosting service providing capabilities that are expected to fit the needs of the data centric product families. These include 

Domain object services extend the Ocean Core s Domain Object Hosting DOH layer. Domain object services complement DOH. Ocean is establishing rules for domain object behavior e.g. multithreading support unit and coordinate data exposure domain objects must comply with these rules.

Domain object services may also be involved in the bridge between domain objects which represent entity and attribute data in a data model and bulk data which represents open ended streams of data associated with a variety of entities.

Product families may require domain APIs to access data from different data sources. These include commercial third party databases as well as proprietary customer databases.

Some data centric products may need to work with data exposed through a classic connections as opposed to meta driven API connections . Access to data exposed through an object model instead of a relational model has architectural significance for domain object services.

As shown in a domain object from application may present a query at the domain object API . Domain object services may then be performed. Prior to presenting the query to the data store a query may be revised by refactoring broadening and through query formation . The query formation module may convert a query to a format native to the data store .

Next a data object management module may convert results from queries into data objects. The data object management module may rely upon cached data objects for data and update such cached data objects. Next a data object refactoring module may aggregate multiple data objects into a single data object. Alternatively the data object re factoring module may convert a data object into separate data objects each of which can be shared between multiple domain objects. The unseparated data object may have been created because of a join into separate data objects. In addition the data object re factoring module may rename attributes. Such data objects are passed to the domain object management module .

Data object management module may map data objects to domain objects according to mapping specifications. Mapping specifications may be for example mapping specification of .

Runtime metadata provides a machine interpretable description of a data model schema. This meta data is used for a number of tasks. This metadata is used for a number of tasks such as enumerating the entity types in a data model enumerating the attributes of an entity identifying the type and constraints that apply to an attribute and identifying the relations in which entities may participate.

Further shows the architecturally significant design packages that include domain object services. The runtime domain object services package may be compared to a pipeline operations on the domain model e.g. create read update delete enter at the top of the pipeline and flow down to the data store level being modified by stages in the pipeline. Results flow back up the pipeline ultimately exiting at the top in the appropriate form as domain objects or as status indications . Responsibility and collaboration information for each package follows.

Optional elements can be configured into the pipeline according to the demands of the application. This configuration can be specified globally but can be overridden on a per domain object type basis. In the component collaboration discussion that follows components are marked as mandatory or optional however collaborations are discussed as if each possible component is configured. One skilled in the art should understand that if a collaborator component is not be configured into the pipeline then the specific component being discussed collaborates with the next component in the pipeline instead. Also in the discussion that follows for each component of the pipeline the Responsibility section describe the function of the component the Rationale section describes the purpose of the function and the Collaborators section describes other components that collaborate with this component in performing the function. It is noted that collaborations with other components in the pipeline are only described where needed.

As shown in the application finds all BoiActualOperationDataPoint objects that reflect a drilling rig in the Test state by creating a QueryCriteria object for BoiActualOperationDataPoint. Each type in the domain model defines a nested type called QueryCriteria. The properties of the QueryCriteria object correspond directly to the properties of the associated domain model type. For example BoiActualOperationDataPoint has a RigState property which holds a string value. The corresponding QueryCriteria object also has a RigState property but the value of QueryCriteria.RigState is a QueryConstraint which allows the application to support a value and a comparison operator. This is useful for example to find all boreholes with a bottom depth greater than 2000 m or all BoiActualOperationDataPoint objects with a RigState whose name begins with T. The QueryCriteria object is automatically generated by the code generator by examining the properties of the corresponding domain model type in the domain metamodel. The significance is that queries are the same regardless of the underlying relational metamodel that are ultimately being queried. This insulates application code from changes in the underlying database.

As shown in this simple case of finding a value using an exact string match the QueryConstraint type assigns a simple string value and converts the string value to a QueryConstraint object using an exact match comparison operator and the given string value. The application hands the completed QueryCriteria object to the fa ade accessor for BoiActualOperationDataPoint. Accessors are a type generated to perform bookkeeping over objects in the domain. Every domain object has a corresponding accessor type which is used to create new objects delete existing objects perform queries for objects and to raise notification events upon object creation deletion and change. More details can be found in .

In addition to what is shown in the fa ade accessor finds the appropriate implementation accessor for the domain type in the specific data source being queried. The implementation accessor analyzes the QueryCriteria object and generates a query that corresponds to what the application wanted at the domain level but in the terms of the relational data model associated with the specific data source being queried. This happens in the Model Mapping of . The query is pushed down into the data access stack in the rest of the U shaped figure of . Results from the query are pushed back up to the Domain Object Management where implementation objects are materialized for the resulting table rows found by the query and then fa ade objects are materialized for the implementation objects.

It can be seen in that the Super relationship between Generic Borehole Activity and Deviation Survey is a so called Assoc type relation which is implemented through a relational view onto a special table. This is because the Super relation needs to encode semantics that cannot be directly encoded by relational database technology it is many to many and it is abstract. As a result each instance of the Super relation is held in a table row in a view called in this case Deviation Survey Ref which points at both the source and target of the relation and identifies the types of relational entities involved in the relation instance. It is evident from the above description that the query created at the domain level in is complex when expressed at the data level.

The code necessary to convert the domain query to the relational query is automatically generated by the domain object generator using information in the mapping specification the domain metamodel and the relational metamodel. The steps in and are performed in the model mapping of

For better performance the application provides the data access stack with information regarding properties of domain object that the application may access. It is usually just as fast to load multiple columns from a relational database as it is to load a single column. For example the data may be preloaded rather than hitting the database for every domain object as it is used. This process is called priming. illustrates the application finding all boreholes in the data source and then asking the stack to prime the TopDepth and UWI properties of that collection of objects. This is performed in the Domain Object API of

As shown in oilfield data e.g. seismic survey well log etc. associated with oilfield entities e.g. wellbore reservoir etc. is stored in a first data repository Step e.g. a relational database etc. A first target metamodel such as the metamodel described in above is then obtained Step . The first target metamodel includes structural description of data entities e.g. database rows and columns etc. of the first data repository. A domain metamodel such as the metamodel described in above and a first mapping specification such as the metamodel described in above are also obtained Step . The domain metamodel includes structural description of a domain model for representing the oilfield entities in an application programming interface e.g. an object oriented API . The first mapping specification associates the domain metamodel and the first target metamodel such as the example described in above. In some examples the domain metamodel and the first mapping specification may be interleaved such as the example described in above. In other examples a portion of the domain model representing the oilfield entities is obtained from a reference metamodel Step e.g. the reference metamodel of . Finally based on the domain metamodel the first target metamodel and the first mapping specification the application programming interface is formed using a computer implemented method Step e.g. the code generator of . Oilfield data may then be accessed from the first data repository using the application programming interface Step . In Step an interface layer of the application programming interface may be formed based on only the domain metamodel using the computer implemented method while an implementation layer of the application programming interface may be formed based on the domain metamodel the first target metamodel and the first mapping specification using the computer implemented method.

Optionally oilfield data e.g. seismic survey well log etc. associated with oilfield entities e.g. wellbore reservoir etc. may also be stored in a second data repository Step e.g. a relational database etc. . A second target metamodel such as the metamodel described in above may then be obtained Step . The second target metamodel includes structural description of data entities e.g. database rows and columns etc. of the second data repository. A second mapping specification such as the metamodel described in above may also be obtained Step . The second mapping specification associates the domain metamodel and the second target metamodel such as the example described in above. The application programming interface may then be further formed based on the second target metamodel and the second mapping specification using the same metamodel and the same computer implemented method as above Step . Oilfield data may then be accessed from the second data repository using the application programming interface Step .

An exemplary result of the method described above is illustrated in a drilling domain model application using Seabed database. Seabed is a relational database produced by Schlumberger Information Solutions for holding exploration and production information in support of a borehole operation. The exemplary domain model and mapping statistics for Seabed includes 100 domain objects 91 Seabed entities 618 simple properties 144 relations and 3 400 lines of indented XML. The exemplary generated code statistics include 250 000 lines of code half comment and half non comment and 291 compile time SQL queries. The exemplary results show that the code generation is a powerful mechanism for implementing mapping between data and domain models. The method described above creates code with consistent quality and completeness allows data models to evolve without affecting domain models and enables experimentation with alternative model mappings.

Furthermore the steps of portions or all of the process may be repeated as desired. Repeated steps may be selectively performed until satisfactory results achieved. For example steps may be repeated after adjustments are made. Adjustments to the oilfield operation may be made based on the oilfield data the simulation results the arrangement and other factors. Various combinations may be tried and compared to determine the best outcome. The process may be repeated as desired.

It will be understood from the foregoing description that various modifications and changes may be made in the preferred and alternative embodiments of the present invention without departing from its true spirit. For example the object API data repository and arrangement of the system may be altered to achieve the desired results. The data repository may be a relational database a non relational database or other types of data store. In an example the inputs to the code generator may be structured descriptions of physical models of oilfield entities and conceptual models of data entities in the form of a metamodel in which case the code generator includes a metametamodel for interpreting the input metamodels. In another example the inputs to the code generator may be in the form of a model in which case the code generator includes a metamodel for interpreting the input models. The metametamodel may have different number of components than given in the example above and describe various different structures of the domain metamodel the mapping specification and the target relational metamodel. Although details are given in examples above regarding the domain metamodel the mapping specification and the target relational metamodel each of them may consist of different number of components than described in the examples. Different structures of the domain metamodel may be used the mapping specification may consist of various forms of hierarchical structures e.g. varying number of nested levels and or different recursive structures and different structures of the target relational metamodel may also be used. For another example the interleaving structure of the domain metamodel and the mapping specification may vary the condition and structure of the mapping constraints may change and the hierarchical structure of the code generator tasks may also be altered to achieve the desired results.

This description is intended for purposes of illustration only and should not be construed in a limiting sense. The scope of this invention should be determined only by the language of the claims that follow. The term comprising within the claims is intended to mean including at least such that the recited listing of elements in a claim are an open group. A an and other singular terms are intended to include the plural forms thereof unless specifically excluded.

